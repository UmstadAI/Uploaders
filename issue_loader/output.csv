number,title,writer,is_open,body,comments
1214,Memory leak of 150MB per proof,mitschabaude,open,"Reported on discord:
![image](https://github.com/o1-labs/o1js/assets/20989968/b828a051-3a6e-4948-b453-dc5791df3875)
https://discord.com/channels/484437221055922177/1168969852296376461/1169230889058848778","[('dfstio', ""It was tested using the code in https://github.com/dfstio/minanft-lib/blob/large-contract/test/nftupdate.test.ts; one can clone the branch large-contract of the repo and run\r\n```typescript\r\nyarn test nftupdate.test\r\n```\r\nThe last message before the process hung was:\r\n```\r\nconsole.log\r\n    Sending update...\r\n\r\n      at MinaNFT.commit (src/minanft.ts:411:13)\r\n\r\n  console.log\r\n    {\r\n      rss: '6580.5 MB -> Resident Set Size - total memory allocated for the process execution',\r\n      heapTotal: '940.09 MB -> total size of the allocated heap',\r\n      heapUsed: '882.47 MB -> actual memory used during the execution',\r\n      external: '47.01 MB -> V8 external memory'\r\n    }\r\n\r\n      at memory (test/nftupdate.test.ts:232:11)\r\n\r\n  console.log\r\n    Updating, iteration 17...\r\n\r\n      at Object.<anonymous> (test/nftupdate.test.ts:169:15)\r\n\r\n  console.log\r\n    Creating proofs...\r\n\r\n      at MinaNFT.generateProof (src/minanft.ts:475:13)\r\n```""), ('dfstio', ""On the first iterations, the RSS is 4444 MB:\r\n```\r\n console.log\r\n    Updating, iteration 2...\r\n\r\n      at Object.<anonymous> (test/nftupdate.test.ts:169:15)\r\n\r\n  console.log\r\n    Creating proofs...\r\n\r\n      at MinaNFT.generateProof (src/minanft.ts:475:13)\r\n\r\n  console.time\r\n    Proofs created: 95195 ms\r\n\r\n      at MinaNFT.generateProof (src/minanft.ts:504:13)\r\n\r\n  console.log\r\n    Commiting updates to blockchain...\r\n\r\n      at MinaNFT.commit (src/minanft.ts:388:13)\r\n\r\n  console.log\r\n    Sending update...\r\n\r\n      at MinaNFT.commit (src/minanft.ts:411:13)\r\n\r\n  console.log\r\n    {\r\n      rss: '4444.42 MB -> Resident Set Size - total memory allocated for the process execution',\r\n      heapTotal: '1119.06 MB -> total size of the allocated heap',\r\n      heapUsed: '1075.65 MB -> actual memory used during the execution',\r\n      external: '63.84 MB -> V8 external memory'\r\n    }\r\n\r\n      at memory (test/nftupdate.test.ts:232:11)\r\n\r\n  console.log\r\n    Updating, iteration 3...\r\n\r\n\r\n```"")]"
1213,Faster field inversions,mitschabaude,open,,[]
1212,Faster Field conversion,mitschabaude,open,,[]
1211,Remove Poseidon bottleneck,mitschabaude,open,,[]
1210,Passing MerkleWitnesses to ZKProgram causes a Stack_overflow compilation error when compiling the first,dfstio,open,"When trying to compile ZKProgram MapCalculation, the following error occurs:

```
thrown: Array [
      248,
      MlBytes {
        ""c"": ""Stack_overflow"",
        ""l"": 14,
        ""t"": 0,
      },
      -9,
    ]
```

The error is caused by MerkleMapWitness being passed as an argument.
However, if uncomment the line
```typescript
//await Key.compile();
```
the MapCalculation compiles without errors.
If you add some logic to the MapCalculation, errors always occur and do not disappear if MapCalculation compiles second.

The source code to reproduce the error:
```typescript
import { describe, expect, it } from ""@jest/globals"";
import {
  Field,
  SmartContract,
  state,
  State,
  method,
  Experimental,
  Struct,
  MerkleMapWitness,
} from ""o1js"";

jest.setTimeout(1000 * 60 * 60); // 1 hour

class Key extends SmartContract {
  @state(Field) key = State<Field>();

  @method mint(key: Field) {
    this.key.assertEquals(Field(0));
    this.key.set(key);
  }
}

class MapElement extends Struct({
  originalRoot: Field,
  redactedRoot: Field,
  key: Field,
  value: Field,
  originalWitness: MerkleMapWitness,
  redactedWitness: MerkleMapWitness,
}) {}

class MapState extends Struct({
  originalRoot: Field,
  redactedRoot: Field,
}) {
  static create(element: MapElement) {
    return new MapState({
      originalRoot: element.originalRoot,
      redactedRoot: element.redactedRoot,
    });
  }

  static assertEquals(state1: MapState, state2: MapState) {
    state1.originalRoot.assertEquals(state2.originalRoot);
    state1.redactedRoot.assertEquals(state2.redactedRoot);
  }
}

const MapCalculation = Experimental.ZkProgram({
  publicInput: MapState,

  methods: {
    create: {
      privateInputs: [MapElement],

      method(state: MapState, element: MapElement) {
        const computedState = MapState.create(element);
        MapState.assertEquals(computedState, state);
      },
    },
  },
});

describe(""Compile a contract"", () => {
  it(""should compile a contract"", async () => {
    //await Key.compile();
    await MapCalculation.compile();
  });
});
```",[]
1207,Enable compiling smart contracts along with all zkprograms it depends on,mitschabaude,open,"**Why**: Currently, `zk deploy` fails if the contract uses a ZkProgram. The goal of this issue is provide an o1js API that the zkapp-cli can use to compile a contract along with all ZkPrograms it depends on.

**How**: For example, add a new option `SmartContract.compile({ compileDependencies?: boolean })`. Figuring out the ZkProgram dependencies should happen automatically if this option is used.
","[('dfstio', 'The better solution would be to enable SmartContract to be compiled, having only the verification key string and publicInput/publicOutput data of the ZKProgram (for example, Proof.dummy can be renamed and extended to accept the verification key string).\r\n\r\nIt will allow for significant time and memory savings when the ZKProgram proof is being generated in one process (for example, on AWS lambda) and is being used as an argument when calling the SmartContract method in a web application.\r\n\r\nUsually, compilation of ZKProgram, especially with interactive proofs, takes longer than compilation of the SmartContract, and there is no need to force compilation of the ZKProgram in case proofs are not going to be generated, just consumed.'), ('mitschabaude', 'Great point, thanks @dfstio! Both options might be valuable -- provide the ZkProgram verification keys, or compile all dependencies. If the ZkProgram compilation is cached, the second option might be reasonably fast as well')]"
1206,Possibly support `proofsEnabled` in ZkProgram,mitschabaude,open,"![image](https://github.com/o1-labs/o1js/assets/20989968/fb6192f6-552e-4628-aece-6832cc81556f)
",[]
1205,Make every API that needs OCaml/Rust async instead of awaiting at the top level,mitschabaude,open,"The web version of o1js still has a fairly large unavoidable import time (~0.5s). This used to happen in the first asynchronous microtask (and leaked to users through `await isReady`) and is now happening immediately with top-level await.

To enable quicker loading as well as prepare for https://github.com/o1-labs/o1js/issues/1192, the big async task should be awaited inside the functions that need it, not at the top level. There are just a few of those functions which aren't already async:

* `Provable.runAndCheck()` and `runUnchecked()` -- mostly used as part of `Mina.transaction()` which is already async
* `SmartContract.analyzeMethods()`
* `Provable.constraintSystem()` -- mostly used in `analyzeMethods()`
* `Mina.LocalBlockchain()`",[]
1195,Implement FFadd and FFMul in large prime fields,mitschabaude,open,"Application: RSA, zk-email, zk JWTs

Note: This is similar to https://github.com/o1-labs/o1js/issues/1142 and https://github.com/o1-labs/o1js/issues/1180, but those issues will be done for foreign fields up to 259 bits. For RSA, we need much bigger fields with sizes of 2048 bits or similar.

For small fields, there are targeted `FFadd` and `FFmul` custom gates which do addition or multiplication in a single gate (1-2 rows) plus a few range checks on outputs.

However, for large fields we don't have such specific custom gates. This issue is about implementing big-field arithmetic _without_ additional custom gates, only using available primitives.

Primitives that could be useful:
* native addition and multiplication `Field.add`, `Field.mul`
* `Gadgets.rangeCheck64` already exposed in o1js
* 3x88-bit range check that will be exposed as part of #1142 or #1180
* Bigint addition on 3 x 88-bit limbs that'll be exposed as part of #1142
* Possibly the ffmul gadget that'll be exposed as part of #1180",[]
1192,Split out o1js/lite package which can be loaded quickly on the web,mitschabaude,open,"In fact, we want 3 packages:

* `lite` - This package should contain everything needed for defining smart contracts and o1js helpers, but not anything related to running circuits (snarky) or proving or compiling (kimchi, pickles).
* `prover` - Includes the OCaml/Rust crypto dependencies to enable proving and related methods
* `testing` - Includes `LocalBlockchain` and its massive OCaml dependencies. Nore: this is not typically a dependency needed in user-facing apps. Mostly needed for testing during development",[]
1191,The problem with the order of actions returned by fetchActions,Comdex,open,"Now the order of actions returned by calling fetchActions is opposite to the order of transaction execution, which is not conducive for developers to implement the calculation of action state outside the circuit, because we cant simply sort the returned actions in reverse order (this does not apply when there are multiple actions in the same block).

I remember that this problem was fixed before. The reason why it reappears now seems to be that the order of results returned by Archive-Node-API is already the order we need (this was not the case before), but it was reversed in o1js.

https://github.com/o1-labs/o1js/blob/bb9cf00d6dbf74710690d5a2655e6205b05f9454/src/lib/fetch.ts#L955

```ts
let Blockchain = Mina.Network({
    mina: 'https://proxy.testworld.minaexplorer.com',
    archive: 'https://archive.testworld.minaexplorer.com',
  });
  Mina.setActiveInstance(Blockchain);
  let actions = await Mina.fetchActions(
    PublicKey.fromBase58(
      'B62qnd9Ub6kFjAwemb6534AeHMoVLMENgArGNAZ1bTH3DsJQwYfW2Po'
    )
  );

  console.log('actions: ', JSON.stringify(actions));
```
fetchActions result:
```json
[
    {
        ""actions"": [
            [
                ""7""
            ]
        ],
        ""hash"": ""28070093062662078916499520860561703477303560026817655981526893076442153210979""
    },
    {
        ""actions"": [
            [
                ""4""
            ]
        ],
        ""hash"": ""23738301534377930147872706760016946916884087570092081717864769695371553815740""
    },
    {
        ""actions"": [
            [
                ""5""
            ]
        ],
        ""hash"": ""16891113948507207555876484680132852726238336040234239181671265432067789635321""
    },
    {
        ""actions"": [
            [
                ""6""
            ]
        ],
        ""hash"": ""18241307966174365020070272932594687425553651419553221885978164300111705170677""
    },
    {
        ""actions"": [
            [
                ""1""
            ]
        ],
        ""hash"": ""14126484005541313471935487941009247632007934229859291061844286995942998079814""
    },
    {
        ""actions"": [
            [
                ""2""
            ]
        ],
        ""hash"": ""25022851442625413655674736193944689738867947575763044922384812023793434021995""
    },
    {
        ""actions"": [
            [
                ""3""
            ]
        ],
        ""hash"": ""1412358922281821052975075556724736322980844705018992777728351088320565280744""
    }
]
```

archive node api original result:
```json
[
    {
        ""blockInfo"": {
            ""distanceFromMaxBlockHeight"": 53
        },
        ""actionState"": {
            ""actionStateOne"": ""1412358922281821052975075556724736322980844705018992777728351088320565280744"",
            ""actionStateTwo"": ""25079927036070901246064867767436987657692091363973573142121686150614948079097""
        },
        ""actionData"": [
            {
                ""accountUpdateId"": ""4178"",
                ""data"": [
                    ""1""
                ]
            },
            {
                ""accountUpdateId"": ""4179"",
                ""data"": [
                    ""2""
                ]
            },
            {
                ""accountUpdateId"": ""4180"",
                ""data"": [
                    ""3""
                ]
            }
        ]
    },
    {
        ""blockInfo"": {
            ""distanceFromMaxBlockHeight"": 52
        },
        ""actionState"": {
            ""actionStateOne"": ""18241307966174365020070272932594687425553651419553221885978164300111705170677"",
            ""actionStateTwo"": ""1412358922281821052975075556724736322980844705018992777728351088320565280744""
        },
        ""actionData"": [
            {
                ""accountUpdateId"": ""4181"",
                ""data"": [
                    ""4""
                ]
            },
            {
                ""accountUpdateId"": ""4182"",
                ""data"": [
                    ""5""
                ]
            },
            {
                ""accountUpdateId"": ""4183"",
                ""data"": [
                    ""6""
                ]
            }
        ]
    },
    {
        ""blockInfo"": {
            ""distanceFromMaxBlockHeight"": 0
        },
        ""actionState"": {
            ""actionStateOne"": ""28070093062662078916499520860561703477303560026817655981526893076442153210979"",
            ""actionStateTwo"": ""18241307966174365020070272932594687425553651419553221885978164300111705170677""
        },
        ""actionData"": [
            {
                ""accountUpdateId"": ""4184"",
                ""data"": [
                    ""7""
                ]
            }
        ]
    }
]
```

",[]
1189,"Proof.fromJSON() for times in a process, failed with : RangeError: offset is out of bounds",coldstar1993,open,"I hv a zkProgram named `JoinSplitProver `and its Proof is `JoinSplitProof`. 
after compiling  `JoinSplitProver ` in the same process, I try to deserialize a json obj to `JoinSplitProof` for almost twenty times, and failed with '**RangeError: offset is out of bounds**'. 
code as below:
![image](https://github.com/o1-labs/o1js/assets/92623877/f1f7594f-baee-48cf-9de1-7306492caac5)

error stack as below:
![image](https://github.com/o1-labs/o1js/assets/92623877/1209c56d-1ed8-4568-81b6-e70979b6dc74)

I often meet this during circuit execution(witness calc, proof gen), but first time to meet it at `Deserialization`","[('Comdex', 'This seems to be related to the wasm memory leak problem. Similar to executing the proof generation multiple times in a process, the wasm memory will continue to be consumed and not released in time.')]"
1186,HF update branch compatibility in https://github.com/o1-labs/o1js/blob/main/README-dev.md#branch-compatibility,barriebyron,open,"The branch compatibility content requires an update for HF

https://github.com/o1-labs/o1js/blob/main/README-dev.md#branch-compatibility",[]
1185,Expose dummyBase64Proof(),maht0rz,closed,"Would it be possible to expose `dummyBase64Proof()`, or is there a specific reason not to?","[('mitschabaude', 'No reason, PR welcome!'), ('mitschabaude', 'Could be put as a static method on the `Proof` class maybe'), ('maht0rz', ""Just to add, we also need `Pickles` exposed to do `Pickles.proofOfBase64(...)`, i'll make a PR!""), ('mitschabaude', 'made a PR: https://github.com/o1-labs/o1js/pull/1188')]"
1180,Port FFadd and FFsub gadget to TypeScript,Trivo25,open,depends on interface to #1152,[]
1174,Remove Poseidon from PLUME [ERC 7524 incompatibility],Divide-By-0,closed,"We noticed that you deviated from [ERC 7524](https://github.com/ethereum/EIPs/pull/7775) in your implementation of the PLUME nullifier, namely by using the [Poseidon hash](https://github.com/o1-labs/o1js/blob/main/src/lib/nullifier.ts#L189) instead of the recommended hashes. We do not recommend that due to [slowdowns in hardware wallets](https://blog.aayushg.com/posts/nullifier#why-use-secp256k1_xmdsha-256_sswu_ro_-for-hash-to-curve). It is possible that there is something in your implementation that I missed -- open to hearing from your cryptographers!

Edit: Earlier I had mentioned there may be wallet exploits that may be caused by repeated exponentiations of Poseidon hashes, but that is not the case as there is a map_to_curve happening that immunizes against this.","[('Trivo25', 'Thanks for raising this issue! We talked this through in DMs, but just for the public records: \r\n\r\nWe use a [map to curve algorithm](https://github.com/o1-labs/snarky/blob/master/group_map/group_map.ml) which should allow us to prevent the issues mentioned in the blog post. By using this algorithm, we avoid the issue described below\r\n\r\n> Why do we not use a hash function like Poseidon? It turns out that Poseidon would actually lead to a critical vulnerability in ECDSA. Because we would know the pre-image of the final curve exponentiation, we would be able to generate a fake normal ECDSA signature for an arbitrary message. Basically, using the [terminology of ECDSA Wikipedia](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_generation_algorithm), we would know a valid k corresponding to some r (r in this case would be hash(m, pk)), for which we would receive back a PLUME signature that we could use as the last term in the ECDSA signature, add any message hash(m) to, then multiply by k^−1, hence creating an arbitrary ECDSA signing oracle from just one PLUME signature – this would be quite bad. Thus, we must use a hash function for which the final step is not a curve exponentiation.\r\n\r\nPlease let us know if you have any other concerns with our implementation, we highly appreciate your input - this is super important to deliver a robust and secure SDK for writing zero knowledge applications!'), ('Divide-By-0', ""@Trivo25 Continued discussion with Gregor leads me to conclude that yes, due to map_to_curve, your Poseidon hash to curve function is likely secure in the current implementation, because the final operation of your map to curve is not an exponentiation. However, it could be made faster both for calculation in hardware wallets and the client-side zk proof time.\r\n\r\n**Signature in Hardware Wallets**\r\n- We expect, via Markus's benchmarks, that Poseidon would make the ledger app have a 10-15 second slowdown compared to sha256, and you've noticed similar slowdowns in your ledger implementations: https://github.com/search?q=repo%3Ajspada%2Fledger-app-mina%20poseidon&type=code\r\n- We expect a switch to SHA to make this much faster\r\n\r\n**ZK Proof**\r\n- Geometry's post: https://geometry.xyz/notebook/Hashing-to-the-secp256k1-Elliptic-Curve#the-hashtocurve-algorithm > map_to_curve says that the default Shallue-van de Woestijne method that (that [you are using](https://github.com/o1-labs/snarky/blob/78e0d952518f75b5382f6d735adb24eef7a0fa90/group_map/group_map.ml)?) is slower than the Simplified SWU method for the secp256k1 curve specifically, which we optimized to make the zk circuit faster to compute client side. We would likely anticipate speedups from switching to Simplified SWU as well!"")]"
1172,Set feature flags in Pickles and Kimchi depending on custom gates used,mitschabaude,closed,"This is a requirement to make any of the custom gates work.

Both Kimchi and Pickles have a concept of ""feature flags"" which says which custom gates should be enabled. These have to be set on a per-circuit basis: The flags set to true exactly have to match the actual custom gates used in a circuit.

This will probably require some refactors in o1js since currently o1js isn't designed at all to look at the contents of a circuit before interacting with Kimchi / Pickles.

Here are places that use feature flags, which probably have to be hooked into dynamically from o1js (potentially non-exhaustive list!)
* Wasm bindings https://github.com/o1-labs/o1js-bindings/blob/571e1b2ea970623772efb4989f17459a4271503f/kimchi/wasm/src/plonk_verifier_index.rs#L642-L660
* Pickles bindings https://github.com/o1-labs/o1js-bindings/blob/a065bad2f3e62d961b70288ae70b2c71d5fc995e/ocaml/lib/pickles_bindings.ml#L253",[]
1169,Exercise more APIs during the live tests against real network (if makes sense),shimkiv,open,Maybe start with updating the https://github.com/o1-labs/o1js/blob/main/tests/integration/simple-zkapp.js,"[('mitschabaude', 'To me it would be interesting to run a variant of this one, which is fairly complicated and exercises a number of things: https://github.com/o1-labs/o1js/blob/main/src/examples/zkapps/dex/happy-path-with-actions.ts'), ('shimkiv', '[Internal details of tools needed](https://o1-labs.slack.com/archives/C028Q27R8UC/p1697731181038089?thread_ts=1697474701.828569&cid=C028Q27R8UC).')]"
1166,Recursive verification does not fail on proof from a foreign ZkProgram,mitschabaude,open,"Unexpected behaviour reported on discord: https://discord.com/channels/484437221055922177/1159491755469721611

![image](https://github.com/o1-labs/o1js/assets/20989968/961e0f8a-4e73-45a7-9413-627d754fd87a)

OCaml test: https://github.com/MinaProtocol/mina/compare/testing/mixing-proofs?expand=1",[]
1159,Port ECDSAVerify gadget to TypeScript,Trivo25,open,party depends on interfaces to #1153 #1157 #1154 #1155 ,[]
1158,Port EcCheckSubgroup gadget to TypeScript,Trivo25,open,,[]
1157,Port ECScale gadget to TypeScript,Trivo25,open,depends on #1153 #1154 ,[]
1156,Port ECIsOnCurve gadget to TypeScript,Trivo25,open,depends on #1157 ,[]
1155,Port ECNegate gadget to TypeScript,Trivo25,open,,[]
1154,Port ECDouble gadget to TypeScript,Trivo25,open,,[]
1153,Port ECAdd gadget to TypeScript,Trivo25,open,depends on interfaces to #1142 #1152 #1180 ,[]
1152,Port FFSum_check gadget to TypeScript,Trivo25,open,,[]
1149,mina-signer: use string instead of boolean for compilation option,nicc,open,We need to make the mina-signer change that goes with this PR: https://github.com/MinaProtocol/mina/pull/13232,"[('bkase', ""Context: If we don't expose this in mina-signer, it's not really real. Why is this feature important? It prevents replay attacks from an arbitrary string-labeled network (instead of just two, which isn't enough in a world with projects like [zeko](https://zeko.io/))"")]"
1148,Port LSL and LSR gadgets to TypeScript,nicc,open,,"[('Trivo25', 'depends on #1139')]"
1147,Port SHA-3 gadget to TypeScript,nicc,closed,,"[('Trivo25', 'same as #1146 ')]"
1146,Port Keccak (SHA3) gadget to TypeScript,nicc,open,partly depends on interfaces to #1138 #1140 #1141 #1139 #1148 ,[]
1145,Port ECDSA gadget to TypeScript,nicc,closed,,[]
1144,Port MUL gadget to TypeScript,nicc,closed,,[]
1143,Port ADD gadget to TypeScript,nicc,closed,,[]
1142,Port FFMUL gadget to TypeScript,nicc,open,,"[('chiro-hiro', 'Hi @nicc, are there any detail on this?.')]"
1141,Port NOT gadget to TypeScript,nicc,open,,"[('Trivo25', 'depends on #1138 ')]"
1140,Port AND gadget to TypeScript,nicc,closed,,"[('Trivo25', 'depends on #1138 ')]"
1139,Port ROT64 gadget to TypeScript,nicc,closed,,[]
1138,Port XOR gadget to TypeScript,nicc,closed,,[]
1137,Check opensource webkit to see if wasm memory limit will be raised ,nicc,open,,[]
1136,Automatically create a fortnightly release PR for o1js,nicc,open,See also: https://github.com/o1-labs/zkapp-cli/issues/495,"[('nicc', 'This would be step toward a release train.\n\nWhat does the PR do? Just bump version number?')]"
1135,Error: Invalid rich scalar: Field,coldstar1993,open,"My circuit dependency relationship is as: zkProgramC <-- zkProgramB <-- SmartContractA.  
I tried to trigger smartContractA with the proof from zkProgramB(zkProgramC), and get successful tx and broadcast at the first trigger.  However, when I trigger the second or more times, it throws an error as below:

```
Error: Invalid rich scalar: Field 10877295794357616459115299833550986754430745535593408272184814485138476140408
    at failwith (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:64877:50)
    at raise_invalid_scalar (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376100:36)
    at except (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376105:49)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376146:61
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376117:64
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at map$14 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:78942:49)
    at caml_call2 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7702:28)
    at _hH4_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376387:58)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at _hHV_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376441:40)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at count_map (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:77630:21)
    at func$3 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:77656:33)
    at _hKK_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375367:56)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at _hHV_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376441:40)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at creator (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375280:36)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376511:46
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at _g$b_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:401043:43)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376572:60
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at of_json (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375297:38)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at creator (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375270:33)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376511:46
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:401833:47
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376572:60
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at of_json (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375297:38)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at creator (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375270:33)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376511:46
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at _g7C_ (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:403186:38)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at /opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376572:60
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at of_json (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:375297:38)
    at caml_call1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7700:28)
    at of_json (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:376649:31)
    at caml_call2 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:7702:28)
    at account_update$1 (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:424307:56)
    at caml_call_gen (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:1987:17)
    at caml_call_gen (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:1990:16)
    at Object.accountUpdate (/opt/anomix_server/anomix-network/node_modules/o1js/dist/node/bindings/compiled/_node_bindings/snarky_js_node.bc.cjs:3581:16)
    at AccountUpdate.hash (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/account_update.js:638:44)
    at AccountUpdate.toPublicInput (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/account_update.js:642:34)
    at createZkappProof (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/account_update.js:1318:37)
    at addProof (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/account_update.js:1313:23)
    at addMissingProofs (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/account_update.js:1285:52)
    at Object.prove (file:///opt/anomix_server/anomix-network/node_modules/o1js/dist/node/lib/mina.js:158:50)
    at file:///opt/anomix_server/anomix-network/apps/proof-generators/dist/src/provers/proof-worker-AnomixRollupContract.js:28:30
    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)
    at async execCircuit (file:///opt/anomix_server/anomix-network/apps/proof-generators/dist/src/provers/proof-worker-AnomixRollupContract.js:42:21)
    at async process.<anonymous> (file:///opt/anomix_server/anomix-network/apps/proof-generators/dist/src/provers/proof-worker-AnomixRollupContract.js:14:17)
```

And then I reboot a new process again for repeated progress, it could always succeed at the first time, while all failed at second time.

So  I guess it's about the memory usage. Might be at the first time there is enough memory space, but from the second time, memory is not enough (perhaps it failed to release some memory? just guess.). 
","[('mitschabaude', ""It's weird, could you post the stack trace when running with\r\n```\r\nnode --enable-source-maps\r\n```\r\n""), ('mitschabaude', 'It would possibly be easy to fix by switching to the TS version in `AccountUpdate.hash()`')]"
1131,Explanation of buildWeb.js,directcuteo,open,Hello! Can someone describe what `buildWeb.js` is doing roughly? I can see that is altering some files but I am not sure what is the reason behind it. Thank you !!,[]
1130,Explain magic,L-as,open,"There is a lot of unexplained magic, which makes it unclear what is happening, e.g., when is an account update created?
When is it added as child? There is a lot documentation that could be written.",[]
1129,`getAndAssertEquals` -> `get` ?,L-as,open,"This is probably confusing for beginners,
especially when people do `x.assertEquals(x)`.

When would you use raw `get` over `fetch` anyway?","[('bkase', 'there are (rare) times where you want to get without asserting, and it seemed cleaner than requiring the two lines of code everytime.'), ('L-as', ""Yes but that is the special-case, and it should be named as such. `get` should assert, the original one should be renamed, and it's not clear to me how it's different from `fetch`.""), ('mitschabaude', ""I disagree, because adding a precondition is something that can have negative impact on UX, by introducing race conditions. Something like that shouldn't happen silently. That's why I prefer the more explicit `getAndAssertEquals()`\r\n\r\nRe difference:\r\n* `fetch()` is async and therefore can't be used in a smart contract method\r\n* `get()` is sync, and has two modes: one where it returns a dummy value and marks the account to be fetched, and one where it returns something from cache. By running the contract method twice and doing the fetch in between, we enable a synchronous API. This aspect of `get()` is really just a hack around not having async circuits (currently)\r\n* `get()` puts the result in a witness. using the `fetch()` result directly would mean you use a different constant every time you compile/prove the circuit, so it'd be broken"")]"
1126,method decorator doesn't work in browser,directcuteo,closed,"Whenever I import method decorator in my browser based application, I am receiving the following error.
![Screenshot 2023-09-20 at 14 11 54](https://github.com/o1-labs/o1js/assets/37619567/1d19d03b-1640-4da6-b016-0dcb474dff66)

This is the entire code:
```
import { Field, method, SmartContract } from ""o1js"";

class Square extends SmartContract {
  @method update(square: Field) {
  }
}
```

This code doesn't produce the error:

```
import { Field, method, SmartContract } from ""o1js"";

class Square extends SmartContract {
  // @method update(square: Field) {
  // }
}
```

How can I overcome this issue?","[('directcuteo', '### Update:\r\nLocation of the error:\r\nhttps://github.com/o1-labs/o1js/blob/0bc79959ecb54a49ffadee0f8c7143d4c52b4b9c/src/lib/proof_system.ts#L396\r\nIt seems that the error is coming because this code is ""broken"".\r\nhttps://github.com/o1-labs/o1js/blob/0bc79959ecb54a49ffadee0f8c7143d4c52b4b9c/src/lib/zkapp.ts#L98\r\n\r\nI changed the code to \r\n``` \r\nlet paramTypes: Provable<any>[] = Reflect.getMetadata(\r\n  \'design:paramtypes\',\r\n  target,\r\n  methodName\r\n) || [];\r\n```\r\n\r\nAnd now it seems to work.'), ('mitschabaude', 'Hey @directcuteo it sounds like whatever bundler pipeline you use isn\'t compiling decorators to JS as intended, so you get empty metadata. The ""fix"" you applied just silences the error but makes it work incorrectly and will probably cause an error later'), ('mitschabaude', 'The proper code change would be to throw the same error you observed but make the error message more informative'), ('mitschabaude', '@directcuteo you can get around decorators not working by using declareMethods / declareState instead of method / state decorators '), ('directcuteo', '@mitschabaude That is great piece of info!\r\nI am using again the `o1js 0.13.0`\r\n\r\nSo I added these 2 functions instead of the decorators. Now when the line `zkAppInstance.deploy()` is executed, I receive the following error:\r\n\r\n![Screenshot 2023-09-21 at 11 51 30](https://github.com/o1-labs/o1js/assets/37619567/d474b855-d0aa-41d5-8a8b-aaece9f4b3f7)\r\n\r\n\r\n### Here is the code \r\n\r\n```\r\n      class Square extends SmartContract {\r\n        num: State<Field>;\r\n\r\n        constructor(num: PublicKey) {\r\n          super(num);\r\n          this.num = State();\r\n        }\r\n\r\n        override init() {\r\n          super.init();\r\n          this.num.set(Field(3));\r\n        }\r\n\r\n        update(square: Field) {\r\n          const currentState = this.num.get();\r\n          this.num.assertEquals(currentState);\r\n          square.assertEquals(currentState.mul(currentState));\r\n          this.num.set(square);\r\n        }\r\n      }\r\n\r\n      declareMethods(Square, { update: [Field] });\r\n      declareState(Square, { num: Field });\r\n\r\n      await isReady;\r\n\r\n      console.log(""o1js loaded"");\r\n\r\n      const useProof = false;\r\n\r\n      const Local = Mina.LocalBlockchain({ proofsEnabled: useProof });\r\n      Mina.setActiveInstance(Local);\r\n      const { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];\r\n      const { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];\r\n\r\n// ----------------------------------------------------\r\n\r\n// Create a public/private key pair. The public key is your address and where you deploy the zkApp to\r\n      const zkAppPrivateKey = PrivateKey.random();\r\n      const zkAppAddress = zkAppPrivateKey.toPublicKey();\r\n\r\n// create an instance of Square - and deploy it to zkAppAddress\r\n      const zkAppInstance = new Square(zkAppAddress);\r\n      console.log(\'initiated Square\');\r\n      const deployTxn = await Mina.transaction(deployerAccount, () => {\r\n        AccountUpdate.fundNewAccount(deployerAccount);\r\n        zkAppInstance.deploy();\r\n      });\r\n      console.log(\'signing\');\r\n      await deployTxn.sign([deployerKey, zkAppPrivateKey]).send();\r\n      console.log(\'signed\');\r\n// get the initial state of Square after deployment\r\n      const num0 = zkAppInstance.num.get();\r\n      console.log(""state after init:"", num0.toString());\r\n```\r\n\r\nNow sure what is wrong since I followed the docs'), ('mitschabaude', 'I think this TS config option might be what you need, I vaguely recall it being related: https://github.com/o1-labs/o1js/blob/bb9cf00d6dbf74710690d5a2655e6205b05f9454/tsconfig.json#L15')]"
1121,Typescript errors on build,directcuteo,closed,"I cannot build the freshly cloned **o1js**. There are a lot of errors in the Typescript code

![image](https://github.com/o1-labs/o1js/assets/37619567/cfd6be48-a5f7-4249-8ff4-18194a457355)
","[('mitschabaude', 'Hey @directcuteo you need to pull the [o1js-bindings](https://github.com/o1-labs/o1js-bindings) submodule where some of the dependencies are contained'), ('mitschabaude', '```\r\ngit submodule update --init\r\n```')]"
1120,Investigate loading native OCaml over an FFI in node,mitschabaude,open,Inspired by this tweet: https://twitter.com/dillon_mulroy/status/1701226300663276003,[]
1119,Avoid to recompute SRS,mitschabaude,closed,PR which added a flag to kimchi to include the SRS in the Rust binary: https://github.com/o1-labs/proof-systems/pull/1090,"[('MartinMinkov', 'Just wanted to confirm my thoughts, we must wait until the proof systems PR is landed to start this?'), ('mitschabaude', 'Yeah that would make it easier 🤔 ')]"
1118,Investigate Punkpoll network compatibility,nicc,closed,,[]
1115,Dex example fails in Chrome with stack overflow on OCaml side,L-as,open,"It fails [here](https://github.com/o1-labs/o1js/blob/main/src/examples/zkapps/dex/dex.ts#L76).

The `transfer` onto an existing account update, if done twice (?), will fail seemingly.
A normal transfer to a public key will not cause the same issue.
It works normally under Node obviously.
Maybe increasing the stack limit in Chrome fixes it, or reducing it in Node reproduces it, I forgot to try.
I think it depends on some other factors too, it was not feasible for me to meaningfully minimize the example.",[]
1114,Bug: Cannot nest account updates inside contract call,mitschabaude,open,"If we create an account update with `update = AccountUpdate.create()` and then use `update.send()` which creates a _nested_ account update for the receiver, proving the contract fails. The reason is that `create()` witnesses the new AU with zero children and sets its `callType` accordingly. The creation of nested account updates needs to take this into account and modify `callType` on the parent account udpate.

Temporary workaround: Create both account updates on the same level
![image](https://github.com/o1-labs/o1js/assets/20989968/31a9f17d-9d55-45a2-98c6-3e1e31fe759c)

",[]
1109,"CLOSE since wrong repo, oops zk system only finds o1js from the ui and contracts directories",barriebyron,closed,"I installed the latest version of the Mina zkApp CLI:

`$ npm update -g zkapp-cli`

and successfully created a zkApp CLI with tutorial 4

However, the `zk system` command doesn't find o1js from the root project directory:

```
➜  04-zkapp-browser-ui git:(main) ✗ pwd
/Users/barriebyron/zkprojects/04-zkapp-browser-ui
➜  04-zkapp-browser-ui git:(main) ✗ zk system
Be sure to include the following system information when submitting a GitHub issue:

  System:
    OS: macOS 13.5.1
    CPU: (12) arm64 Apple M2 Pro
  Binaries:
    Node: 18.5.0 - ~/.nvm/versions/node/v18.5.0/bin/node
    Yarn: Not Found
    npm: 8.12.1 - ~/.nvm/versions/node/v18.5.0/bin/npm
  npmPackages:
    o1js: Not Found (not in a project)
  npmGlobalPackages:
    zkapp-cli: 0.11.2
```

Success with the `zk system` command from the `04-zkapp-browser-ui/ui` directory and the `/04-zkapp-browser-ui/contracts` directory
```
➜  04-zkapp-browser-ui git:(main) ✗ pwd
/Users/barriebyron/zkprojects/04-zkapp-browser-ui
➜  04-zkapp-browser-ui git:(main) ✗ cd ui
➜  ui git:(main) ✗ zk system
Be sure to include the following system information when submitting a GitHub issue:

  System:
    OS: macOS 13.5.1
    CPU: (12) arm64 Apple M2 Pro
  Binaries:
    Node: 18.5.0 - ~/.nvm/versions/node/v18.5.0/bin/node
    Yarn: Not Found
    npm: 8.12.1 - ~/.nvm/versions/node/v18.5.0/bin/npm
  npmPackages:
    o1js: 0.* => 0.12.1
  npmGlobalPackages:
    zkapp-cli: 0.11.2
```","[('ymekuria', '@barriebyron This issue should be in the `zkApp-cli` repo https://github.com/o1-labs/zkapp-cli/')]"
1101, Unable to Interact with zkapp Contract Despite Successful Deployment,PashaKlybik,closed,"Hello,

I've been encountering a persistent issue when attempting to interact with my zkapp contract. Even though the contract seems to be correctly deployed on the network (verified on Minascan and through the fetchAccount method), I'm consistently receiving the following errors:

We can't find this zkapp account in the ledger.
Because the zkapp account was not found in the cache. Try calling await fetchAccount(zkappAddress) first.
To ascertain my contract's presence on the network, I:

Checked its existence on Minascan and can confirm it's listed there.
Utilized the fetchAccount method with my zkapp contract's address, which returned relevant data .
`{
  publicKey: PublicKey {
    x: Field { value: [Array] },
    isOdd: Bool { value: [Array] }
  },
  tokenId: Field { value: [ 0, [Uint8Array] ] },
  tokenSymbol: '',
  balance: UInt64 { value: Field { value: [Array] } },
  nonce: UInt32 { value: Field { value: [Array] } },
  receiptChainHash: Field { value: [ 0, [Uint8Array] ] },
  delegate: PublicKey {
    x: Field { value: [Array] },
    isOdd: Bool { value: [Array] }
  },
  votingFor: Field { value: [ 0, [Uint8Array] ] },
  timing: {
    isTimed: Bool { value: [Array] },
    initialMinimumBalance: UInt64 { value: [Field] },
    cliffTime: UInt32 { value: [Field] },
    cliffAmount: UInt64 { value: [Field] },
    vestingPeriod: UInt32 { value: [Field] },
    vestingIncrement: UInt64 { value: [Field] }
  }, ...`
Given these verifications, I'm puzzled as to why I continue to face this error. I sought assistance from the community on Discord, but we couldn't pinpoint the root cause of the issue.

I'm reaching out here hoping for a deeper insight into this problem and any potential solutions or workarounds. Any guidance or advice would be immensely appreciated.

Thank you.","[('mitschabaude', ""This is not a known issue, so you'll have to provide more info so that anyone can debug this! I assume that the account which can't be found and the account that you are checking on Minascan are different""), ('PashaKlybik', ""Hello, @mitschabaude \r\n\r\nThank you for the prompt response.\r\n\r\nI assure you that the account I'm trying to interact with in my code and the one I'm checking on Minascan are the same. You can verify this using the following contract address on Minascan: https://minascan.io/testworld2/account/B62qk52dWhknKVrtb3dMMNKGJo6YjaTyfCFCacQN7YvfcaF7zwmEdoY/zkApp.\r\n\r\nRegarding the method causing the error on line 75, here's a snippet for clarity:\r\nhttps://github.com/zk-auth-com/mina-google-keys/blob/3dcd3d72023edce975f46b287dbba807fa364ee3/server/src/contract.ts#L35\r\n\r\nIf there's any other information or details you need from me to help debug this issue, please let me know. I'm eager to resolve this and continue with my development work.\r\n\r\nThank you for your assistance.""), ('mitschabaude', 'Hey @PashaKlybik can you also post the stack trace? That would make it much easier to understand the error cause without cloning and running the code myself'), ('PashaKlybik', ""@mitschabaude  \r\n```\r\ncontract compiled\r\ncontract created\r\ncreate transaction \r\nError: email.get() failed, either:\r\n1. We can't find this zkapp account in the ledger\r\n2. Because the zkapp account was not found in the cache. Try calling `await fetchAccount(zkappAddress)` first.\r\nIf none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!\r\n    at file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/contracts/node_modules/snarkyjs/dist/node/lib/state.js:154:27\r\n    at Object.witness (snarkyjs/dist/node/lib/provable.js:165:28)\r\n    at Object.get (snarkyjs/dist/node/lib/state.js:144:42)\r\n    at MinaGoogleKeysContract.verifyAndSend (file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/contracts/build/src/MinaGoogleKeysContract.js:51:41)\r\n    at MinaGoogleKeysContract.wrappedMethod (snarkyjs/dist/node/lib/zkapp.js:177:41)\r\n    at file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/server/src/contract.ts:32:15\r\n    at file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/server/node_modules/.pnpm/snarkyjs@0.12.1/node_modules/snarkyjs/dist/node/lib/mina.js:79:25\r\n    at Object.runUnchecked (snarkyjs@0.12.1/node_modules/snarkyjs/dist/node/lib/provable-context.js:50:20)\r\n    at createTransaction (snarkyjs@0.12.1/node_modules/snarkyjs/dist/node/lib/mina.js:78:30)\r\n    at Object.transaction (snarkyjs@0.12.1/node_modules/snarkyjs/dist/node/lib/mina.js:554:22)\r\n    at Module.transaction (snarkyjs@0.12.1/node_modules/snarkyjs/dist/node/lib/mina.js:681:31)\r\n    at sendTxs (file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/server/src/contract.ts:28:36)\r\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\r\n    at async main (file:///Users/pavelklybik/Documents/2023/bootstrap/mina-google-keys/server/src/main.ts:8:16)\r\n```""), ('mitschabaude', 'Thanks @PashaKlybik, I ended up debugging this in your repo. The problem is that you have two different versions of snarkyjs around, one in `/contracts` and one in `/server`. You do `Mina.setActiveInstance()` on the server version but then call `state.get()` (which uses the ""Mina instance"") in contract code -- so, when trying to get the state snarkyjs doesn\'t have the active instance set and in particular doesn\'t know the graphql API to fetch from.\r\n\r\nIt\'s bad that `state.get()` swallows tha actual error and throws something unhelpful in this edge case, I\'ll fix that.\r\n\r\nIn your repo, the error goes away if, from the `/server` code, you import snarkyjs like this:\r\n```ts\r\nimport { Field, ... } from ""../../contracts/node_modules/snarkyjs/dist/node/index.js"";\r\n```'), ('mitschabaude', ""Btw, that's why the zkapp CLI makes snarkyjs a peer dependency and the docs tell you to use `npm link` from the contracts package - that way you don't get two different snarkyjs instances""), ('PashaKlybik', ""Thank you so much for taking the time to debug this in my repo and pinpointing the issue. Your explanation makes perfect sense, and I'll make the necessary adjustments in my code. It's great to know that the error handling for this particular edge case will be improved in the future.\r\n\r\nYour assistance has been invaluable. I'll go ahead and close this issue. Thanks again!"")]"
1096,Invert git submodule relationship with Mina repo,mitschabaude,open,"## Why

In terms of logical dependency, SnarkyJS depends on the Mina repo, but Mina (the node software and related utilities) doesn't depend on SnarkyJS.

However, the git relationship is reversed: SnarkyJS is a git submodule of the Mina repo.

A consequence of the reversed setup is that for each branch on the Mina repo, there also _has_ to be a corresponding SnarkyJS version, which successfully compiles together with that Mina code base and passes basic tests (this is enforced in CI). This is unintended -- here's no reason to keep SnarkyJS working with every possible incarnation of Mina.

If we inverted the submodule relationship, we could be intentional about which versions of SnarkyJS + Mina we want to maintain (e.g., one that's in sync with the current testnet, and one that tracks changes necessary for the upcoming testnet). This would reduce the burden for some developers that do a lot of SnarkyJS-impacting changes. Those changes could be brought to SnarkyJS as a separate step, possibly in batches, in a way that doesn't block landing the corresponding changes in the Mina repo. 

In short, it just makes sense if the logical dependency is reflected in the submodule structure.

## How

* Add a new git submodule to SnarkyJS, at `src/mina`
* Make dune compilation work in that new setup
* Remove the git submodule at `src/lib/snarkyjs` from the Mina repo. Land that change in a place where it is upstreamable to all major Mina dev branches, e.g. `rampup`.
* (see below) Develop a solution for tests in Mina CI

## Unresolved

There is one unresolved question: What do we do with the existing tests in Mina CI that check that SnarkyJS can be compiled from its OCaml and Rust sources, and works? These tests seem important. SnarkyJS CI is currently a cheap GH action setup and would need a lot of work to be able to compile from source in CI. Also, having those tests in Mina CI had the benefit ot immediately alerting people when changes broke SnarkyJS compilation -- the CI tests recently have been carefully refactored to only fail on basic build errors and e2e SnarkyJS crypto breakage (i.e. failing to generate a proof). The tests aren't blocking protocol changes that aren't reflected in SnarkyJS, which we agreed isn't suitable to keep in sync on a per-PR basis.","[('shimkiv', ""Since SnarkyJS will now have Mina as submodule then it makes sense to execute such a test in SnarkyJS CI. \r\nOne simple way to do this is to follow similar approach as we did with the [Docker Images building procedure](https://github.com/o1-labs/mina-lightnet-docker/blob/develop/.github/workflows/build.yml).\r\nThis approach a). won't require loads of work to compile everything from sources, build system is already ready and consumed. and b). will let us stay with the same CI but offload all the heavyweight tasks to cloud VM(s).\r\nCurrently this is the Hetzner VM snapshot with ready to use mina build system, with everything configured to build mina from sources on all major branches (adding here snarkyjs build is a matter of slightly changing the scripts). Then GitHub Action job creates VM from the snapshot mentioned using Hetzner API and executes all the stuff. VM is turned off and deleted on Job completion.""), ('mitschabaude', ""Thanks @shimkiv I like this suggestion! We should definitely build that into SnarkyJS CI.\r\n\r\nI'm not 100% convinced we should remove _all_ checks in Mina CI that prevent SnarkyJS breakage. At the same time, we don't want Mina CI to depend on another repo (that would make fixes too awkward if the tests fail).\r\n\r\nSo what I'm proposing is the following:\r\n- full e2e snarkyjs build and integration test in SnarkyJS CI, with the methods @shimkiv outlined\r\n- replace snarkyjs in Mina with a stub OCaml module, let's call it `snarkyjs-stub`. It has the same dependencies as snarkyjs used to have, but only stub code, and in Mina CI we check that it can be dune-compiled. We also add a unit test, written in OCaml and run with JSOO, which checks that basic proof generation works in the JS target. This way, we achieve the following:\r\n  - if the JS build breaks in an unintended way (as has happened often in the past, because certain popular OCaml libraries can't compiled to JS and they easily get added if nothing prevents that), Mina CI will catch that, ensuring we keep the Mina core JS-compilable\r\n  - same if e2e proof generation breaks (would happen often without a test, because it would be easy to change the OCaml-Rust bindings without changing the JSOO-Wasm bindings in exactly the same way)\r\n  - on the other hand, if snarkyjs-stubs tests break in an intended way, it can be fixed right in the Mina repo (without painful repo-switching and separate PRs), and at the later stage when those changes are brought to snarkyjs, we already see what in the snarkyjs dependencies has to be updated, by looking at changes to the stub module""), ('MartinMinkov', 'I just wanted to reflect on some discussions we had internally with @shimkiv and @dkijania \r\n\r\nAction items:\r\n1. Investigate removing `o1js` as a dependency for the Rosetta tests. Instead, manually construct AccountUpdates/zkApp transactions with protocol library code instead of having `o1js` do this to test Rosetta interaction.\r\n\r\n2. Document and communicate branching strategy with Velocity relating to matching and compatible `o1js` and `mina` branches. Make sure we are aligned on how this is done.\r\n\r\n3. Add the compile/proof tests in place of the `snarkyjs` submodule, to be done by Product Eng'), ('MartinMinkov', 'Once o1js can be built with Mina as a submodule, we need to complete the following to make sure the o1js stub code will work as expected:\r\n1. https://github.com/o1-labs/o1js-bindings/issues/200\r\n2. https://github.com/MinaProtocol/mina/issues/14466')]"
1088,circuit compilation fail by some errors,coldstar1993,open,"Background:
  My Machine: 36c, 128GB.

  My two circuits' size are not small. When I compile them (with `node --experimental-wasm-memory64` ), got the errors respectively as blow:

**`TypeError:The encoded data was not valid for encoding utf-8`**
![image](https://github.com/o1-labs/snarkyjs/assets/92623877/5fcd6a5f-024b-46a2-9d25-faab341f7850)

**`Errors: curve point must not be the point at infinity`**
![image](https://github.com/o1-labs/snarkyjs/assets/92623877/d099ae4c-c264-49f0-bcf5-2cef5cdb9979)
  
 These error seems NOT from that the circuit size exceeds the upper limit (though, might be close).
  
  Later, I tried to simplify the circuit by reducing some constraints or operations, like lower merkle-tree heights, rid some constraints, etc. Then they could smoothly be compiled.
  
  My question: if my circuit size does not exceed, why I compiled them with `wasm-memory64`, but still got these errors?
  Furthermore, does snarkyJS support wasm64 currently??
  ","[('mitschabaude', ""the wasm code compiled from kimchi is definitely not using 64-bit memory, so I wouldn't expect the flag `--experimental-wasm-memory64` to have an effect""), ('coldstar1993', ""We team are on a L2Rollup product, the circuits' dependency relationship: `zkPragramC <- zkPragramB <- RollupContractA`， each one is **small** circuit that is **NOT** close to the preset upper limit of constraints amount.  \r\n\r\nI could compile `zkPragramC` and `zkPragramB` as sequence smoothly. But after that,  the former two circuits' compilation result has already been occupying really much memory(exactly,  _addressing spaces_), and not enough memory(_addressing spaces_) left for later compilation of `RollupContractA`, as well as further proving progresses.\r\n\r\nWhat we could do currently is to reduce the merkle-tree height to a really small value, to decrease memory( _addressing spaces_) occupy to make all circuits compiled and run. But this limit our product really much.\r\n\r\nAlthough our machine memory is 128GB, but due to the wasm code compiled from kimchi is using 32-bit memory, much of _machine memory_ left could not be made usage of for circuits.\r\nSo I wonder if snarkyJS will support wasm64 in soon future?\r\n\r\nBesides, any practices/suggestions for the cases like ours?\r\n""), ('coldstar1993', ""Besides, how about the progress about 'Expose side loaded verification key to snarkyjs' at  [#673](https://github.com/o1-labs/snarkyjs/issues/673) ??  It would help much!!""), ('mitschabaude', ""> Besides, how about the progress about 'Expose side loaded verification key to snarkyjs' at [#673](https://github.com/o1-labs/snarkyjs/issues/673) ?? It would help much!!\r\n\r\nUnfortunately we haven't planned to do this in the next 2-4 weeks"")]"
1086,Array lookups - JS side,mitschabaude,open,"Create a TS API for the array lookup features exposed by @dannywillems with this task: https://github.com/MinaProtocol/mina/issues/13087

The API will likely consist of (at least) two constraint-creating methods:
* `array_initialize(array: Field[]): void` - fill an array with circuit variables
* `array_get(array: Field[], index: Field): Field` - look up a value in the array

The task for the SnarkyJS team is to package that as part of a nice API that makes array operations in a circuit easy. There's a lot of good prior work on this: #633","[('stevenpack', '@garwalsh I moved this up the On Deck list for next sprint after ECDSA. Not a directive, but want to make sure it gets considered, as it looks like a smallish lift in o1js to unlock a significant capability.')]"
1085,Cryptic Error with snarkyjs-pack,45930,open,"I am working on a test suite for snarkyjs-pack and getting this error:

```
  ● End to End Votes Test › Incrementing votes › Increments the 0th index

    caml_fp_vector_get: Index out of bounds, got 146055/146055

      at caml_fp_vector_get (snarkyjs/src/bindings/kimchi/js/bindings.js:505:13)
      at external_values (src/lib/crypto/kimchi_backend/pasta/vesta_based_plonk.ml:90:33)
      at ../../../../../workspace_root/src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml:880:44
      at iteri$1 (ocaml/base/array0.ml:50:18)
      at _oXW_ (src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml:874:9)
      at ../../../../../home/gregor/.opam/4.14.0/lib/base/list.ml:544:8
      at fold_left$0 (ocaml/ocaml/list.ml:121:25)
      at fold_left$2 (ocaml/base/list0.ml:21:23)
      at iteri$2 (ocaml/base/list.ml:543:6)
      at compute_witness (src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml:873:5)
      at create_async (src/lib/crypto/kimchi_backend/pasta/vesta_based_plonk.ml:111:7)
      at ../../../../../workspace_root/src/lib/snarky/src/base/runners.ml:351:13
      at ../../../../../workspace_root/src/lib/snarky/src/base/runners.ml:305:34
      at ../../../../../workspace_root/src/lib/snarky/src/base/snark0.ml:1309:19
      at finalize_is_running (src/lib/snarky/src/base/snark0.ml:1279:15)
      at generate_witness_conv (src/lib/snarky/src/base/snark0.ml:1308:7)
      at prove (snarkyjs/src/bindings/ocaml/lib/pickles_bindings.ml:493:7)
      at node_modules/snarkyjs/src/lib/proof_system.ts:545:32
      at withThreadPool (snarkyjs-pack/node_modules/snarkyjs/src/bindings/js/node/node-backend.js:55:20)
      at prettifyStacktracePromise (snarkyjs-pack/node_modules/snarkyjs/src/lib/errors.ts:137:12)
      at Object.prove_ [as incrementIndex0] (snarkyjs-pack/node_modules/snarkyjs/src/lib/proof_system.ts:299:18)
      at Object.<anonymous> (snarkyjs-pack/tests/provable/end_to_end.test.ts:24:21)
```

The test I am running is here: https://github.com/45930/snarkyjs-pack/blob/362276d339b27dade184e40b86637148088c3a9d/tests/provable/end_to_end.test.ts

A different example using snarkyjs-pack in a smart contract context is here: https://github.com/45930/snarkyjs-pack-examples/blob/main/src/BigContract.test.ts.  This smart contract can successfully generate transactions on berkeley, but I haven't gotten it to work in a zk program yet.

I'd like help understanding what's going wrong with this zk program so I can build a more robust test suite.",[]
1079,Node 20 support,shimkiv,open,"Since Node 16 will be EOL soon we need to make sure that SDK will continue work with Node 18 and 20 (including CI)

","[('shimkiv', '`Node 20` will complain on `--experimental-wasm-threads` usage: `node: bad option: --experimental-wasm-threads`.'), ('shimkiv', 'Seems to be not related to SnarkyJS.')]"
1078,Enforce `this.sender` correctness with an empty signed child account update,mitschabaude,open,,[]
1074,Live tests improvements (dynamic accounts),shimkiv,closed,"- https://github.com/o1-labs/snarkyjs/pull/1057#discussion_r1280178805
- After implementation of https://github.com/o1-labs/quality-and-testing/issues/121",[]
1072,Live tests improvements,shimkiv,closed,"- Address items from https://github.com/o1-labs/snarkyjs/pull/1057.
- Use specialized GitHub Action (https://github.com/o1-labs/wait-for-mina-network-action) instead of Shell script.",[]
1069,Better built-ins to support offchain state patterns,mitschabaude,open,"To discuss

One idea is #661 but it might be good to create an official offchain Merkle tree example and then make all hard parts of it easy",[]
1068,Generic to/fromValue() method to move between zk and JS types,mitschabaude,open,For O1 people: we [discussed this internally](https://o1-labs.slack.com/archives/C028Q27R8UC/p1689234833659599) @garwalsh ,[]
1067,More user-friendly Struct with instance methods,mitschabaude,open,"And update all the internal classes (UInt64 etc) to be Structs

For O1 people: we [discussed this internally](https://o1-labs.slack.com/archives/C028Q27R8UC/p1689234507363509) @garwalsh ",[]
1066,Remove bottlenecks in witness generation,mitschabaude,closed,"The most important part of this is believed to be #1063, but there are other easy to remove bottlenecks like time spent throwing and catching errors in snarky-ml",[]
1065,Remove bottlenecks in snarkyjs loading time,mitschabaude,closed,,[]
1064,Move JSOO Poseidon to bigint-based,mitschabaude,open,"very small part of #1063 and key enabler for #1064

EDIT: wasn't needed for #1064, instead I chose to avoid doing hashes during import altogether (instead of making them faster). So, I see this now as something that can just be done together with #1063 in one go (it's still a very impactful part of that issue)","[('mitschabaude', ""This was based on unfounded assumptions. The Poseidon used by snarky in provable code is an OCaml implementation, not the Rust impl exposed over the bindings layer. As such, it also isn't swappable for a TS impl simply by changing the bindings layer.\n\nI will have to do more perf investigation to see how much slower the OCaml impl is, to understand the potential impact of changing it."")]"
1063,Move snarky backend to bigint-based,mitschabaude,closed,"Why? 
- SnarkyJS operations that involve snarky-ml under the hood are typically very slow, and it's hurting the DX 
- Performance investigation showed that a main bottleneck are slow calls into the Wasm bindings
- We know that changing those implementations to using JS bigints would improve performance a lot; this is what this issue is about",[]
1062,Dynamic Array Access in SnarkyJS,shryasss,open,"Hi! I was looking for a way to do array access using `Field` elements, but could not find any documentation for it. I would be more than happy to implement a naive `quin_selector` -- [circom implementation](https://github.com/darkforest-eth/circuits/blob/master/perlin/QuinSelector.circom) for the time being, but I believe that's not a long term solution.

Any help is much appreciated!","[('shryasss', 'This is the naive implementation:\r\n```\r\n/**\r\n * Selects an element from an array based on an index.\r\n * @param arr The array to select from.\r\n * @param index The index of the element to select.\r\n * @returns The selected element.\r\n */\r\nexport const quinSelector = (arr: Field[], index: Field) => {\r\n  index.lessThan(Field(arr.length)).assertTrue();\r\n\r\n  let out = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    out.push(arr[i].mul(index.equals(Field(i)).toField()));\r\n  }\r\n\r\n  let res = Field(0);\r\n  for (let i = 0; i < arr.length; i++) {\r\n    res = res.add(out[i]);\r\n  }\r\n\r\n  return res;\r\n};\r\n```'), ('mitschabaude', ""Yep, I have used the same pattern. I don't think there's anything better without lookup based array access (which will come to snarkyjs within the next months)\r\n\r\n"")]"
1061,Issue with LessThan Function: No Support for Field Elements Greater Than 253 Bits,shryasss,open,"Hello,

I am currently developing a Zero-Knowledge (ZK) application and have encountered a limitation with the `lessThan` function in the Field class. Specifically, the function seems to only support field elements of size less than or equal to 253 bits.

In my particular use case, I need to work with field elements that are larger than 253 bits. This limitation is causing a significant roadblock in the development of my application.

I am referring to the implementation found at this location: https://github.com/o1-labs/snarkyjs/blob/main/src/lib/field.ts#L699

I would greatly appreciate any guidance or potential solutions to overcome this limitation. Is there a workaround or an alternative function that I could use to compare larger field elements? Or is there a plan to extend the `lessThan` function to support larger field elements in the future?

Thank you in advance for your assistance and I look forward to your response.","[('mitschabaude', 'I\'m sure we can help you implement something custom with existing snarkyjs methods.\r\nCan provide more details on what field elements you want to compare? Are they ""random"" elements (or hash outputs, or something like that)? In that case we can assume they are 254 bit with overwhelming probability. You might have a look at Field.isEven() and see how it decomposes a 254 bit Field element into a 253 bit high part and a 1 bit low part (the parity bit).\r\nYou might be able to work out a solution from that (if not I can help)'), ('shryasss', ""Hi, I implemented a `lessThanWrapper` to do what you suggested, but it turns out that the numbers are 255 bits. Any other solution for this?\r\n\r\nCode:\r\n```\r\nimport { Field, Provable } from 'snarkyjs';\r\nimport { Snarky } from 'snarkyjs/dist/node/snarky';\r\nimport { FieldConst } from 'snarkyjs/dist/node/lib/field';\r\nimport { Field as Fp } from 'snarkyjs/dist/node/provable/field-bigint';\r\n\r\nconst separateHighPart = (x: Field): [Field, Field] => {\r\n  let [, isOddVar, xDiv2Var] = Snarky.exists(2, () => {\r\n    let bits = Fp.toBits(x.toBigInt());\r\n    Provable.log('bitlen', bits.length);\r\n    let isOdd = bits.shift()! ? 1n : 0n;\r\n\r\n    return [\r\n      0,\r\n      FieldConst.fromBigint(isOdd),\r\n      FieldConst.fromBigint(Fp.fromBits(bits)),\r\n    ];\r\n  });\r\n  return [new Field(xDiv2Var), new Field(isOddVar)];\r\n};\r\n\r\nexport const lessThanWrapper = (a: Field, b: Field) => {\r\n  let [aHigh, aParity] = separateHighPart(a);\r\n  let [bHigh, bParity] = separateHighPart(b);\r\n\r\n  Provable.log('aHigh', aHigh);\r\n  Provable.log('aParity', aParity);\r\n  Provable.log('bHigh', bHigh);\r\n  Provable.log('bParity', bParity);\r\n\r\n  let highPartLessThan = aHigh.lessThan(bHigh);\r\n  let highPartEqual = aHigh.equals(bHigh);\r\n  let parityLessThan = aParity.lessThan(bParity);\r\n\r\n  return highPartLessThan.or(highPartEqual.and(parityLessThan)).toField();\r\n};\r\n\r\n```""), ('mitschabaude', 'You can treat 255 bit numbers equivalently, instead of splitting them into 1 + 253 bits you split them into 2 + 253 bits.\r\nAlso, FYI, there is Provable.witness() which is a more user friendly version of exists() and is exported from snarkyjs '), ('shryasss', ""Hey, thanks for the solution. I am running into the problem where one of the input to the `lessThan` function is a negative number, so that is very near to the Modulus, so i guess that's why it's going beyond 253 bits and the functions fails. What is the ideal thing to do in such a case?""), ('mitschabaude', '@shryasss I was suggesting that you split it into 2 + 253 in this case.\r\n\r\nIf you know that inputs are smallish negative or positive numbers, say they have an absolute value < MAX, then there is an even easier solution: check whether\r\nx + MAX < y + MAX\r\nso that both sides become smallish positive numbers'), ('shryasss', ""Yes, I have implemented a `lessThanWrapper` to handle case where input is >253 bits.\r\n\r\n```\r\nimport { Field, Provable } from 'snarkyjs';\r\nimport { Snarky } from 'snarkyjs/dist/node/snarky';\r\nimport { FieldConst } from 'snarkyjs/dist/node/lib/field';\r\nimport { Field as Fp } from 'snarkyjs/dist/node/provable/field-bigint';\r\n\r\nconst separateHighPart = (x: Field): [Field, Field] => {\r\n  let [, isOddVar, xDiv2Var] = Snarky.exists(2, () => {\r\n    let bits = Fp.toBits(x.toBigInt());\r\n    let highPart = [];\r\n    for (let i = 0; i < 2; i++) {\r\n      highPart.push(bits.shift()! ? 1n : 0n);\r\n    }\r\n\r\n    return [\r\n      0,\r\n      FieldConst.fromBigint(Fp.fromBits(highPart.map((x) => x === 1n))),\r\n      FieldConst.fromBigint(Fp.fromBits(bits)),\r\n    ];\r\n  });\r\n  return [new Field(xDiv2Var), new Field(isOddVar)];\r\n};\r\n\r\nexport const lessThanWrapper = (a: Field, b: Field) => {\r\n  let [aHigh, aLow] = separateHighPart(a);\r\n  let [bHigh, bLow] = separateHighPart(b);\r\n\r\n  let highPartLessThan = aHigh.lessThan(bHigh);\r\n  let lowPartLessThan = aLow.lessThan(bLow);\r\n\r\n  return highPartLessThan\r\n    .or(lowPartLessThan.and(aHigh.equals(bHigh)))\r\n    .toField();\r\n};\r\n```\r\n\r\nBut as you mentioned in the last response, the inputs might not be smallish, as a negative number will be very close to the Field Order, so it won't be smallish. \r\n\r\nAlso, if I do -- x + Max < y + Max, won't it be equivalent to -- x < y, I am not able to understand the difference here.\r\n\r\nThanks for the prompt responses, appreciate it a lot!""), ('mitschabaude', '> Also, if I do -- x + Max < y + Max, won\'t it be equivalent to -- x < y, I am not able to understand the difference here\r\n\r\nYeah that\'s the point, it\'s equivalent but both sides are small, by adding MAX you turn the ""negative"" (close to field order) into a small positive number, so it no longer has too many bits\r\n\r\n\r\nAlso, does your 2 + 253 bit solution above not work?'), ('shryasss', '> Yeah that\'s the point, it\'s equivalent but both sides are small, by adding MAX you turn the ""negative"" (close to field order) into a small positive number, so it no longer has too many bits\r\n\r\nI think the problem here will be that if only one of the input is close to the Field Order, then if I add the modulus to both the numbers, then the other number becomes close to the Field Order. Any thoughts on this?\r\n\r\n> Also, does your 2 + 253 bit solution above not work\r\n\r\nYes, it works\r\n'), ('mitschabaude', ""> I think the problem here will be that if only one of the input is close to the Field Order, then if I add the modulus to both the numbers, then the other number becomes close to the Field Order. Any thoughts on this?\r\n\r\nI didn't suggest to add the modulus, but some number MAX that's large enough to make all your inputs positive but small enough so that x + MAX is less than 253 for all your inputs. Of course, it depends on the application whether such a number exists. As I wrote above, this is applicable if all your inputs are either small negative or small positive numbers (as is the case for many applications)""), ('shryasss', 'Ohh right, got it. It makes a lot of sense to do that. Thanks, will try to implement this in my wrapper and share the code here. Thank you so much for the help!!')]"
1053,Generalize non-foreign Field in an ergonomic manner,bkase,open,"Right now `Field` is hardcoded to the Pasta base field; there should be a mechanism for swapping it for something else.

Consider using generics, runtime dependency injection. Note that there are some library code that can be generalized over the Field and some that can't, so we'll need to support that.

PRD and RFC needed.",[]
1043,Expose string-network selector in mina-signer/wallets/snarkyjs etc,bkase,open,"The protocol now supports modifying signatures by a network string to prevent replay attacks across arbitrary networks.

However, we need to expose this in all our toolings and wallets",[]
1039,Make `Proof` a normal `Provable` to compose within Structs,mitschabaude,open,"**Why**: Right now, we can only pass in proofs to provable methods as a top-level method argument. But for building abstractions, some users want to pass arrays of proofs and similar nested structures containing proofs.

**Notes on implementation**

This is more subtle than it sounds. Currently, the code that processes private inputs in `proof_systems.ts` has a lot of special cases for handling proofs, because these have to be explicitly passed on to Pickles to be recursively verified.

If we allow proofs arbitrarily nested inside other Structs, it means in some places we have to find and pull out all these proofs in order to perform that special logic.",[]
1037,Using lighweight local mina network Docker image in the standard zkApps development workflow,nicc,open,"This epic tracks progress toward our community using a lightweight network in a Docker image during local zkApp development.

As part of delivering this we will also dogfood this image on CI so note that some issues will not be overtly community-facing.","[('barriebyron', '- improved Docker Hub image text to @Serhii Shymkiv for review https://hackmd.io/TPlu6kYUR4WQD5IGRWUsDw?view \n- updated how to test a zkApp with a section and link to the lightweight mina Docker Hub https://docs.minaprotocol.com/zkapps/how-to-test-a-zkapp#test-zkapps-on-a-lightweight-mina-local-network')]"
1038,[Testing] - Integration test(s) that run through all gate and gadgets work,MartinMinkov,open,"We should write an integration test that uses all the newly added gates and gadgets to ensure everything works. It would be great to run this in CI as well. 

Gates that should be tested:
- AND
- NOT
- ROT
- XOR
- SHA/Keccak
- ECDSA / FF","[('MartinMinkov', '@shimkiv We would like your assistance once we start this work. I wanted to loop you in early. :D'), ('mitschabaude', 'Should this be on the snarkyjs repo?')]"
1036,Adapt Foreign Arithmetic APIs to ffmul changes,mitschabaude,closed,The foreign field multiplication gate is being updated to be more secure. This issue represents the work to adapt the SnarkyJS implementation accordingly.,"[('nicc', 'Blocked by [this PR](https://github.com/MinaProtocol/mina/pull/13664)'), ('nicc', 'Blocks https://github.com/o1-labs/snarkyjs/pull/985 and https://github.com/o1-labs/snarkyjs/pull/1007'), ('nicc', 'Indirectly responsible individual: @Trivo25 '), ('garwalsh', 'Done but waiting for review, Joseph and Anais'), ('mitschabaude', 'this is mostly done in a branch, but will be rewritten. closing because the upcoming work is better covered by other issues')]"
1035,Testing against lightweight network,mitschabaude,closed,,"[('shimkiv', 'Hey @mitschabaude.\r\nCouple of questions about this one.\r\n\r\n1. Are we interested in networks with proving enabled or the lightweight one you mentioned will be enough?\r\n2. Are we talking about enabling the [""Berkeley Live""](https://github.com/o1-labs/snarkyjs/blob/aed64f2b4d2b85b0c3811ef2dcc0b0f24a20a910/run-ci-tests.sh#L25C5-L25C20) simple zkApp execution against real network or maybe do we want to exercise something more complex like [Voting](https://github.com/o1-labs/snarkyjs/blob/aed64f2b4d2b85b0c3811ef2dcc0b0f24a20a910/src/examples/zkapps/voting/run_berkeley.ts) (instead of default [Hello World](https://github.com/o1-labs/snarkyjs/blob/aed64f2b4d2b85b0c3811ef2dcc0b0f24a20a910/src/examples/zkapps/hello_world/run_berkeley.ts))?\r\n3. Do we want to exercise zkApps flow (deployment + interaction) in-browser (and against real networks) as well?\r\n4. Do we want to run tests for all major [branches](https://github.com/o1-labs/snarkyjs/blob/aed64f2b4d2b85b0c3811ef2dcc0b0f24a20a910/.github/workflows/build-action.yml#L2) with corresponding mapping to Mina\'s branches (and [available networks](https://hub.docker.com/r/o1labs/mina-local-network/tags)) or we\'re interested in some particular branch only?'), ('mitschabaude', 'Hey @shimkiv, good questions!\r\n'), ('mitschabaude', '1. lightweight is enough\r\n2. Yes, the old ""berkeley live"" test = hello world example is enough for an initial version IMO. So I think the first PR should just do that. We can then still decide if we want to move to a more complex example, that could be voting or DEX-with-actions\r\n3. No '), ('mitschabaude', ""Re 4) (branch mapping) -- currently we run CI on the 3 major branches main, berkeley and develop. Mapping those to rampup, berkeley and develop and running the test on those branches would be a great start.\r\n\r\nThe only problem I'm seeing is that currently, main is not compatible with rampup due to some complications. The current Mina branch for snarkyjs/main is this one: https://github.com/MinaProtocol/mina/pull/13602\r\n\r\nI think we should make the effort to bring rampup back up to date with main, and use the branch mapping""), ('shimkiv', ""Thank you @mitschabaude, got it and will land the corresponding PR.\r\n\r\n> The only problem I'm seeing is that currently, main is not compatible with rampup due to some complications. The current Mina branch for snarkyjs/main is this one: https://github.com/MinaProtocol/mina/pull/13602\r\n\r\nWell, that is why [o1labs/mina-local-network:rampup-latest-lightnet](https://hub.docker.com/r/o1labs/mina-local-network/tags) is actually based on Mina's `rampup-before-accidental-merge` for now 😄 \r\nSo we should be good to run tests against all branches."")]"
1033,Speed up dev workflow feedback loop,nicc,open,"We want to drastically improve the feedback loop from making code changes to seeing their results. This should be considered holistically to include compilation, proving, tests and test environment.",[]
1028,housekeeping: use 88 bit range checks for `Field.parity`,Trivo25,open,,"[('mitschabaude', 'This should be expanded to be ""expose primitives for efficient range checks to snarkyjs and use them everywhere possible"".\r\n\r\nThings that are super expensive and we can speed up with range checks:\r\n* Field comparisons (they use naive full bit decomposition)\r\n* Field parity - also used implicitly when (de)compressing public keys, i.e. in `privateKey.toPublicKey()`\r\n* all UInt32 / UInt64 operations (they already use more-efficient-than-naive range checks but could still be much more efficient)')]"
1023,Are `Field.toBits()` and `fromBits()` unsound?,mitschabaude,open,"`Field.toBits()` without the optional length parameter returns 255 Bools to represent a field element. However, the representation of a field element as 255 bits is not necessarily unique!

Namely, for most Pasta field elements $x$, both $x$ and $x + p$ fit within 255 bits. If the decomposition of $x$ into bits is checked like I think it is -- as $x = x_0 + 2 x_1 + ... + 2^{254} x_{254} \bmod{p}$ --, then the prover can choose between two decompositions: that of $x$ and that of $x + p$.

The same vulnerability applies to `fromBits()` which likely uses the same constraints

Possible fix: Make 254 the default bit length parameter and don't allow 255.",[]
1022,Fix nullifier non-uniqueness,mitschabaude,closed,"Problem: Our current nullifier implementation doesn't constrain the nullifier to a unique value. It allows the prover to choose between two square roots and thus, two different nullifiers (N and -N). This defeats the purpose of a nullifier, since the prover can double-spend after all.

Solution: Check that the parity of the square root returned by hashToGroup is 0.

Sketch of parity check:
```ts
function parity(x: Field) {
  let [isOdd, xDiv2] = Provable.witness(provable([Field, Field]), () => {
     let bits = x.toBits();
     let isOdd = bits.shift();
     return [isOdd, Field.fromBits(bits)];
  });    

  // range check for 253 bits
  // WARNING: this makes use of a special property of the Pasta curves,
  // namely that a random field element is < 2^254 with overwhelming probability
  // TODO use 88-bit RCs to make this more efficient
  xDiv2.toBits(253);
  
  // check composition
  xDiv2.mul(2).add(isOdd).assertEquals(x);
  
  return isOdd;
}

function assertEven(x: Field) {
  parity(x).assertEquals(0);
}
```    ","[('mitschabaude', 'Fixed by https://github.com/o1-labs/snarkyjs/pull/1026')]"
1018,Unhelpful fetchActions error when not specifying archive node endpoint,mitschabaude,open,"Mina.Network() let's you specify either only the Mina node endpoint or an object with both endpoints.

If you use actions, you need the archive endpoint as well. This connection is implicit and not obvious just from using the API.

The error that you get when fetching actions if you didn't set the archive node is kinda unhelpful, it just says ""graphql endpoint undefined"":
https://github.com/o1-labs/snarkyjs/blob/ff908249a91da78c8347d8d5927037d2faf619b9/src/lib/fetch.ts#L895

This error should point you to setting the archive node in Mina.Network().",[]
1012,Can't run server with snarkyJS dependency,45930,closed,"I cannot run the server in my project because I am getting the following error in snarkyJS version 0.11.3

```
npm run dev

> mina-arena-server@1.1.0 dev
> npm run build && npm run start


> mina-arena-server@1.1.0 build
> npm run generate && tsc --project tsconfig.json


> mina-arena-server@1.1.0 generate
> graphql-codegen --config codegen.yml

✔ Parse Configuration
✔ Generate outputs
node_modules/snarkyjs/dist/node/lib/bool.d.ts:2:36 - error TS2307: Cannot find module 'src/bindings/crypto/non-negative.js' or its corresponding type declarations.

2 import { NonNegativeInteger } from 'src/bindings/crypto/non-negative.js';
                                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 1 error in node_modules/snarkyjs/dist/node/lib/bool.d.ts:2
```

To repro, clone this repo at the linked commit, then run `npm i && npm run dev`","[('mitschabaude', ""This is a legit bug, there's a non relative import in the code https://github.com/o1-labs/snarkyjs/blob/ff908249a91da78c8347d8d5927037d2faf619b9/src/lib/bool.ts#L11\r\n\r\nThe problem seems to be that our CI somehow doesn't catch this..""), ('45930', 'I have another one now:\r\n\r\n\r\n```\r\nnode_modules/mina-arena-contracts/build/src/turn/TurnProof.d.ts:37:68 - error TS2694: Namespace: Projects/trumpet-zk-ignite/server/node_modules/snarkyjs/dist/node/snarky""\' has no exported member \'Bool\'.\r\n\r\n37         verifyIf(condition: import(""snarkyjs/dist/node/snarky.js"").Bool): void;\r\n```\r\n\r\nI guess it\'s all the same stuff and it just depends on what I import/use in my code.'), ('45930', ""The second one is tricky because it's my proof which has the error, but the it's in the generated typescript declaration file which is auto-generated.""), ('mitschabaude', 'I think this should address both issues: https://github.com/o1-labs/snarkyjs/pull/1015\r\n'), ('45930', 'Confirmed!  Thank you so much @mitschabaude !')]"
1003,`Runtime unreachable` when invoking `caml_fp_srs_b_poly_commitment` through the bindings layer,Trivo25,open,"Invoking any method that that accesses `caml_fp_srs_b_poly_commitment` in the bindings layer causes an `Runtime unreachable` error

example:

```ocaml
method test_poly_commitment =
      let n = 131072 in
      let urs = Kimchi_bindings.Protocol.SRS.Fq.create n in
      let log_n = Core_kernel.Int.ceil_log2 n in
      let xs = Array.init log_n ~f:(fun _ -> Pasta_bindings.Fq.random ()) in
      Kimchi_bindings.Protocol.SRS.Fq.b_poly_commitment urs xs (* unreachable here *)
```

which invokes a rust function 

```rs

            #[ocaml_gen::func]
            #[ocaml::func]
            pub fn [<$name:snake _b_poly_commitment>](
                srs: $name,
                chals: Vec<$CamlF>,
            ) -> Result<CamlPolyComm<$CamlG>, ocaml::Error> {
                let chals: Vec<$F> = chals.into_iter().map(Into::into).collect();
                let coeffs = b_poly_coefficients(&chals);
                let p = DensePolynomial::<$F>::from_coefficients_vec(coeffs);
                Ok(srs.commit_non_hiding(&p, None).into())
            }
```


logs

```
RuntimeError: unreachable
    at __rust_start_panic (wasm://wasm/00fc2ace:wasm-function[4410]:0x37a1a7)
    at rust_panic (wasm://wasm/00fc2ace:wasm-function[4071]:0x378aeb)
    at std::panicking::rust_panic_with_hook::hd6c4677d123a0b1c (wasm://wasm/00fc2ace:wasm-function[2799]:0x348596)
    at std::panicking::begin_panic_handler::{{closure}}::h4d615f37d8b95697 (wasm://wasm/00fc2ace:wasm-function[3372]:0x368838)
    at std::sys_common::backtrace::__rust_end_short_backtrace::h0c0583f19aa0b4d0 (wasm://wasm/00fc2ace:wasm-function[3987]:0x377d5b)
    at rust_begin_unwind (wasm://wasm/00fc2ace:wasm-function[3742]:0x373a58)
    at core::panicking::panic_fmt::hef457850cd9ff5e9 (wasm://wasm/00fc2ace:wasm-function[3923]:0x377070)
    at core::panicking::panic::hac9729efe1dbe352 (wasm://wasm/00fc2ace:wasm-function[3859]:0x375f5f)
    at caml_fq_srs_b_poly_commitment (wasm://wasm/00fc2ace:wasm-function[593]:0x1fd7c4)
    at Object.module.exports.caml_fq_srs_b_poly_commitment (/home/trivo/Development/mina-rollup/src/lib/snarkyjs/dist/node/_node_bindings/plonk_wasm.cjs:1102:14)
    at null.caml_fq_srs_b_poly_commitment (/workspace_root/src/lib/snarkyjs/src/bindings/kimchi/js/bindings.js:1094:15)
    at self (/workspace_root/src/lib/snarkyjs/src/bindings/ocaml/lib/snarky_js_bindings_lib.ml:1676:7)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at Function.<anonymous> (/builtin/+jslib.js:289:12)
    at Function.Class.<computed> (/home/trivo/Development/mina-rollup/src/lib/snarkyjs/src/bindings/js/proxy.js:20:52)
    at file:///home/trivo/Development/mina-rollup/src/lib/snarkyjs/src/examples/program.tmp.js:4:26
    at ModuleJob.run (node:internal/modules/esm/module_job:198:25)
    at async Promise.all (index 0)
    at async ESMLoader.import (node:internal/modules/esm/loader:385:24)
    at async buildAndImport (file:///home/trivo/Development/mina-rollup/src/lib/snarkyjs/src/build/buildExample.js:12:22)
    at async file:///home/trivo/Development/mina-rollup/src/lib/snarkyjs/src/build/run.js:25:16
```



compiling smart contracts also invoked `caml_fp_srs_b_poly_commitment`. however, in that case it doesn't fail while in any other situation it does. ","[('L-as', 'The function noted is in fact the *incorrect* one, the correct function is [here](https://github.com/o1-labs/snarkyjs-bindings/blob/f52126e53ceb9cfe4e3beab0b6ac30f4a4cc77e4/kimchi/wasm/src/srs.rs#L163). \r\n\r\nThe real issue, however, is that the **thread pool is uninitialised**. I figured this out after sprinkling the code with some console.logs.\r\n\r\nThe real real issue, however, is that no useful debugging information is contained within the error message.\r\n`run_in_pool` uses `.unwrap()` instead of `.expect(...)`, but even when using the latter, the message, nor the line number, nor the (correct) stack trace is reported!'), ('L-as', 'This is a symptom of `console_error_panic_hook` not being used, I made a PR to fix this completely: https://github.com/o1-labs/snarkyjs-bindings/pull/63\r\n\r\nPreviously it was set ad-hoc in some functions (I assume a relic of debugging the implementations).'), ('mitschabaude', 'Nice find @L-as! At the time I introduced the console panic hook, I made it activate in those functions that would be the only important entry points for catching errors in snarkyjs ')]"
995,Cannot read properties of undefined (reading 'memory') in plonk wasm file,45930,open,"When I run `vite build` in my app, I get this error:

```
vite v4.3.9 building SSR bundle for production...
✓ 68 modules transformed.

node:internal/event_target:916
  process.nextTick(() => { throw err; });
                           ^
TypeError [Error]: Cannot read properties of undefined (reading 'memory')
    at Object.<anonymous> (/Users/me/Projects/zkapps/mina-rng/node_modules/snarkyjs/dist/node/_node_bindings/plonk_wasm.cjs:14:27)
    at Module._compile (node:internal/modules/cjs/loader:1103:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1157:10)
    at Module.load (node:internal/modules/cjs/loader:981:32)
    at Function.Module._load (node:internal/modules/cjs/loader:822:12)
    at Function.wrappedLoad [as _load] (/Users/me/Projects/zkapps/mina-rng/node_modules/newrelic/lib/shimmer.js:313:24)
    at ModuleWrap.<anonymous> (node:internal/modules/esm/translators:168:29)
    at ModuleJob.run (node:internal/modules/esm/module_job:197:25)
    at async Promise.all (index 0)
    at async ESMLoader.import (node:internal/modules/esm/loader:337:24)
Emitted 'error' event on Worker instance at:
    at Worker.[kOnErrorMessage] (node:internal/worker:289:10)
    at Worker.[kOnMessage] (node:internal/worker:300:37)
    at MessagePort.<anonymous> (node:internal/worker:201:57)
    at MessagePort.[nodejs.internal.kHybridDispatch] (node:internal/event_target:647:20)
    at MessagePort.exports.emitMessage (node:internal/per_context/messageport:23:28)
```

I am using version `0.10.1`.","[('mitschabaude', ""It seems that vite tries to bundle the nodejs version of snarkyjs instead of using the prebuilt web bundle - this won't work for a couple of reasons ""), ('mitschabaude', ""SnarkyJS tries to tell bundlers how to resolve the import by declaring an 'exports' field in package.json. I would assume that vite can handle that, but maybe we have to tweak for it to work""), ('mitschabaude', ""Oh.. just realized that it refers to the 'SSR bundle'. So it bundling the node version is correct after all (although I don't see the point of bundling code for nodejs, after all it works to just execute it)""), ('45930', ""@mitschabaude In the past I've had success by just disabling SSR for all of my pages.  I can try that.\r\n\r\nThis is the RNG app I built for zk-ignite cohort 0, which was working fine before.  I found that if I update just the snarkyJS version and pin `@svekte/kit` and `@svelte/adapter-node` to their previous versions, then the app builds.  But in the zkapp-cli, you are using the newest version of `@svelte/kit` and `@svelte/adapter-auto` in the example project, which builds fine.  It's annoying to have to track down build errors more often than not when making new projects and updating old ones.\r\n\r\n\r\n> just realized that it refers to the 'SSR bundle'. So it bundling the node version is correct after all \r\n\r\nIs this actually true?  My understanding of SSR is that the server generates an html and js functions before the user requests it, but then if the user interacts with those functions, then they will be executed in a browser environment, not in node.  That's why it's always made sense to me to _disable_ SSR for snarkyJS interactions.\r\n""), ('mitschabaude', 'Hm maybe we should pin the sveltekit version 🤔'), ('45930', ""@mitschabaude the mina-rng app does not use the zkapp-cli scaffolding.  I only mention that because that scaffold _does_ use the most up-to-date of every package, and my app only works when I _don't_.\r\n\r\nI should clarify something - the mina-rng app only uses snarkyJS on the server side.  The html in the app is just some documentation about how to use the API.  The API is where I use snarkyJS to sign data, and node is the correct execution environment to use.\r\n\r\n```\r\nlet { isMainThread, workerData } = require('worker_threads');\r\n\r\nlet env = {};\r\nif (isMainThread) {\r\n  env.memory = new WebAssembly.Memory({\r\n    initial: 20,\r\n    maximum: 65536,\r\n    shared: true,\r\n  });\r\n} else {\r\n  env.memory = workerData.memory;  <-------\r\n}\r\n```\r\n\r\nThis is the the line with the error.  `workerData` is apparently undefined (`Cannot read properties of undefined (reading 'memory')`), but it is required and should be present?  My node version is `v16.14.2`""), ('45930', ""For reference, here's the app: https://github.com/45930/mina-rng""), ('mitschabaude', ""> I only mention that because that scaffold does use the most up-to-date of every package, and my app only works when I don't.\r\n\r\nI understood that! Pinning would solve it randomly breaking when new versions come out\r\n\r\nYeah the error you have is weird. Maybe the code doesn't work because it all runs in a worker so isMainThread is never true?""), ('leomanza', '@mitschabaude @45930 have you found a fix for this error? we are facing the same issue running `vite build`\r\nWe are using:\r\n ""snarkyjs"": ""^0.12.1"",\r\n ""@sveltejs/adapter-auto"": ""^2.0.1"",\r\n ""@sveltejs/kit"": ""^1.15.10"",\r\n""@sveltejs/adapter-static"": ""^2.0.2""\r\n\r\nSSR is disabled'), ('ymekuria', '@leomanza are you running into this error after generating a svelte project using the zkapp-cli?'), ('mazito', 'Yes, we have used this: [https://github.com/mazito/zkLearn/tree/main/05-zkapp-sveltekit-ui](https://github.com/mazito/zkLearn/tree/main/05-zkapp-sveltekit-ui) that was based on the zkapp-cli, because the zkapp-cli had problems already described in this post.\r\n\r\nInitially we had no problems with build, but from what I am testing now the problem seems to happens with dynamic routes (such as `/credentials/[uid]` and similar), because svelte-kit can not prerender them.\r\n\r\nPlease note the we are prerendering all pages.'), ('mazito', 'So, this is what I have found so far.\r\n\r\n**First we set prerender on all pages**, so `+layout.js` contains:\r\n~~~\r\n// for generating a static site\r\nexport const prerender = true;\r\nexport const ssr = false;\r\nexport const csr = true;\r\n\r\n// may need it for static sites ??? NOT SURE\r\nexport const trailingSlash = \'always\';\r\n~~~\r\n\r\n**Second, we add dynamic pages to the `prerender`** section in `svelte.config.js`:\r\n~~~\r\n//import adapter from \'@sveltejs/adapter-auto\';\r\nimport adapter from \'@sveltejs/adapter-static\';\r\nimport { vitePreprocess } from \'@sveltejs/kit/vite\';\r\nimport path from \'path\';\r\n\r\n/** @type {import(\'@sveltejs/kit\').Config} */\r\nconst config = {\r\n  // Consult https://kit.svelte.dev/docs/integrations#preprocessors\r\n  // for more information about preprocessors\r\n  preprocess: vitePreprocess(),\r\n\r\n  kit: {\r\n    // adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.\r\n    // If your environment is not supported or you settled on a specific environment, switch out the adapter.\r\n    // See https://kit.svelte.dev/docs/adapters for more information about adapters.\r\n    adapter: adapter({\r\n      // default options are shown. On some platforms\r\n      // these options are set automatically — see below\r\n      pages: \'build\',\r\n      assets: \'build\',\r\n      // fallback: undefined, // for static site\r\n      fallback: \'index.html\', // for SPA\r\n      precompress: false,\r\n      strict: true\r\n    }),\r\n\r\n    prerender: {\r\n      entries: [\r\n        \'*\',\r\n        \'/credential/claimed/[uid]\',\r\n        \'/credential/issued/[uid]\',\r\n        \'/credential/edit/[uid]\',\r\n      ]\r\n    },\r\n\r\n  }\r\n};\r\n\r\nexport default config;\r\n~~~\r\n\r\n**Then it builds, except when we import something from `snarkyjs` in the `+pages.js` of the given page**. \r\n\r\nFor example, the following code in `/credential/claimed/[uid]/+pages.js`:\r\n~~~\r\nimport { error } from \'@sveltejs/kit\';\r\nimport { getPlan, getCommunity, getClaim } from ""@apis/queries"";\r\nimport { getCurrentUser } from \'@models/current-user\';\r\n\r\n\r\nasync function loadClaim(params, user) {\r\n  const claimUid = params.uid;\r\n\r\n  let claim = await getClaim(claimUid);\r\n\r\n  const plan = await getPlan(claim.planUid);\r\n\r\n  const org = await getCommunity(claim.communityUid);\r\n\r\n  claim.community = org.name;\r\n  claim.type = plan.name;\r\n  claim.description = plan.description;\r\n  claim.image = plan.image; \r\n\r\n  return claim; \r\n}\r\n\r\n\r\n/** @type {import(\'./$types\').PageLoad} */\r\nexport async function load({ params, route, url }) {\r\n  if (params.slug !== """") {\r\n      let user = await getCurrentUser();\r\n\r\n      let aClaim = await loadClaim(params, user);\r\n      return JSON.parse(JSON.stringify(aClaim));\r\n    }\r\n    throw error(404, \'Not found\');\r\n}\r\n~~~\r\n\r\nBuilds correctly:\r\n~~~\r\n...\r\n.svelte-kit/output/server/index.js                                                          83.51 kB\r\n\r\nRun npm run preview to preview your production build locally.\r\n\r\n> Using @sveltejs/adapter-static\r\n  Wrote site to ""build""\r\n  ✔ done\r\n✓ built in 7.36s\r\n~~~\r\n\r\n**BUT adding just `import { Field } from \'snarkyjs\';` to the top of the same code it generates the error**:\r\n\r\n~~~\r\n\r\nnode:internal/event_target:1036\r\n  process.nextTick(() => { throw err; });\r\n                           ^\r\nTypeError [Error]: Cannot read properties of undefined (reading \'memory\')\r\n    at Object.<anonymous> (/home/mzito/tmp/sc-ui2/node_modules/snarkyjs/dist/node/bindings/compiled/_node_bindings/plonk_wasm.cjs:14:27)\r\n    at Module._compile (node:internal/modules/cjs/loader:1275:14)\r\n    at Module._extensions..js (node:internal/modules/cjs/loader:1329:10)\r\n    at Module.load (node:internal/modules/cjs/loader:1133:32)\r\n    at Module._load (node:internal/modules/cjs/loader:972:12)\r\n    at ModuleWrap.<anonymous> (node:internal/modules/esm/translators:165:29)\r\n    at ModuleJob.run (node:internal/modules/esm/module_job:193:25)\r\nEmitted \'error\' event on Worker instance at:\r\n    at [kOnErrorMessage] (node:internal/worker:309:10)\r\n    at [kOnMessage] (node:internal/worker:320:37)\r\n    at MessagePort.<anonymous> (node:internal/worker:216:57)\r\n    at [nodejs.internal.kHybridDispatch] (node:internal/event_target:761:20)\r\n    at exports.emitMessage (node:internal/per_context/messageport:23:28)\r\n\r\nNode.js v19.9.0\r\n~~~\r\n\r\n**Please note** that since we are using an static adapter and forcing CSR and disabling SSR for all pages (it is an SPA), it should never try to include any node code, as it seems it is happening.\r\n\r\nConclusions:\r\n\r\n- Including `snarkyjs` in any `+page.js` generates the build error.\r\n- I also happens if we include in `+pages.js` some other code that itself includes snarkyjs.\r\n- Including snarkyjs (or some other code that includes snarkyjs) in `.svelte` files seems to work ok.\r\n\r\nHope this helps.\r\n\r\n\r\n\r\n\r\n\r\n'), ('ymekuria', ""@mazito @45930 I believe we fixed this issue in the `zkapp-cli` scaffold after adding this to the vite config. \r\n```\r\n   optimizeDeps: {\r\n        esbuildOptions: {\r\n            target: 'esnext'\r\n        }\r\n    },\r\n```\r\n\r\nYou should be able to generate and build a Svelte project using the `zkapp-cli` with the latest version `0.11.0` although the scaffold does not use a static adapter. \r\n""), ('mazito', ""@ymekuria Yes, I have that option already settled in the project. \r\n\r\nAnd it works fine for static routes, but **the problem reported here is different, it happens with dynamic routes** (such as `/credential/[uid]`).  I don't know if only with static adapter, but I suppose not.\r\n\r\nHave you tested it with dynamic routes and including `snarkyjs` in the `+pages.js` of such routes ?\r\n\r\nAnyway I solved it by:\r\n\r\n1) cleaning up all snarkyjs imports from those pages, and also avoiding to import any code that imports snarky in any `+pages.js` too. \r\n\r\n2) including those dynamic routes in the `prerender.entries` section of `svelte.config.js`.\r\n\r\nJust writing it here for anyone who may have the same problem.\r\n"")]"
984,add an unsafe `Group.add` with less constraints that does not handle zero,Trivo25,open,,[]
981,Document eng. workflow using a local network in Docker ,nicc,open,"In order to test against a real network (more easily)
As an **internal** code contributor
I want instructions on running a local network in Docker

**Acceptance Criteria**
When I clone the SnarkyJS repo
Then I can see instructions on running a local network in Docker in the **developer** (not public / homepage) [README-DEV](https://github.com/o1-labs/snarkyjs/blob/main/README-dev.md)
And those instructions work when I follow them","[('mitschabaude', 'can we change `README` to `README-dev`?'), ('barriebyron', 'I wrote this doc for another project I worked on https://docs.ignite.com/guide/docker')]"
980,rework `Group.scale` to accept a non-shifted scalar and values of `0` and `1`,Trivo25,open,"Currently, `Group.scale` only takes shifted scalar values -- it would be nice to add an implementation that works with non-shifted values. Additionally, `scale` does not accept `0` or `1` (`g * 1 = g` and `g * 0 = zero`) but throws an error instead.",[]
973,Block crypto PRs on all tests,nicc,closed,Block crypto PRs on both sets of tests that were split apart in issue #971. i.e. crypto PRs should always require a fully passing test suite.,"[('mitschabaude', 'following [the RFC](https://github.com/o1-labs/rfcs/pull/5), the minimal snarkyjs test suggested there might be enough for crypto tests, and we can call this done with https://github.com/MinaProtocol/mina/pull/13430'), ('mitschabaude', 'I think this can be closed now per the comment above')]"
972,Block protocol PRs on protocol-blocking test failures only,nicc,closed,Only block protocol PRs on failures to the subset of tests split out in issue #971.,[]
971,Split tests into protocol-blocking and non-protocol blocking failures,nicc,closed,"We want to set CI up so that only certain tests block protocol from merging PRs.

Which tests should block protocol? @mitschabaude, @bkase ",[]
970,Document ECDSA signature verification,nicc,open,"Create a tutorial that steps through ECDSA signature verification. It shouod be based on the API defined in [this issue](https://github.com/o1-labs/snarkyjs/issues/968).

See reference implementation using Circom: https://github.com/BigWhaleLabs/seal-hub-ecdsa-verifier-contract/blob/main/circuits/ECDSAChecker.circom

From Phil:
ECDSA is the elliptical cryptography scheme used by Ethereum.  SnarkyJS can’t “read” things from Ethereum without having a custom gate for ECDSA. After we have ECDSA, SnarkyJS can allow people eg, to attest to the fact that they own a bored ape on Ethereum without doxxing themselves, or that they have an ETH balance of more than x.  There may also be use cases outside Ethereum

","[('barriebyron', ""I've circled in with Phil Kelly to find out what a use case looks like. thank you @Trivo25  for being my tutorial code partner to deliver the example code for https://github.com/o1-labs/docs2/tree/main/examples/zkapps \r\n\r\nI am up for working on the content but do require engineering support for the command sequence and code\r\n\r\n""), ('barriebyron', '@Trivo25  thank you for being the example code hero!'), ('nicc', 'This should start alongside #968 to parallelise and share context. '), ('barriebyron', 'No doc work to do, yet\nHere is a growing collection of resources:\nSnarkyJS SHA/Keccak RFC design convo https://github.com/o1-labs/rfcs/pull/9\nSnarkyJS ECDSA RFC design convo https://github.com/o1-labs/rfcs/pull/14\n\nSnarkyJS PRs can merge only after crypto updates are in:\nhttps://github.com/o1-labs/snarkyjs/pull/999\nhttps://github.com/o1-labs/snarkyjs/pull/989\nhttps://github.com/o1-labs/snarkyjs/pull/988\n\nOther resources\nhttps://www.notion.so/minaprotocol/ECDSA-ver-gadget-PoC-PRD-9458c38adf204d6b922deb8eed1ac193 \nhttps://www.notion.so/minaprotocol/Ethereum-Primitives-Dependencies-21e56244b1cd43b1807aac39fdd25117 \n1.5 hour video [ECDSA sync](https://drive.google.com/file/d/1Ugy5qT0M880Q-JUxKxQXch-d0S3WedgK/view)\n\n[page 11 of the nullifier PLUME](https://eprint.iacr.org/2022/1255.pdf) paper for the SnarkyJS nullifier\n\n> 2.2 Signatures\n> 2.2.1 ECDSA\n> ECDSA is the signature protocol used by Bitcoin, Ethereum and most blockchain\n> systems [27, 7], due to both Schnorr’s copyright and ECDSA’s relatively smaller key\n> size, especially when compared to RSA. Most RSA keys are 2,048 bits, but the much\n> shorter 256-bit ECDSA key provides roughly equal security to a 3,248 bit RSA key\n> [30].\n> ECDSA uses the secp256k1 curve...\n> Because almost all existing blockchain and public key infrastructure uses this curve\n> for non-deterministic signatures, we are interested in a nullifier construction for this\n> class of curves specifically.'), ('barriebyron', 'Doc outlined in draft PR https://github.com/o1-labs/docs2/pull/562 and ready for dev contributions from @MartinMinkov  or @Trivo25 '), ('barriebyron', ""@nicc I expected to find this issue in the https://github.com/o1-labs/docs2 repo... I don't see how to transfer it, as the author, are you able to move it? \r\nI successfully moved an issue recently... maybe because I was the author? Can you try to move to the docs2 repo?"")]"
969,Benchmark ECDSA signature verification relative to Circom,nicc,open,"Reference implementation: https://github.com/BigWhaleLabs/seal-hub-ecdsa-verifier-contract/blob/main/circuits/ECDSAChecker.circom

How does our performance compare to Circom for the same action above?

Measure all key stages of the developer journey:
- Compilation
- Proof generation
- Verification

This work should be repeatable, even if it's not integrated. i.e. we should be able to build on this or at least integrate it into further becnhmarking efforts. Basically, we don't want to waste this effort by doing a one-off thing, but we also don't want to block benchmarking results until we have an entire framework.","[('stevenpack', '@barriebyron can you watch this issue? good be a good blog post opportunity'), ('Trivo25', 'status: running the ECDSA circom verifier takes 12s for witness generation and 8s for proving (20s total) with Groth16 on my PC -- will follow up with the repository, Plonk benchmarks and other hardware once proving of ECDSA works in SnarkyJS ')]"
968,"Provide a clear API for verifiying ECDSA signatures, based on exposed primitives",nicc,open,"Here's a circuit built with Circom that needs to verify an ECDSA signature for reference: https://github.com/BigWhaleLabs/seal-hub-ecdsa-verifier-contract/blob/main/circuits/ECDSAChecker.circom

Provide a clear, easy-to-use interface for performing this kind of operation. Do we need to wrap the primitives exposed previously in this epic?","[('nicc', 'This should start alongside #970 to parallelise and share context.'), ('mitschabaude', 'TODO: fix TS output of inline classes like `ForeignField`, `ForeignCurve`. It seems we need to define an abstract class or something to make this work')]"
966,Expose ECDSA,joseandro,open,Functor wrappers must have already been expose by the Crypto team before taking on this task. Here @jspada can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
965,Expose SHA-3,joseandro,open,Here @querolita  can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
964,Expose Keccak,joseandro,open,Here @querolita  can help you if you need to clarify anything about this primitive's interface or behavior. ,"[('orkunkilic', 'What’s the ETA for this?'), ('Trivo25', 'Hey @orkunkilic No ETA on this yet, but you can follow the progress here https://github.com/o1-labs/snarkyjs/pull/999')]"
963,Expose FFMul,joseandro,open,Here @jspada can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
962,Expose ROT64,joseandro,open,Here @jspada can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
961,Expose FFAdd,joseandro,open,Here @querolita can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
960,Expose AND,joseandro,closed,Here @querolita can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
959,Expose NOT,joseandro,open,Here @querolita can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
958,Expose XOR,joseandro,open,Here @querolita can help you if you need to clarify anything about this primitive's interface or behavior. ,[]
957,Expose primitives to SnarkyJS (Ethereum + base primitives),joseandro,open,[Here's](https://www.notion.so/minaprotocol/Ethereum-Primitives-Support-PRD-d89af720e1c94f7b90166709432e7bd5) the PRD supporting this effort.,[]
955,Use platform independent commands in scripts,shimkiv,open,Currently `package.json` contains `cp` invocations which are not recognisable by plain Windows shells (Cmd). It will be good to replace such with something platform independent or document the need to configure Windows dev env. with additional tools.,[]
951,(Feature request) Cache contract compilation artifacts,Isaac-DeFrain,closed,"Every time you run a script to interact with a smart contract, you have to first compile the contract which takes a significant amount of time (~30-45 sec). It would be really nice if the provers, verification key, and verify function were cached on the first compilation to speed up future interactions with the same contract!","[('ycryptx', ""I'm building a system that uses a MapReduce to speed up proof accumulation. The ZKProgram compilation happens on every run of the MapReduce operation, and thus degrades the performance improvements I'm trying to get with parallelizing the proving. Without being able to precompile the program, developers like me would find it difficult to accelerate the proving time of contracts""), ('nicc', ""+100 for this in a local context. I also think it's worth thinking about this compilation time in a production / deployed-to-web context. I believe the compiled artefacts can be very large so we probably can't just generate and deploy them to prod. Too big a payload size. But are there smaller, intermediate artefacts that can be added to a web payload to speed of compilation for end users?\n\nI don't think this issue should contain this scope btw. We should just consider it when designing a solution.""), ('mitschabaude', 'Done!')]"
950,Can't compile smart-contract on iOS devices,shimkiv,open,"- Checked on iPhone 14 Pro with iOS v.16.5

Safari's (or any other browser) page that compiles [SC of moderate complexity](https://github.com/o1-labs/e2e-zkapp/blob/develop/e2e-zkapp-sc/src/E2eZkApp.ts) (by @method count) crashes after ~1.5-2 minutes which causes page reload.
Crash reports are saying about exceeding of different limits:

```shell
Event:            cpu usage
Action taken:     none
CPU:              90 seconds cpu time over 123 seconds (73% cpu average), exceeding limit of 50% cpu over 180 seconds
CPU limit:        90s
Limit duration:   180s
CPU used:         90s
CPU duration:     123s
Duration:         123.20s
Duration Sampled: 112.54s
Steps:            98


Event:            wakeups
Action taken:     none
Wakeups:          45001 wakeups over the last 57 seconds (789 wakeups per second average), exceeding limit of 150 wakeups per second over 300 seconds
Wakeups limit:    45000
Limit duration:   300s
Wakeups caused:   45001
Wakeups duration: 57s
Duration:         57.02s
Duration Sampled: 50.95s
Steps:            19
```

- Interestingly, same in-browser SC compilation works on iPad Pro with iPadOS v.16.5 (Chrome only, [not in Safari or Firefox](https://github.com/o1-labs/snarkyjs/issues/949))

---

[Internal discussion and crash reports](https://o1-labs.slack.com/archives/C028Q27R8UC/p1685729799013959)",[]
949,SnarkyJS doesn't work on iPad's Safari or Firefox but works in Chrome,shimkiv,open,"- Checked with iPad Pro with iPadOS v.16.5 and latest versions of browsers.

It feels like the same issue as https://github.com/o1-labs/snarkyjs/issues/823 which happens in Safari or Firefox browsers but everything works fine in Chrome.

More details will be added later or on-request.",[]
948,Update contract/verification key outside of contract method,Isaac-DeFrain,open,"I presume that the intention for updating a contract on-chain is that it should only be possible if a method is provided to do so. In other words, if a dev wants their contract to be updateable, they must include a corresponding method in the contract, to set the verification key.

Having said that, I would expect to get an error when attempting to set the verification key of a zkapp account _outside of a contract method_. However, no such error is thrown when creating the transaction. Instead, the transaction is sent to the network with no effect other than deducting the fee from the fee payer [for example](https://berkeley.minaexplorer.com/transaction/5Ju1Pvpp9us1sW36nxbPidhYr26arx3WNYnmkqeSrYn6CfHrrxjW)

Setting of other permission properties display a similar behavior, e.g. `delegate` and `zkappUri`.",[]
947,Action/Event limits LocalBlockchain vs Berkeley,Isaac-DeFrain,open,"Up to 100 actions/events are supported per transaction on `Mina.LocalBlockchain()` but only up to 16 are supported on the Berkeley network. As a result, one could pass all tests locally and still deploy an incorrect contract.","[('shimkiv', ""Thanks! We're aware of this issue, the [limits](https://github.com/o1-labs/snarkyjs/blob/f250e614eb7ff62741210db037d29a8ac710e60f/src/lib/mina/constants.ts#L25) you mentioned are applied across whole the SDK, not only for LocalBlockchain. Next Berkeley redeployment will match limits."")]"
945,Fix broken Wasm build,mitschabaude,closed,,[]
944,`getNetworkState` doesn't fetch network state,Isaac-DeFrain,open,"Neither the Mina Explorer or Minascan GraphQL endpoints return the network state via `Mina.getNetworkState()`

![image](https://github.com/o1-labs/snarkyjs/assets/42081488/f8f9fd7e-a122-4098-a142-d5ed18fc607b)
![image](https://github.com/o1-labs/snarkyjs/assets/42081488/4ccd45f9-78b8-40ee-8a76-974b52879035)
","[('mitschabaude', 'the API is probably misleading. this is for getting a cached network state inside `MIna.transaction` (where async fetches are not possible). To fetch the network state, there is the top level export `fetchLastBlock()`'), ('Isaac-DeFrain', 'That certainly explains why `getNetworkState()` is not async.'), ('Isaac-DeFrain', 'Some additional comments for that method could clear up this confusion')]"
943,(Feature request) Cyclic method call detection,Isaac-DeFrain,open,"Suppose I define a smart contract with mutually recursive method calls that are obviously nonterminating because they are cyclic. E.g. (obviously this is contrived)

```typescript
@method method1() {
  method2()
}

@method method2() {
  method1()
}
```

and call `zkApp.method1()` at some point.

It should be possible to detect this cyclic calling of methods early and exit with an error. Instead you get 1,000 or so lines of repeating

```txt
...
at runWith (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/global-context.js:55:18)
at Function.runWith (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/global-context.js:14:37)
at runCalledContract (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/zkapp.js:243:65)
at file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/zkapp.js:277:19
at runWith (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/global-context.js:55:18)
at Function.runWith (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/global-context.js:14:37)
at Circular.wrappedMethod (file:///home/quantifier/Documents/Mina/zkapps/itn-custom/qa/node_modules/snarkyjs/dist/node/lib/zkapp.js:215:47)
...
```",[]
942,(Feature requests) Type checking for event values,Isaac-DeFrain,open,AFAICT there is no static type checking for event values even though we define events with specific value types. Incorrect event value types are caught at runtime. It would be really nice to catch this earlier!,[]
941,(Feature request) Easier way to increment nonce,Isaac-DeFrain,open,"It would be very nice to have an easier way to increment an account's nonce. I see at least three ways to do it:
- change the type of the `nonce` field in `FeePayerSpec` to `UInt32` (it is `UInt32` in `Account` after all)
- add a method to `UInt32` to convert to `number`
- add an `incrementNonce()` method to `Account` (or something along those lines)","[('mitschabaude', ""Thanks! Both of the first two sound very helpful! So I'm guessing you want to optimize a code snippet that\r\n* gets /fetches an account\r\n* take the nonce from there\r\n* pass this nonce + 1 to the fee payer spec""), ('mitschabaude', ""FWIW, I think an important change is to fetch an account's nonce from the tx pool instead of from the last block (there is a graphql query for that)""), ('Isaac-DeFrain', ""> gets /fetches an account\r\ntake the nonce from there\r\npass this nonce + 1 to the fee payer spec\r\n\r\nThat's exactly my use case! The simplest way I could find to do it in the current state is this\r\n\r\n```typescript\r\nfunction wellDefine(n: UInt32 | undefined) {\r\n  if (n === undefined) {\r\n    return UInt32.zero;\r\n  } else {\r\n    return n;\r\n  }\r\n}\r\n\r\n// new nonce\r\nlet nonce = 0;\r\nwhile (\r\n  UInt32.from(nonce)\r\n    .lessThanOrEqual(wellDefine(feePayerAccount?.nonce))\r\n    .toBoolean()\r\n) {\r\n  nonce += 1;\r\n}\r\n```""), ('Isaac-DeFrain', ""> FWIW, I think an important change is to fetch an account's nonce from the tx pool instead of from the last block (there is a graphql query for that)\r\n\r\nAgreed. Fetching the nonce from the last block doesn't necessarily prevent the `Insufficient_replace_fee` errors. My hope is that having an easy way to increment nonces will do just that."")]"
940,(Feature request) Display `locations` and `path` arrays when printing `statusText` field,Isaac-DeFrain,open,"It would be very helpful to see the line of the command which has an insufficient fee. I presume this info is contained in `locations` but it is not displayed in the error message.
![image](https://github.com/o1-labs/snarkyjs/assets/42081488/4c0072e5-9f07-47d4-80e6-34ddb7a7cb2a)",[]
937,Field.fromBits() can't be of length 0,shimkiv,open,"An attempt of getting the `Field` from empty string results in error: `Field.fromBits(): bit length must be positive, got 0`. But it should be possible to get Field from 0 length bits.

---

[Internal discussion](https://o1-labs.slack.com/archives/C028Q27R8UC/p1685614747822749)",[]
934,Remove @method limits per Smart-Contract unit,shimkiv,open,"Currently we have a limit of 21 @method per Smart-Contract. But it seems this limit can be removed entirely without workarounds.
It will be good to have it implemented.

---

[Internal discussion](https://o1-labs.slack.com/archives/C028Q27R8UC/p1685465148660699?thread_ts=1683480776.437259&cid=C028Q27R8UC)",[]
930,Avoid throwing an error if private key is missing unless .send() is executed,marekyggdrasil,closed,"Hello everyone. I am working on a contribution to SnarkyJS and I am opening this thread just to have a corresponding issue to my pull request.

The problem I discovered while working on https://github.com/sqrt-xx/mina-ui-deployment, particularly, I could not sign the zkApp deployment transaction using AURO. There is nothing wrong with AURO signing capabilities. The problem originates from SnarkyJS as it will raise an exception if signer private key is missing during the transaction building when account creation fee is included.

The related discussion thread is: https://discord.com/channels/484437221055922177/1109079490111479848","[('marekyggdrasil', 'Many thanks for guidance and letting me help fixing this!')]"
928,Make stack trace prettifying cover >90% of dev flows,mitschabaude,closed,,[]
927,Initial WebGPU MVP,mitschabaude,closed,"Scope: Polynomial multiplication and addition, integrated with Kimchi, running natively.
Running in JS and implementing more complex algorithms is an ""extension"".","[('shimkiv', 'Can help you run the PoC in e2e environment. Please let me know if you will need any help with it.'), ('nicc', 'Please sync with @jspada and @fabrizio-m before embarking on this. '), ('mitschabaude', 'I think you mean @joseandro! I will 👍🏻 '), ('mitschabaude', 'done')]"
926,Remove all uses of JS classes from OCaml,mitschabaude,closed,"Depends on all ""Move _ to JS issues""","[('mitschabaude', 'closed by https://github.com/o1-labs/snarkyjs/pull/979')]"
925,Move Scalar to JS,mitschabaude,closed,Same as https://github.com/o1-labs/snarkyjs/pull/902 but for the `Scalar` class,"[('shimkiv', 'Can we please add more details here regarding an overall impact on existing codebase and apps?'), ('mitschabaude', '> Can we please add more details here regarding an overall impact on existing codebase and apps?\r\n\r\ndone!')]"
924,Move Group to JS,mitschabaude,closed,"This issue aims to move the Group implementation from OCaml to JavaScript, reducing OCaml dependencies as best as possible.","[('shimkiv', 'Can we please add more details here regarding an overall impact on existing codebase and apps?')]"
923,Benchmark core development workflows,nicc,open,"In order to improve developer and user experience through faster workflows
All core components in the critical path should be benchmarked for a baseline and ongoign comparison

The following components (is there a better name? ...steps? ...functions?) should be benchmarked:
- Compilation
- Proof generation
- (SnarkyJS) Verification
- Startup time
- Deployment
- ...anything else? Scaffolding is infrequent and interactive so is it worth measuring?

Benchmarks should be derived from CI or nightly builds (as opposed to user telemetry) and published somewhere. 

Questions:
- Should we warn on performance regression?
- How do we systematise / get into the habit of checking performance impacts and communicating them with every release?","[('shimkiv', '- View/rendering example of [""publish somewhere""](https://o1labs-grafana.p42.xyz/d/H-L-ytP4k/snarkyjs-simple-benchmarking?orgId=1&refresh=10s&from=now-30d&to=now).\n\n> Should we warn on performance regression?\n\nDefinitely but baseline should be established first.\n\n> How do we systematise / get into the habit of checking performance impacts and communicating them with every release?\n\nAs part of PR gates/chaecks?')]"
922,Turn proving off by default,nicc,open,"To speed up the development workflow
Proving should be turned off by default

Questions:
- Does this open up the potential to deploy broken apps? Would a dev miss catching any issues if proofs aren't generated until the app is deployed?
- What needs to change in our documentation and tutorials?","[('mitschabaude', 'I see some risks in doing this. One change that we should definitely make alongside this is to run the transaction callback in ""checked computation mode"", i.e. using `runAndCheck`. This will catch basic stuff that you can\'t do in a circuit, like reading out field element values.\r\n\r\nStill, there\'s a large error surface, including writing circuits that change each time you run them, which is not captured when running with proofs disabled. It would be nice if we could reduce that error surface over time and add more checks that emulate the full prover environment without incurring the costs of proving'), ('shimkiv', ""If we're talking about this as general approach not, say, for LocalBlockchain only, then I definitely don't think this should be a default. \nThough, having a simple switch (environment variable perhaps) for this would be great.""), ('mitschabaude', ""We're talking about LocalBlockchain"")]"
914,Swap out Wasm curve arithmetic with faster implementations,mitschabaude,open,"Under the hood, snarkyjs depends on a [Rust code base](https://github.com/o1-labs/proof-systems) which is based on arkworks for finite field and elliptic curve implementations. These are fairly slow when compiled to Wasm, in part due to some Wasm idiosyncracies, and there are faster options available:

* [Zprize showed](https://github.com/mitschabaude/montgomery) how Wasm arithmetic can be made ~2x faster. This could yield a nice speedup in both the browser and Node.js when swapped out for the arkworks implementations
* In Node.js, we could instead use any native implementation which will always be faster than Wasm. However, an even faster alternative here would be to swap out the _entire_ stack of OCaml and Rust dependencies for a native build

There is some promising work by Parity to swap out the arkworks curve arithmetic (with native implementations) to get major speedups over the Wasm version: https://github.com/paritytech/ark-substrate","[('stevenpack', 'Looks promising. @mitschabaude can you fill out the estimate for this?')]"
913,Building SnarkyJS,es92,closed,"Having some issues when trying to build SnarkyJS from scratch, and then linking it into a project. What I'm doing:

```
$ git clone git@github.com:MinaProtocol/mina.git
$ git submodule update --init --recursive
$ cd src/lib/snarkyjs
$ npm install
$ npm run build:web
```

Then, from the ui folder of a svelte zkApp-cli project:

```
$ rm -rf node_modules/snarkyjs
$ npm link ~/gits/mina/src/lib/snarkyjs
```

npm run dev when loading the site on a browser yields:
```
* Internal server error: Failed to resolve entry for package ""snarkyjs"". The package may have incorrect main/module/exports specified in its package.json.
```

If I do

```
$ npm run build:node
```

Then instead npm run dev when loading the site on a browser yields:
```
ReferenceError: module is not defined
```","[('ycryptx', 'Facing the same issue '), ('mitschabaude', 'Does it work if you install local snarkyjs with `npm i ../path/to/snarkyjs`?'), ('mitschabaude', 'Btw, you probably want to run both `npm run build` and `npm run build:web`'), ('es92', '> Does it work if you install local snarkyjs with `npm i ../path/to/snarkyjs`?\r\n\r\nUnfortunately does not work, same set of errors @mitschabaude \r\n\r\n> Btw, you probably want to run both `npm run build` and `npm run build:web`\r\n\r\nThis has the same result as if I include `$ npm run build:node` (`ReferenceError: module is not defined`)\r\n'), ('ycryptx', ""Can confirm that's true @es92 ""), ('shimkiv', ""@es92 @ycryptx \r\nSince you're using `cd src/lib/snarkyjs` path I assume you're using Mina's latest `rampup` or `berkeley` branch. In which case before building SnarkyJS you need to update its sub-modules too. \r\nThen, `npm link` isn't it the [two-step process](https://docs.npmjs.com/cli/v9/commands/npm-link)? You first issue `npm link` being in SnarkyJS repo and then `npm link snarkyjs` being in zkApp repo.\r\nSo the steps might look like the following.\r\n\r\nMina repo:\r\n\r\n```shell\r\ngit clone git@github.com:MinaProtocol/mina.git\r\ncd mina/\r\ngit submodule update --init --recursive\r\ncd src/lib/snarkyjs\r\ngit submodule sync\r\ngit submodule update --recursive --init\r\nnpm install\r\nnpm run build:node\r\nnpm run build:web\r\nnpm link\r\n```\r\n\r\nzkApp repo:\r\n\r\n```shell\r\nrm -rf node_modules/snarkyjs\r\nnpm link snarkyjs\r\nnpm install\r\nnpm run dev\r\n```""), ('shimkiv', ""> isn't it the [two-step process](https://docs.npmjs.com/cli/v9/commands/npm-link)?\r\n\r\nRight, can be simplified into one command.\r\n\r\nAnyway, using steps described in previous comment worked for me. ""), ('es92', ""Confirmed this has worked for me as well! I think the key was checking out the berkeley branch (tried / was trying develop and didn't seem to work with that).\r\n\r\nThanks!""), ('es92', ""Nvm, unfortunately this didn't work. With the above I'm still getting \r\n\r\n`Internal server error: module is not defined`.\r\n\r\nI think the issue could be, running `npm install` after `npm link snarkyjs` seems to be reinstalling the packaged remove version of snarkyjs, overriding the linked version.\r\n\r\nIf `npm install` is run first, same errors still show up""), ('ycryptx', '@es92 Did you manage to solve this?\r\n'), ('es92', 'Nope, still stuck with above'), ('mitschabaude', 'It works with published snarkyjs though, right? If yes, then you should be able to install from source by doing `npm pack` inside the snarkyjs repo and then installing the resulting tarball in your other project (and make sure to unlink snarkyjs). That should be equivalent to the install process that installing from npm gives you'), ('MartinMinkov', 'I ran into the same issues related to `ReferenceError: module is not defined` when building locally and using that build inside a Svelte app by either specifying the file path manually in my UI `package.json` or by using `npm link`.\r\n\r\nI just wanted to confirm that using `npm pack` worked instead!'), ('marekyggdrasil', 'The `npm pack` is working for me as well. Here\'s how I setup my local dev environment for SnarkyJS.\r\n\r\nFirst of all, checking if it is same environment for all three directories (zkApp, SnarkyJS, smart contract)\r\n\r\n```\r\n$ nvm current\r\nv18.16.0\r\n```\r\n\r\nIn the SnarkyJS directory I run the steps provided by @shimkiv in https://github.com/o1-labs/snarkyjs/issues/913#issuecomment-1549075745 but instead of `npm link` I use `npm pack`\r\n\r\n```\r\ngit submodule update --init --recursive\r\nnpm install\r\nnpm run build:node\r\nnpm run build:web\r\nnpm pack\r\n```\r\n\r\nthis creates `/Users/marek/Development/open-source/snarkyjs/snarkyjs-0.10.1.tgz`\r\nthen in the smart contracts directory I run\r\n\r\n```\r\nrm -rf node_modules/\r\nnpm install /Users/marek/Development/open-source/snarkyjs/snarkyjs-0.10.1.tgz\r\nnpm run build\r\n```\r\n\r\nfinally in the zkApp directory\r\n\r\n```\r\nrm -rf node_modules/\r\nnpm install /Users/marek/Development/open-source/snarkyjs/snarkyjs-0.10.1.tgz\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\nRuns correctly.\r\n\r\nIf you are curious what happens if I use `npm link`, it also builds and starts but the zkApp crashes during compiling and my console gets flooded with following errors regarding undefined `navigator`\r\n\r\n```\r\n- ready started server on 0.0.0.0:3000, url: http://localhost:3000                                                                 [54/1846]\r\n- event compiled client and server successfully in 6.2s (214 modules)                                                                       \r\n- wait compiling...                                                                                                                         \r\n- wait compiling /_error (client and server)...                                                                                             \r\n- event compiled client and server successfully in 1620 ms (215 modules)                                                                    \r\nReferenceError: navigator is not defined                                                                                                    \r\n    at getEfficientNumWorkers (webpack-internal:///../../../snarkyjs/dist/web/index.js:9131:17)                                             \r\n    at async initSnarkyJS (webpack-internal:///../../../snarkyjs/dist/web/index.js:11328:20)                                                \r\n    at async eval (webpack-internal:///../../../snarkyjs/dist/web/index.js:11447:1)                                                         \r\n- warn Fast Refresh had to perform a full reload due to a runtime error.                                                                    \r\n- wait compiling / (client and server)...                                                                                                   \r\n- event compiled client and server successfully in 453 ms (235 modules)                                                                     \r\n- error javascript/snarkyjs/dist/web/index.js (9057:0) @ getEfficientNumWorkers                                                             \r\n- error Error [ReferenceError]: navigator is not defined                                                                                    \r\n    at getEfficientNumWorkers (webpack-internal:///../../../snarkyjs/dist/web/index.js:9131:17)                                             \r\n    at async initSnarkyJS (webpack-internal:///../../../snarkyjs/dist/web/index.js:11328:20)                                                \r\n    at async eval (webpack-internal:///../../../snarkyjs/dist/web/index.js:11447:1) {                                                       \r\n  digest: undefined                                                                                                                         \r\n}                                                                                                                                           \r\n  9055 | async function getEfficientNumWorkers() {                                                                                          \r\n  9056 |   let gpuTier = await f();                                                                                                         \r\n> 9057 |   let numCpus = navigator.hardwareConcurrency;                                                                                     \r\n  9058 |   let gpuModel = gpuTier.gpu;                                                                                                      \r\n  9059 |   var numWorkers = {                                                                                                               \r\n  9060 |     ""apple m1"": 2,                                                                                                                 \r\nReferenceError: navigator is not defined                                                                                                    \r\n    at getEfficientNumWorkers (webpack-internal:///../../../snarkyjs/dist/web/index.js:9131:17)                                             \r\n    at async initSnarkyJS (webpack-internal:///../../../snarkyjs/dist/web/index.js:11328:20)                                                \r\n    at async eval (webpack-internal:///../../../snarkyjs/dist/web/index.js:11447:1) {                                                       \r\n  page: \'/\'                                                                                                                                 \r\n}                                                                                                                                           \r\nReferenceError: navigator is not defined                                                                                                    \r\n    at getEfficientNumWorkers (webpack-internal:///../../../snarkyjs/dist/web/index.js:9131:17)                                             \r\n    at async initSnarkyJS (webpack-internal:///../../../snarkyjs/dist/web/index.js:11328:20)                                                \r\n    at async eval (webpack-internal:///../../../snarkyjs/dist/web/index.js:11447:1) {                                                       \r\n  page: \'/\'                                                                                                                                 \r\n}                                                                                                                                           \r\nReferenceError: navigator is not defined                                                                                                    \r\n    at getEfficientNumWorkers (webpack-internal:///../../../snarkyjs/dist/web/index.js:9131:17)                                             \r\n    at async initSnarkyJS (webpack-internal:///../../../snarkyjs/dist/web/index.js:11328:20)                                                \r\n    at async eval (webpack-internal:///../../../snarkyjs/dist/web/index.js:11447:1)                                                         \r\n- warn Fast Refresh had to perform a full reload. Read more: https://nextjs.org/docs/messages/fast-refresh-reload                           \r\n- error javascript/snarkyjs/dist/web/index.js (9057:0) @ getEfficientNumWorkers                                                             \r\n- error Error [ReferenceError]: navigator is not defined   \r\n```\r\n\r\nInsteresting that `navigator` seems recognized if `npm pack` is used but is undefined if `npm link` is used.'), ('mitschabaude', ""Seems like, if `npm link` is used, sveltekit (or whatever tools it's using under the hood) tries to run the web build output in node at some point. I think this is incorrect behavior by the UI framework -- it should be fine to use `navigator` in a web library.\r\n\r\nI think we can leave this unaddressed since it's not the normal user path and there's a workaround"")]"
910,Add bundler annotations to make o1js work in Angular,directcuteo,open,"I want to include the capabilities of SnarkyJS in my web application. The only code I added that uses snarkyjs is the following one.

```
import { SmartContract } from 'snarkyjs';

class Square extends SmartContract {
}
```

This resulted in the error below. The error is coming from a snarkyjs file.
Have I made a mistake?

![image](https://github.com/o1-labs/snarkyjs/assets/37619567/19067af2-ce6a-490e-bbea-065f4da68943)

![image](https://github.com/o1-labs/snarkyjs/assets/37619567/e9bd22dc-911a-4535-807d-efb854aee8f4)
","[('mitschabaude', 'can you add more context about your build setup / UI framework? it seems parts of snarkyjs that are necessary are not bundled properly'), ('directcuteo', 'I am using it in an Angular v15 app which is built using Webpack v5.75.0\n'), ('mitschabaude', '@ymekuria do you have an idea what could happen here?'), ('directcuteo', '@mitschabaude Do you have any updates regarding this issue? Thanks!'), ('mitschabaude', ""@directcuteo I haven't looked into it. It seems that Angular / webpack is trying to compile snarkyjs' web bundle and is doing something wrong. Since snarkyjs' bundle should work as is, without transpilation, maybe there's some option that you can give to webpack to ignore snarkyjs when bundling the code, i.e. leave it untouched?""), ('directcuteo', ""@mitschabaude can you share a simple HTML + Javascript example of how to use o1js?\r\n\r\nI can't really figure out what is going on but Angular has a big community so maybe it should be included in the integration tutorial.\r\nThanks!""), ('mitschabaude', 'sure! plain html & js example:\r\n\r\n* take `index.js` which is shipped in the npm package at `/dist/web/index.js`\r\n* make sure `index.js` is located next to `index.html`\r\n* serve the following `index.html`:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=""utf-8"" />\r\n    <title>hello-snarkyjs</title>\r\n    <script type=""importmap"">\r\n      { ""imports"": { ""snarkyjs"": ""./index.js"" } }\r\n    </script>    \r\n    <script type=""module"">\r\n      import { Field } from ""snarkyjs"";\r\n      console.log(Field(-1));\r\n    </script>\r\n  </head>\r\n  <body>\r\n    <div>Check out the console (F12)</div>\r\n  </body>\r\n</html>\r\n```'), ('mitschabaude', 'So the point is, it\'s better if your web framework doesn\'t try to transform the snarkyjs build output (bundling should be fine; it should know where to resolve it from the package.json ""exports"" field)'), ('directcuteo', ""Your example works, I appreciate!\r\n\r\nMy opinion:\r\nThe thing is that because I import `SmartContract` in an Angular component, Angular will include `o1js` in its bundling/tree-shaking thing. The problem is that this changes the names of functions and variables. By default this should not be an issue. The issue is that `wasm` is imported later and it will call a function from javascript which (and here is the surprise) doesn't exist anymore because of the tree-shaking.\r\nFollowing this discussion [https://github.com/evanw/esbuild/issues/458](https://github.com/evanw/esbuild/issues/458) if I get it right, there should be some flag added in `o1js` that will not allow the tree-shaking because it has side-effects (`wasm` will fail to call the functions).\r\nWhat are your thoughts?""), ('mitschabaude', ""@directcuteo wow, thanks for investigating! I'll look into this""), ('directcuteo', 'Small upd: building `o1js` locally and using it in the Angular app without the minifier resulted that the undefined function is `_mainWorker`\r\n\r\n![image](https://github.com/o1-labs/o1js/assets/37619567/b640f3e0-613f-4886-b3db-57455335fdd9)\r\n'), ('mitschabaude', ""hm that's weird.. this is a transformed version of the code here, which has normal function code inside `mainWorker()`:\r\nhttps://github.com/o1-labs/o1js-bindings/blob/66061bfd2349c16414330410881fcf6e6473ed6d/js/web/web-backend.js#L117-L124""), ('mitschabaude', 'Maybe Angular does something clever with `Worker` calls that interferes with the [very custom way we create web workers](https://github.com/o1-labs/o1js/pull/33)'), ('directcuteo', 'That transformed version is coming from a blob file imported via http request.\r\n\r\n![Screenshot 2023-09-13 at 16 40 08](https://github.com/o1-labs/o1js/assets/37619567/6274afa3-9d88-4438-9eb8-7b21d9cec582)\r\n\r\nI am wondering how does webpack/angular come in play here anyway. Do you know how that file is created?'), ('mitschabaude', ""> Do you know how that file is created?\r\n\r\nYes it's created on the fly from function source code, with `Function.toString()`, which is then put in a Blob, which then the worker is created from\r\nSee explanation here: https://github.com/o1-labs/o1js/pull/33""), ('directcuteo', ""Do you know if this works with `react`? Isn't react also bundled by webpack?"")]"
909,Implement Wordle UI,nicc,open,,[]
906,Investigate bottlenecks in non-prover operations,mitschabaude,open,,[]
905,Mask parts of the network precondition that provide bad DX given current protocol functionality,bkase,open,,[]
904,Warning or error for `AccountUpdate` in ordinary conditional,Isaac-DeFrain,open,"I noticed that if one does something like
```typescript
if (someCondition) {
  this.send({ to, amount })
}
```
inside of a smart contract method, then even when `someCondition` evaluates to `true`, the account update not only does not happen, but no warning or error is provided. Something along the lines of notifying the dev that they did an account update inside an ordinary conditional, but need to do this inside of a `Circuit.if` for it to take effect would be very helpful.","[('mitschabaude', ""That behavior doesn't seem plausible to me. If `someCondition` is always a truthy JS value, then that conditional will always be executed. This is how JS works and has nothing to do with snarkyjs"")]"
903,Pushing to array causes heap OOM error,Isaac-DeFrain,closed,"The contract method
```typescript
@method update() {
  let num = this.num.get();
  this.num.assertEquals(num);

  let arr = [UInt64.from(1), UInt64.from(2), UInt64.from(3)];
  for (let i = 0; i < arr.length; i++) {
    Circuit.if (
      num.lessThan(arr[i]),
      UInt64.from(arr.push(num)),
      UInt64.from(0)
    );
  }
}
```

The error message
```
<--- Last few GCs --->

[3583:0x5735a60]   295530 ms: Scavenge (reduce) 2044.6 (2081.2) -> 2043.6 (2081.5) MB, 2.9 / 0.0 ms  (average mu = 0.157, current mu = 0.120) allocation failure; 
[3583:0x5735a60]   297409 ms: Mark-sweep (reduce) 2044.6 (2081.5) -> 2042.8 (2081.5) MB, 1872.1 / 0.0 ms  (average mu = 0.109, current mu = 0.060) allocation failure; scavenge might not succeed


<--- JS stacktrace --->

FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory
 1: 0xb652d0 node::Abort() [node]
 2: 0xa761b5 node::FatalError(char const*, char const*) [node]
 3: 0xd55b6e v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [node]
 4: 0xd55ee7 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [node]
 5: 0xf32f15  [node]
 6: 0xf33e18 v8::internal::Heap::RecomputeLimits(v8::internal::GarbageCollector) [node]
 7: 0xf44323  [node]
 8: 0xf45198 v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [node]
 9: 0xf1fafe v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]
10: 0xf20ec7 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [node]
11: 0xf0209a v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [node]
12: 0x12c548f v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [node]
13: 0x16f6939  [node]
Aborted
```","[('mitschabaude', ""isn't this just an infinite loop? :D you're iterating until `arr.length` which is never reached because you're also pushing to that array?""), ('Isaac-DeFrain', ""It appears that it is, but it shouldn't be.\r\n\r\n(Editing after further investigation)\r\nOne would expect that this should only add at most `arr.length` elements (in this case 3) to `arr` because of the strict condition `num.lessThan(arr[i])`. When `i = 3`, `arr[3] === num`, making `num.lessThan(arr[3]) === Bool(false)` so we don't push another element. Similarly for `i = 4` and `i = 5`.""), ('Isaac-DeFrain', ""You're right about `arr.length`, it changes during execution!\r\nIs is wrong to expect similar semantics to this?\r\n![image](https://user-images.githubusercontent.com/42081488/236948889-c535c178-7b67-4de6-94dc-969857ccfe40.png)""), ('mitschabaude', ""Ok sorry I didn't catch the details of the example -- that this would stop pushing to the array and finish, if one of the `if` branches wouldn't be executed.\r\n\r\n>  Is is wrong to expect similar semantics to this?\r\n\r\nYes, those semantics can't be expected, because you're writing normal JS that is executed as JS, with no compilation or anything like it going on. And `Circuit.if()` is not a builtin JS control flow operator, it's a normal function call. When you call a function, all of its arguments are evaluated before the function call. So, in your original example, you're performing `arr.push(...)` in every loop iteration, while in the last example, it's behind an actual `if` statement so it's not always executed.""), ('Isaac-DeFrain', 'Gotcha. In that case, is it possible to add a premature error about the infinite loop? Otherwise, you just wait a few minutes for the heap to be exhausted which is not ideal. Maybe this is a good task for a static analysis tool 😉 '), ('trevorbernard', ""That difference is certainly confusing and will likely be the source of hard to catch bugs. One way to match the JavaScripts `if` semantics could be passing in a function references for both paths of the branch but I don't know if that's any better. Ideally JavaScript would have a macro system for syntactic sugar but alas it doesn't. I agree with Isaac in that this could be part of a static code analysis tool or at the very least, have it documented somewhere as a warning.""), ('mitschabaude', ""Yeah, I definitely agree that this should be part of `Circuit.if`'s documentation! Also, catching it with static analysis would be awesome but seems challenging to me.\r\n\r\n> One way to match the JavaScripts if semantics could be passing in a function references for both paths of the branch but I don't know if that's any better.\r\n\r\nA proper if statement with different branches that get executed conditionally would be awesome, and you're right that a callback API would enable that. However, our proof system doesn't support branching in a straightforward way. It's not currently possible to conditionally add constraints to a zk program.""), ('mitschabaude', 'I addressed this for now by including a warning in the doccomments of `Circuit.if` in this PR: https://github.com/o1-labs/snarkyjs/pull/889')]"
901,"Improve ""range check helper"" error messages ",mitschabaude,open,"```
rangeCheckHelper: expected XXX to fit in 64 bits
```

These errors can occur in most UInt64 and UInt32 methods (because they include a ""range check"").
They should be made more accessible to users and present solutions to the problem.

Example: https://github.com/o1-labs/snarkyjs/issues/895

","[('mitschabaude', 'Update: with https://github.com/o1-labs/snarkyjs/pull/902, these errors arguably get even worse because `rangeCheckHelper` will not throw an error anymore. So we get something like\n\n```ts\nUInt32.from(3).sub(5);\n```\n```\n/home/gregor/o1/mina/src/lib/snarkyjs/src/lib/field.ts:156\n          throw Error(`Field.assertEquals(): ${this} != ${y}`);\n                ^\n\nError: Field.assertEquals(): 0 != 28948022309329048855892746252171976963363056481941560715954676764349967630336\n    at Field.assertEquals (snarkyjs/src/lib/field.ts:156:17)\n    at UInt32.sub (snarkyjs/src/lib/int.ts:542:41)\n```')]"
900,Improve `Permutation failed` error message,nicc,open,'Permutation failed' error occurs when you create a different circuit every time because you use a constant instead of a variable. Can this be improved?,[]
899,Improve `Can't evaluate prover code outside an as_prover block` error message,nicc,closed,Can we get more info on this one? Submitted by rpanic on issue #849.,"[('mitschabaude', 'basically same issues: #489 #478'), ('mitschabaude', 'I wrote up some ideas for this here: https://github.com/o1-labs/snarkyjs/pull/902#discussion_r1211360904')]"
898,Improve `<none>` error during veteranUpdate method call test,nicc,open,https://user-images.githubusercontent.com/36684975/231592134-06c188e3-338a-4894-a461-5b309da8c776.png,[]
897,Improve `Account_action_state_precondition_unsatisfied` error,nicc,open,"`Account_action_state_precondition_unsatisfied` error occurs during `Reducer.reduce`, usually when you reduce the wrong set of actions (because you hash the wrong actions and the target hash doesn't match the committed on-chain hash anymore).

Is this always indicative of the same error? Can we catch this and present a more helpful message?",[]
896,Error: Cannot find module - Windows OS,directcuteo,closed,"I am trying to run a simple example from the HelloWorld tutorial but there is an error when I try to build the file:

`npm run build`
`node build/src/main.js`

```
D:\mina\hello-world-zk-app\node_modules\snarkyjs\dist\node\_node_bindings\snarky_js_node.bc.cjs:7427
         throw err;
         ^
Error: Cannot find module 'D:\D:\mina\hello-world-zk-app\node_modules\snarkyjs\dist\node\snarkyjs-bindings\js\node\node-backend.js'
    at Module._resolveFilename (node:internal/modules/cjs/loader:1082:15)
    at Module._load (node:internal/modules/cjs/loader:928:27)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:83:12)
    at MessagePort.<anonymous> (node:internal/main/worker_thread:185:26)
    at [nodejs.internal.kHybridDispatch] (node:internal/event_target:762:20)
    at exports.emitMessage (node:internal/per_context/messageport:23:28)
Emitted 'error' event on Worker instance at:
    at [kOnErrorMessage] (node:internal/worker:323:10)
    at [kOnMessage] (node:internal/worker:334:37)
    at MessagePort.<anonymous> (node:internal/worker:229:57)
    at [nodejs.internal.kHybridDispatch] (node:internal/event_target:762:20)
    at exports.emitMessage (node:internal/per_context/messageport:23:28) {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
```

it is pretty clear what the error is: there is double ""D"" -> D:\D:\mina\hello-world-zk-app.......

My setup:
```
Windows 11
node v20.1.0
tsc 4.9.3
npm 8.4.1
```","[('mitschabaude', ""Hi @directcuteo, thanks for the report! I can't reproduce the bug, but I'm on Linux. I wonder if it's a bug with node 20 on windows.\r\n* Do you experience the same on node 19?\r\n* Can you share the code of a minimal `main.ts` which reproduces the problem?""), ('directcuteo', ""Yes, I installed node v19 and I encounter the same error.\r\n\r\nThis is the entire code (I've put everything in one file). `tsc` command runs fine\r\n\r\n```\r\nimport { AccountUpdate, Field, isReady, method, Mina, PrivateKey, shutdown, SmartContract, state, State } from 'snarkyjs';\r\n\r\nexport class Square extends SmartContract {\r\n  @state(Field) num = State<Field>();\r\n\r\n  init() {\r\n    super.init();\r\n    this.num.set(Field(3));\r\n  }\r\n\r\n  @method update(square: Field) {\r\n    const currentState = this.num.get();\r\n    this.num.assertEquals(currentState);\r\n    square.assertEquals(currentState.mul(currentState));\r\n    this.num.set(square);\r\n  }\r\n}\r\n\r\nawait isReady;\r\nconsole.log('SnarkyJS loaded');\r\nconst useProof = false;\r\nconst Local = Mina.LocalBlockchain({ proofsEnabled: useProof });\r\nMina.setActiveInstance(Local);\r\nconst { privateKey: deployerKey, publicKey: deployerAccount } = Local.testAccounts[0];\r\nconst { privateKey: senderKey, publicKey: senderAccount } = Local.testAccounts[1];\r\n\r\nconst zkAppPrivateKey = PrivateKey.random();\r\nconst zkAppAddress = zkAppPrivateKey.toPublicKey();\r\n\r\nconst zkAppInstance = new Square(zkAppAddress);\r\nconst deployTxn = await Mina.transaction(deployerAccount, () => {\r\n  AccountUpdate.fundNewAccount(deployerAccount);\r\n  zkAppInstance.deploy();\r\n});\r\nawait deployTxn.sign([deployerKey, zkAppPrivateKey]).send();\r\n\r\n\r\n// get the initial state of Square after deployment\r\nconst num0 = zkAppInstance.num.get();\r\nconsole.log('state after init:', num0.toString());\r\n\r\n// ----------------------------------------------------\r\nconst txn1 = await Mina.transaction(senderAccount, () => {\r\n  zkAppInstance.update(Field(9));\r\n});\r\nawait txn1.prove();\r\nawait txn1.sign([senderKey]).send();\r\n\r\nconst num1 = zkAppInstance.num.get();\r\nconsole.log('state after txn1:', num1.toString());\r\n// ----------------------------------------------------\r\n\r\nconsole.log('Shutting down');\r\nawait shutdown();\r\n\r\n```\r\n\r\nThe error is gone if I comment the line `await txn1.prove();`\r\nThank you for helping!""), ('directcuteo', '@mitschabaude  I hope there is enough information so you can investigate this issue. I am waiting for your response. Thank you!'), ('mitschabaude', ""Thanks @directcuteo, I'll find someone on the team with Windows so we can investigate this "")]"
895,Conditional `UInt64` subtraction bug,Isaac-DeFrain,closed,"This took me so long to pin down!
There seems to be a bug when evaluating conditional `UInt64` subtraction in SnarkyJS 0.9.8.

*Occurrences*
Ordinary conditional (throws an error when condition is false)
![image](https://user-images.githubusercontent.com/42081488/236709897-0ccb54df-8380-4612-9a22-9fbe14b54d9e.png)

`Circuit` conditional (throws errors in both cases)
![image](https://user-images.githubusercontent.com/42081488/236709887-03f04073-2af1-4da8-b3b2-6af350bf6d22.png)

![image](https://user-images.githubusercontent.com/42081488/236709842-500523d5-23cc-45e4-a39b-3e4023685531.png)

Converting the condition `toBoolean()` fixes the ordinary conditional
![image](https://user-images.githubusercontent.com/42081488/236710362-49647b84-631d-4af0-b9e1-64bc767e936a.png)
but *not* the `Circuit` conditional","[('Isaac-DeFrain', ""I realized that I wasn't using the latest version of `node` in those screenshots. I have confirmed these errors still occur with the latest `node v20.1.0`.""), ('mitschabaude', ""Thanks for reporting @Isaac-DeFrain! This isn't a bug. `UInt64.sub()` asserts that the result doesn't underflow zero, and throws when it does. Since Circuit.if is a normal function call, the else case is evaluated, there's no way around that.\r\n\r\nSo, a safe subtraction of the smaller value from the larger one needs to be implemented differently. For example, you could first determine the min and max with 2 Circuit.ifs, and then do max.sub(min).\r\n\r\nWhat this definitely highlights is that we should improve the error message!""), ('Isaac-DeFrain', ""If there's a way to report the line in the smart contract method where the error occurs, that would be like a 10x improvement! When running tests with jest, you only get the line in the test where the error occurs."")]"
891,Max `UInt64` returns an error,Isaac-DeFrain,closed,"Multiple ways to get the max value for `UInt64`s return an error.
1. `UInt64.MAXINT()`
![Screenshot 2023-05-04 204211](https://user-images.githubusercontent.com/42081488/236365048-c3411b7a-da12-4cbc-86df-a1d4a101a845.png)
2. `UInt64.from(18_446_744_073_709_551_615)`
![Screenshot 2023-05-04 203852](https://user-images.githubusercontent.com/42081488/236365183-28954509-5945-4d5c-af4e-229f93ddb6e7.png)

","[('mitschabaude', ""I can't reproduce the error with `UInt64.MAXINT()`:\r\n\r\n![image](https://user-images.githubusercontent.com/20989968/236386037-9de1f373-ad1f-4485-b545-dc592b28bd53.png)\r\n\r\nThe second error I can explain: the JS `number` type can't represent 2^64-1 exactly as an integer -- as you see, it gets rounded up, which makes it too large for a UInt64. The solution is to use `bigint` for large numbers:\r\n\r\n![image](https://user-images.githubusercontent.com/20989968/236386473-f0e6fa1c-a03a-469d-a1ba-70be81e9d3de.png)\r\n""), ('Isaac-DeFrain', ""1. Yeah I have no idea... Now I can't even reproduce the error. It's for the best!\r\n2. That makes sense."")]"
881,UInt constructors are not typed,Isaac-DeFrain,open,"The following
```typescript
describe('Compare', () => {
  it('UInt32s', async () => {
    let x = new UInt32(0);
    x.assertEquals(x);
  });

  it('UInt64s', async () => {
    let x = new UInt64(0);
    x.assertEquals(x);
  });
});
```
both throw the error `Type ""number"" cannot be used with function ""toFields""`.

The following
```typescript
describe('Compare', () => {
  it('Int64s', async () => {
    let x = new Int64(new UInt64(0));
    x.assertEquals(x);
  });
});
```
throws the error `TypeError: this.magnitude.value.mul is not a function`.

My deets:
```
System:
  OS: Linux 4.19 Debian GNU/Linux 10 (buster) 10 (buster)
  CPU: (8) x64 AMD EPYC Processor
Binaries:
  Node: 18.4.0 - ~/.nvm/versions/node/v18.4.0/bin/node
  Yarn: 1.22.19 - ~/.nvm/versions/node/v18.4.0/bin/yarn
  npm: 9.6.5 - ~/.nvm/versions/node/v18.4.0/bin/npm
npmPackages:
  snarkyjs: 0.9.8
npmGlobalPackages:
  zkapp-cli: 0.7.5
```","[('Trivo25', 'Can you try `UInt32.from(0)` instead of `new UInt32(0)`? '), ('Isaac-DeFrain', 'Works as expected'), ('Isaac-DeFrain', 'Are those errors expected when using `new UInt32(0)`?'), ('mitschabaude', ""The problem here is that the constructor is not typed, and also doesn't validate its inputs at runtime..\r\n`new UInt32(Field(0))` is how it's supposed to be used""), ('mitschabaude', 'We should fix it asap by putting types on it')]"
880,Smart contract compilation fails after several successful attempts,shimkiv,open,"#### Notes:

- Issue happens for **any** runtime (server, browser);
- SnarkyJS version in use: **0.9.8**;
- Smart contract in use: [E2eZkApp](https://github.com/o1-labs/e2e-zkapp/blob/develop/e2e-zkapp-sc/src/E2eZkApp.ts);
- Compilation operation in use: [example](https://github.com/o1-labs/e2e-zkapp/blob/47641513b6a5b0e6ca6112f1e266b2d9f0a52ceb/e2e-zkapp-ui/utils/ZkAppUtils.ts#L111);
- Hardware in use: **Intel(R) Core(TM) i9-9980HK CPU @ 2.40GHz 32.00GB RAM**;
- `zkApp` operation after this issue is unstable and can cause other issues.

#### Steps:

1. Initialize `SnarkyJS` (load zkApp server or browser version).
2. Issue the smart contract compilation several times in a row within the same global context.
  2.1. `4 sequential operations` execution on specified hardware (if it matters).

#### Expected results:

- No issues happen.

#### Actual results:

- Smart contract compilation fails on 4th attempt and exact issue thrown differs depending on some state the zkApp is in (like if the compilation is called within other application methods, [deploy example](https://github.com/o1-labs/e2e-zkapp/blob/47641513b6a5b0e6ca6112f1e266b2d9f0a52ceb/e2e-zkapp-ui/utils/ZkAppUtils.ts#L61), [account state update example](https://github.com/o1-labs/e2e-zkapp/blob/47641513b6a5b0e6ca6112f1e266b2d9f0a52ceb/e2e-zkapp-ui/utils/ZkAppUtils.ts#L199)) but always is thrown during the Smart contract compilation method invocation.

```shell
(3) [0, Array(3), Error: null pointer passed to rust
    at imports.wbg.__wbindgen_throw (http://localhost:9042/javas…]

---

Deploying zkApp for E2E testing...
panicked at 'capacity overflow', /Users/shymkiv/.rustup/toolchains/nightly-2022-09-12-x86_64-apple-darwin/lib/rustlib/src/rust/library/alloc/src/raw_vec.rs:518:5
Stack:
Error
    at module.exports.__wbg_new_abda76e883ba8a5f (/Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/plonk_wasm.cjs:7539:17)

---

Updating zkApp State from ""144"" to ""20736""...
Something went wrong. [
  0,
  [ 248, MlBytes { t: 0, c: 'Jsoo_runtime.Error.Exn', l: 22 }, 238 ],
  RangeError: offset is out of bounds
      at Uint8Array.set (<anonymous>)

---

Deploying zkApp for E2E testing...
panicked at 'caml_bigint_256_of_decimal_string', src/arkworks/bigint_256.rs:72:17
Stack:
Error
    at module.exports.__wbg_new_abda76e883ba8a5f (/Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/plonk_wasm.cjs:7539:17)
    at console_error_panic_hook::hook::h70346a39261188fe (wasm://wasm/0100b0ae:wasm-function[2046]:0x2fbf1e)

---

panicked at 'called `Result::unwrap()` on an `Err` value: Custom { kind: Other, error: ""FromBytes::read failed"" }', src/arkworks/pasta_fp.rs:59:21
Stack:
Error
    at module.exports.__wbg_new_abda76e883ba8a5f (/Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/plonk_wasm.cjs:7539:17)
```

![image](https://user-images.githubusercontent.com/4096154/235313120-c11fedd8-c2ec-40f5-8e1b-ae59a204ef64.png)

---

[Internal discussion](https://o1-labs.slack.com/archives/C028Q27R8UC/p1682336420164539) with more logs.",[]
877,"docs use consistent spelling of product names, esp. SNARK workers",barriebyron,closed,"Docs build trust when we are consistent and accurate.
For example, `SNARK workers` have various spellings throughout the docs

Make updates throughout docs to follow the https://github.com/o1-labs/docs2/wiki/Word-list to update the docs so we use consistent terminology ","[('mitschabaude', 'can we move this issue to the docs repo?'), ('barriebyron', '> \r\n\r\nyes of course, is this move something I have the power to learn and do?'), ('mitschabaude', ""> > \r\n> \r\n> yes of course, is this move something I have the power to learn and do?\r\n\r\nI think there's no way to do it except recreate it in the other repo!""), ('barriebyron', 'I inadvertently created this docs PR in the codebase repository, closing here'), ('mitschabaude', 'Fun fact: since I wrote the comment above I learned that GitHub allows you to transfer issues! It\'s a small link on the side/bottom, ""Transfer issue""')]"
870,Investigate whether we can reduce reliance on global state,mitschabaude,open,"**Why:** reliance on global state is bad for many reasons. Two pain points are:
1. snarkyjs stops working if imported twice (e.g., not used as a peer dependency but direct dep by some library), because the two global states don't know of each other.
1. snarkyjs is likely to break when used in an async mode. example: Node.js server which runs snarkyjs and serves incoming requests in an async way

**Thoughts on how to solve:**

We heavily rely on global state for multiple different purposes:
* `snarky-ml` internal state (i.e., the circuit that is being built / witnesses that were computed)
* knowing in which ""circuit mode"" we are (duplicated in JS since snarky-ml used to not manage this reliably; should be unified)
* knowing in which smart contract method we are
* knowing in which transaction mode we are

there are two big topics here: snarky-ml state and smart contract state

making snarky-ml's internal state not global could potentially be solved by passing along the internal state with variables, and introducing it explicitly in a few APIs like `exists` / `Provable.witness`

getting rid of smart contract state would imply changing the API and passing in state objects in a few places explicitly. for example, a `SmartContract` instance could be tied to a specific transaction state, so you would need to reinstantiate it inside `Mina.transaction`

both of those topics have to be researched before coming up with definite implementation plans!","[('L-as', 'Is there a sister issue in the snarky repo?'), ('mitschabaude', '> Is there a sister issue in the snarky repo?\r\n\r\nNope')]"
869,Move 'Field' class to JS,nicc,closed,,[]
868,What's New in SnarkyJS: May 2023 blog post,barriebyron,closed,,"[('barriebyron', ""May 2023 blog post will primarily focus on memory benefits\nCharlie has image assets, @jasongitmail can select and add to the working Google Doc [May 2023: What's New in SnarkyJS](https://docs.google.com/document/d/1rKjXzrYlsTqMQY_N5-peZjwUbc-6kKmN7JGSL67va0I/edit?usp=sharing)\n\nCan we get numbers around performance improvements?\n3 GB to 300 MB numbers from @mitschabaude \n\n\n""), ('barriebyron', 'Issue that tracks the work to document memory improvements on Notion, see https://app.zenhub.com/workspaces/zkapps-product-eng-6130fedb3b0fc600123d8796/issues/zh/22 '), ('barriebyron', ""Our working Google Doc is [May 2023: What's New in SnarkyJS](https://docs.google.com/document/d/1rKjXzrYlsTqMQY_N5-peZjwUbc-6kKmN7JGSL67va0I/edit)""), ('mitschabaude', 'done!')]"
867,Filter noise out of stack traces coming from OCaml,mitschabaude,closed,,[]
865,Tutorial 1 expected assert_equal output is incorrectly output as hexadecimal,barriebyron,closed,"Run [Tutorial 1](https://docs.minaprotocol.com/zkapps/tutorials/hello-world#write-the-zkapp-smart-contract) 

on Mina zkApp CLI 0.6.4 and SnarkyJS 0.8.0.

For this step:

> Now let's try adding a transaction that should fail - updating the state to 75. Now that num is in state 9, updating should only be possible with 81.

The expected output at this part of the tutorial for running:
`npm run build && node build/src/main.js`
is
```
SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 75 != 81
state after txn2: 9
Shutting down
```

But... surprise! when I run the command, the output incorrectly includes hexadecimal values:

```
➜  01-hello-world git:(main) ✗ npm run build && node build/src/main.js

> 01-hello-world@0.1.0 build
> tsc

SnarkyJS loaded
state after init: 3
state after txn1: 9
Shutting down
➜  01-hello-world git:(main) ✗ npm run build && node build/src/main.js

> 01-hello-world@0.1.0 build
> tsc

SnarkyJS loaded
state after init: 3
state after txn1: 9
assert_equal: 0x000000000000000000000000000000000000000000000000000000000000004B != 0x0000000000000000000000000000000000000000000000000000000000000051
state after txn2: 9
Shutting down
➜  01-hello-world git:(main)
```","[('mitschabaude', 'heads up: [this PR](https://github.com/o1-labs/snarkyjs/pull/902) will change the output to\n```\nField.assertEquals(): 75 != 81\n```\ndo you agree that output is better @barriebyron?')]"
864,Add a delay to `Mina.faucet` for reliability,MartinMinkov,open,"# Description
When using `Mina.faucet` to fund multiple accounts consecutively, it can easily lead to overloading the faucet server and cause errors, resulting in failed fund requests.

Although the exact cause of this issue hasn't been thoroughly investigated, it seems that making multiple requests simultaneously contributes to the problem. The following code, for instance, exhibits inconsistent behaviour:

```ts
await Promise.all([Mina.faucet(address1), Mina.faucet(address2), ...]);
```
As a temporary solution, I've introduced a 1.5-second delay to each execution of `Mina.faucet`, which has significantly improved the function's reliability. The duration of the delay can be adjusted as needed to further enhance reliability.

While it's possible to address the issue by investigating and fixing the errors in the faucet server itself, implementing this delay provides a simpler and more immediate solution.",[]
862,Mina `transaction` and `fundNewAccount` deprecation of private key arg,Isaac-DeFrain,closed,"The [deprecated private key arg](https://github.com/o1-labs/snarkyjs/issues/635) of these methods is reflected in the VSCode UI but not in zkapp-cli 0.7.5. You can confirm with any of the tests in [this code](https://github.com/garethtdavies/zkAppPool/blob/main/oracle/src/DelegationOracleVerifier.test.ts).
Reading the 635 issue, it seems like this will be supported in 0.8.0.","[('mitschabaude', ""Hey @Isaac-DeFrain! I don't quite understand what behavior you find missing. Do you mean the zkapp-cli should warn about deprecated arguments in its console output?""), ('Isaac-DeFrain', 'Sorry and thanks for the quick reply @mitschabaude! The VSCode UI informs a dev that passing `PrivateKey`s to these methods is deprecated. However, when you make that change in your code, all the corresponding tests fail.'), ('mitschabaude', 'Gotcha. The public key fee payer argument should work, what was the error you got? Something about missing private key? You have to pass the private key to tx.sign() '), ('Isaac-DeFrain', ""You're right! It works perfectly, just didn't realize that I need to pass both the zkapp and deployer private keys, but that did the trick. Thanks! "")]"
860,Actions cache behaves incorrectly upon the first circuit method invocation,shimkiv,open,"Suppose we have a SC method which calls `this.reducer.getActions`. 
First invocation of such a circuit method will take whatever actions are currently in the cache and it might not represent the current state of things.

Considering the following set of transactions:

1. Deployment + 1 action dispatching
2. More actions dispatching
3. Reduction call (sum of actions field values)
4. More actions dispatching
5. Reduction call (sum of actions field values)
6. More actions dispatching
7. Reduction call (sum of actions field values)
8. ...

First Txn `#3` invocation will ""fetch"" empty actions list.
First Txn `#5` invocation will ""fetch"" actions list from updated cache after Txn `#3` processing (which will be contain wrong list values).
And so on.

---

Internal discussion can be found [here](https://o1-labs.slack.com/archives/C028Q27R8UC/p1681455704304299?thread_ts=1681416539.784809&cid=C028Q27R8UC).

---

<img width=""968"" alt=""SCR-20230414-ondq"" src=""https://user-images.githubusercontent.com/4096154/232057101-aa620733-000e-4fc7-901b-dc635e7a7b69.png"">
<img width=""724"" alt=""SCR-20230414-ohpj"" src=""https://user-images.githubusercontent.com/4096154/232057126-4d8741dd-901e-4c68-858d-5dbe962b1b0a.png"">
",[]
859,fetchEvents returns events in different order than local blockchain,mitschabaude,open,"Reported by @mitschabaude 

@MartinMinkov I assume this is just because we don't do `fetchedEvents.reverse()` inside `fetchEvents()`, as we do for actions?","[('MartinMinkov', 'Yup, a `.reverse()` inside `fetchEvents()` would fix this! Although, I would question whether fetching events in the order they happened is the most common use case. Is there a case for changing LocalBlockchain to return the latest events instead? I can image use cases like a UI listening for events; you would probably be most interested in the latest events dispatched rather than fetching events and looking at the end for the ones you want. WDYT?'), ('mitschabaude', 'Good point @MartinMinkov!')]"
858,Field.greaterThan not working outside circuit,mitschabaude,closed,"reproduction:

```ts
await isReady;
let x = Field(1).greaterThan(0);
```

throws:

```
Error: This function can't be run outside of a checked computation.
```

from here:
https://github.com/o1-labs/snarky/blob/045d11106d1dcb217c249784dc694d05931f30a8/src/base/snark0.ml#L745-L747

The same issue can sometimes lead to different issues because snarky internal states aren't properly cleaned up, so that it thinks it _is_ in a checked computation, but will return a witness outside the circuit.

Which is actually another bug!","[('mitschabaude', 'Reproduction of different issue caused by not cleaning up ""is running"":\r\n\r\n```ts\r\nimport { Field, isReady, Experimental, Struct } from \'snarkyjs\';\r\n\r\nawait isReady;\r\n\r\nlet DummyProgram = Experimental.ZkProgram({\r\n  publicInput: Struct({}),\r\n  methods: {\r\n    emptyMethod: {\r\n      privateInputs: [],\r\n      method(publicInput: {}) {},\r\n    },\r\n  },\r\n});\r\n\r\nawait DummyProgram.compile();\r\n\r\n// now snarky thinks it\'s ""running""\r\n\r\nlet x = Field(1).greaterThan(0);\r\n\r\nconsole.log(x);\r\n```\r\n\r\nThis version doesn\'t throw, which implies that `compile()` leaves the internal state `Run_state.is_running !state = true`\r\n\r\nthe log shows that `x` is a witness even though this is not supposed be circuit code:\r\n\r\n```\r\n{ value: [ 2, [ 0, [Uint8Array] ], [ 3, [Uint8Array], [Array] ] ] }\r\n```\r\n\r\n')]"
853,Can we pass arguments to a callback?,mitschabaude,open,https://discord.com/channels/484437221055922177/1095438002848792606/1095438002848792606,[]
852,`fetchActions` returns one action too many,mitschabaude,closed,See https://github.com/o1-labs/snarkyjs/pull/844#issuecomment-1503411842,"[('dexterslabor', 'I am affected by this issue for e2e testing and this is a temporary workaround.\r\n\r\n```typescript\r\n  public rollup() {\r\n    const actionsHash = this.actionsHash.get();\r\n    this.actionsHash.assertEquals(actionsHash);\r\n\r\n    let pendingActions = this.reducer.getActions({\r\n      fromActionState: actionsHash,\r\n    });\r\n\r\n    // this is a temporary workaround for https://github.com/o1-labs/snarkyjs/issues/852\r\n    Circuit.asProver(() => {\r\n      // eslint-disable-next-line snarkyjs/no-if-in-circuit\r\n      if (!actionsHash.equals(Reducer.initialActionsHash).toBoolean()) {\r\n        pendingActions = pendingActions.slice(1);\r\n      }\r\n    });\r\n    ...\r\n```\r\nNote: This workaround needs to be removed for testing with local blockchain.\r\n\r\nThank you for your support @mitschabaude '), ('nicc', 'IRI: @mitschabaude / @MartinMinkov ')]"
850,Implement fallback URLs,mitschabaude,closed,RFC: https://github.com/o1-labs/snarkyjs/issues/781,"[('nicc', 'IRI: @ymekuria / @MartinMinkov ')]"
849,Create list of high-value error messages to improve,nicc,closed,"We are intent on improving our error messages in general. There are some initivates that unblock this. In preparation for these improvement, we'd like a list of the most impactful error messages to focus on first.

Consider all errors (protocol, crypto, snarkyjs). Timeboxed to an estimate of 5. No more than 20 items.

Preemptive candidates:
- Out of memory
- Circuit size

Resources for when we are ready to improve the error messages:
- https://www.nngroup.com/articles/error-message-guidelines
- https://uxplanet.org/how-to-write-good-error-messages-858e4551cd4
- https://bootcamp.uxdesign.cc/7-steps-to-design-error-messages-49e509f03d18
","[('barriebyron', '@ymekuria  shared https://github.com/MinaProtocol/docs/blob/main/pages/en/node-operators/transaction-failures.mdx that has been floating around, not published in the docs as of April 11, 2023'), ('nicc', ""Another candidate:\n\n`Account_action_state_precondition_unsatisfied` error during `Reducer.reduce` usually when you reduce the wrong set of actions (because you hash the wrong actions and the target hash doesn't match the committed on-chain hash anymore) ""), ('nicc', 'IRI: @nicc'), ('mitschabaude', 'Here\'s a truly bad one: https://github.com/o1-labs/snarkyjs/issues/808\r\nIf you forget to add `tx.prove()` when doing a zkApp call, the error is just:\r\n```\r\nAssert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1266:17\r\n```\r\n\r\nThis is because the `authorizationKind` is implicitly set to ""proof"" but then the actual authorization doesn\'t match that (missing proof).\r\n(thrown from inside the transaction logic, called by LocalBlockchain)'), ('mitschabaude', ""Basically, every error thrown from inside snarky is bad, because of the **long and noisy stack trace**. @mrmr1993 had some good ideas to address this.\r\n\r\nHere's an example (cut off) for when a constraint fails inside the prover (for example, during `tx.prove()`):\r\n\r\n![image](https://user-images.githubusercontent.com/20989968/231503585-95f25e03-78af-4b4d-b6c0-dce33c7e9a11.png)\r\n\r\n\r\n[constraint-unsatisfied.txt](https://github.com/o1-labs/snarkyjs/files/11212973/constraint-unsatisfied.txt)\r\n\r\n""), ('Kirol54', 'I\'m assuming it\'s coming from graphql but it\'s not a really helpful error message regardless\r\n\r\n<img width=""767"" alt=""image"" src=""https://user-images.githubusercontent.com/36684975/231592134-06c188e3-338a-4894-a461-5b309da8c776.png"">\r\n'), ('rpanic', ""I guess `Can't evaluate prover code outside an as_prover block` can be improved""), ('mitschabaude', ""'Permutation failed' for when you create a different circuit every time because you use a constant instead of a variable""), ('nicc', '@nicc to review / create new issues'), ('shimkiv', 'Another messages for consideration:\n\n- https://github.com/o1-labs/e2e-tests/issues/56\n- https://github.com/o1-labs/snarkyjs/issues/425\n- https://github.com/o1-labs/snarkyjs/issues/478\n- https://github.com/o1-labs/snarkyjs/issues/601\n- https://github.com/o1-labs/snarkyjs/issues/743\n- https://github.com/o1-labs/snarkyjs/issues/782\n- https://github.com/o1-labs/snarkyjs/issues/841\n\ncc @nicc '), ('nicc', 'All improvements identified here have been reflected as new issues with the `error-messages` label. Closing this issue. Thank you, everyone!')]"
848,Deploy DEX sample zkApp to Berkeley,nicc,closed,"This serves to test the live network. Depends on issue #847.

Are we within account update limits? Any other constraints?

Once deployed, we should run the app to exercize the Archive Node API on Berkeley.","[('nicc', 'IRI: @Trivo25 / @MartinMinkov ')]"
847,Update DEX zkApp to use events and actions,nicc,closed,"In order to serve as a test case for the Archive Node API, we want it to emit both actions and events.

Question: are we retrieving actions and events from within an app on Berkeley? Should we add this?","[('nicc', 'IRI: @Trivo25 / @MartinMinkov ')]"
842,bump actions limit,Trivo25,closed,bump actions limit once https://github.com/MinaProtocol/mina/pull/12981 hits,"[('MartinMinkov', 'It has been hit! :D '), ('nicc', ""@shimkiv let's include a high action limit test"")]"
841,Swallowed errors during comms with Archive-Node-API,shimkiv,closed,"During the [events](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L688) and [actions](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L755) fetching we rely on `error` variable to be defined by problematic response when in fact `errors` an array of errors is usually returned by GraphQL, example:
```graphql
{
  ""errors"": [
    {
        ""locations"": [
            {
                ""column"": 3,
                ""line"": 13
            }
        ],
        ""message"": ""Field \""actionState\"" of type \""ActionStates!\"" must have a selection of subfields. Did you mean \""actionState { ... }\""?""
    }
  ]
}
``` 
Thus, check like [this](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L696) or [this](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L763) won't result in error being thrown.
But then, the call execution will be interrupted by [this](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L697) or [this](https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L764) lines when we're going to refer to `undefined`.",[]
839,[Feature Request] Expose `fetchActions` publicly in SnarkyJS exports,MartinMinkov,closed,"# Description

To get actions from the network, a zkApp developer users `getActions` inside their smart contract. `getActions` calls `fetchActions` internally, which does the actual network call. A zkApp developer requested that we expose `fetchActions` so they can fetch actions without it being done inside a smart contract. This functionality would behave very similarly to `fetchEvents`.

When implementing this, make sure to add the `to` and `from` filter parameters since they were not used in `getActions` so they were not implemented.

Fetch Actions Implementation: https://github.com/o1-labs/snarkyjs/blob/33a99467c7795640bfb16dcc2452e3f8108cae15/src/lib/fetch.ts#L742","[('mitschabaude', 'Done thanks to @Comdex!')]"
837,Remove Client-SDK CI job from Mina repo,MartinMinkov,open,"# Description

We have a CI in the [Mina repo](https://github.com/MinaProtocol/mina/blob/develop/buildkite/src/Jobs/Release/ClientSdk.dhall) that handles publishing the ClientSDK to npm. This refers to the old ClientSDK and should be removed, as we now hold releases of MinaSigner in the SnarkyJS repo.

I'm making the issue here so that it's on the product board and will get visibility :sweat_smile: ",[]
832,Use `provedState` in `init()` to assert it runs only once,mitschabaude,closed,,"[('mitschabaude', 'done https://github.com/o1-labs/snarkyjs/pull/908')]"
830,Upgrade JS of OCaml,mitschabaude,open,Why: Would enable us to reap continuous improvements that go into JSOO,[]
827,Add analyzeMethods() to ZkProgram,maht0rz,closed,"Since i began using ZkProgram i have been trying to be cautious about not going over the 2^16 circuit size limit. The only way i knew how to figure out my circuit size, was to use `SmartContract.analyzeMethods()`. I could not find the same for ZkProgram, so i've decided to follow how it is done for SmartContract.


For my own purposes, i've tried adding the following to the [`ZkProgram`](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/proof_system.ts#L270):

```typescript
function analyzeMethods() {
  return methodIntfs.map((methodEntry, i) =>
    analyzeMethod(publicInputType, methodEntry, methodFunctions[i])
  );
}

return Object.assign(
  selfTag,
  { compile, verify, digest, publicInputType, analyzeMethods },
  provers
);
```

^ the code above might not be 100% correct, but when i injected something along these lines into my built snarkyjs dependency, i was able to inspect the amount of 'rows' in my ZkProgram.

Does this approach make sense? If yes, i can open a PR.","[('mitschabaude', 'Yes this makes sense and a PR would be highly appreciated!'), ('mitschabaude', 'done with the linked PR')]"
824,RFC: Transaction Flow (parity of behavior between localBlockchain and Testnet),rpanic,open,"### Motivation & Current State

The sending of Transactions and subsequent status retrieval is inconsistent between local and remote implementations and additionally re-uses the TransactionId and re-uses properties for different functionality.
As an example, in remote networks, `TransactionId.isSuccess` is used for both the indication that the sending of the transaction has succeeded and does not work correctly after calling `.wait()`. See [#819](https://github.com/o1-labs/snarkyjs/issues/819)
In comparison, LocalBlockchain throws at `.send()` if the transaction cannot be applied to the ledger, and does not implement .wait().

Altough the interface for these implementation is the same, the behaviour is completely different and leads to worse developer experience and extra effort to check for those things in scripts. 

### Proposed changes

I propose an extension to the current API which aligns both implementations and seperates concerns into different classes.

```
Transaction.send() : Promise<TransactionId>
```
Where TransactionId uniformly implements properties as:
  - `isSuccess`: The Transaction is well-formed and passes initial checks by the node (I think the mina node primarily checks some nonce preconditions and the fee payer)
  - `errors`: Error[] that occurred
  - `hash()`: Returns the hash of the txid
  - `wait()`: Waits for the tx to be mined (details below)
  

```
TransactionId.wait() : Promise<IncludedTransaction>
```
The first implementation spec only needs an default mina node
 - `isIncluded`: The tx got included in a block (is only false if errors occurred)
 - `errors`: Error[] that occurred

The second possibility would extend the above and involve the new archive-node api:
 - `getInfo() : Promise<IncludedTransactionInfo>`: Retrieves information about the mined transaction from an archive node.
 IncludedTransactionInfo would include inclusion-time errors, block info. This method would throw if no archive node url has been specified for remote networks. 
This should be an extra method in order to allow operation without an archive-node api, as is the current interface for remote networks. 
 
Reliably usage would depend on [Archive-Node-API#69](https://github.com/o1-labs/Archive-Node-API/issues/69) being implemented. 


### Things I am not sure about

hash() is currently taken from the graphql response. I don't know why but it seems that this should be possible to do in snarkyjs
","[('mitschabaude', ""Thanks for the proposal @rpanic! I like it a lot:\r\n\r\n* Making the two interfaces consistent will solve a huge pain point for users\r\n* The additional info returned on `IncludedTransaction` is an important addition that enables applications to show the full transaction lifecycle to their users, from being sent to being successfully included, and to debug any errors that may happen in that lifecycle. \r\n\r\nI have a few comments:\r\n\r\n**Errors**\r\n\r\nThe change from `Transaction.send()` throwing an error on `LocalBlockchain` to not throwing an error breaks most existing SnarkyJS tests. Also, in circumstances like tests, letting it throw an error can be more ergonomic than having to inspect the returned `errors` array. Throwing an error makes it easier for us to give helpful feedback to the user, such as the message shown when [encountering the `Invalid_fee_excess` error](https://github.com/o1-labs/snarkyjs/blob/adea00085d1339154510404c83fc75b9d492aec4/src/lib/errors.ts#L22-L47).\r\n\r\nTherefore, I propose to add an alternative method which retains the old behavior (of throwing an error), and implement this method on both `LocalBlockchain` and `Network`. It would be a wrapper around `Transaction.send()` which inspects the errors array and possibly throws an error. Not sure how to call it, maybe\r\n* `Transaction.sendException()`?\r\n* `Transaction.sendOrThrow()`?\r\n\r\n**`TransactionId.wait()`**\r\n\r\nMinor comment: Let's rename `TransactionId` to something clearer, like `PendingTransaction`.\r\n\r\nIt's unclear to me how `.wait()` is supposed to work on local blockchain. I would advocate to keep it simple and make `.wait()` return immediately and not do something fancy like simulating blocks.\r\n\r\nOne question/thought: There may be a difference in what errors the Mina node returns from GraphQL (subset of errors that can occur in the transaction logic, but some additional checks done before entering the transaction pool) vs what the local blockchain returns from `.send()` (all possible errors that can occur in the transaction logic, but may miss some other checks). How important is it that these are consistent? Some errors that the local blockchain throws on `send()` may only show up on the Network after `wait()`. We would have to work a bit on `LocalBlockchain` to make it more similar to the real network in that respect.\r\n\r\n> hash() is currently taken from the graphql response. I don't know why but it seems that this should be possible to do in snarkyjs\r\n\r\nYes, we can implement `hash()` in SnarkyJS. It's already part of mina-signer which shares a lot of code with SnarkyJS.""), ('rpanic', ""Thanks for your comments!\r\n\r\nI like the idea of adding a method that would throw if errors occurred. I would go with `Transaction.sendOrThrow()` or even `Transaction.sendThrowing()`, sendException seems a bit misleading to me.\r\n\r\n>`TransactionId.wait()`\r\n\r\nRenaming makes a lot of sense!\r\nI agree, `.wait()` should return resolve immediately, but I think we can remove the warning it outputs at the moment. \r\nIn the medium-term simulating blocks and keeping track of network-states (especially things that we can use in preconditions) would be great for testing to get as close as possible to real conditions, but that is out of scope for this one I think. \r\n\r\n>There may be a difference in what errors the Mina node returns from GraphQL ....\r\n\r\nI think that ideally we can also make both implementations consistent, but that kind of comes in tandem with the simulation argument above. It makes no sense to check for things that we don't keep track of in the localblockchain. \r\n\r\nI think even if there is some discrepancy of errors returned on `.send()` vs. `.wait()` the additional effort required to test on both networks is dramatically reduced through these changes. ""), ('jasongitmail', '@Trivo25 could you take a look at this too please? Important enough to have a couple reviewers. After your conference.'), ('Trivo25', 'No further comments to add. I think it would be great to get the tx e2e flow for both the LocalBlockchain and the live Network up to sync. Ideally, without simulating blocks on the JS side (imo). '), ('nicc', 'Prioritised. First step is to make choices as peresented by this RFC, copy it over to the RFC repo, and present it to architects and community. The work will follow from there.')]"
823,iOS Safari Compatibility,bkase,closed,"The new iOS Safari release supports nested web worker spawning, and SnarkyJS with Safari on desktop seems to work; however, iOS Safari SnarkyJS does not seem to according to some internal testing by @shimkiv 

Observed behavior is that something is breaking during SnarkyJS load-time, isReady never resolves and nothing prints.

Note that this does work on an iOS simulator.

We believe this is just a matter of working through the errors one by one until it works! It would be a great first issue for a contributor as you'll step through different parts of SnarkyJS trying to dig through errors.","[('barriebyron', ""I thought of this bug when I read the last paragraph in \r\nhttps://book.leadthe.dev/people/diversity-is-key.html \r\n\r\n> an analysis on the bug my teams had worked on in the past few months. After some crunching, an obvious number stood out. More than 85% of our frontend bugs happened on Windows browsers. I was puzzled at first but then something really obvious hit me. My whole organisation used mac laptops. All our frontend developers used Chrome. We were a monoculture! You know why I use this story all the time? It's because it happened in the team I just mentioned. We thought we were a diverse team. Well, we weren't if we had considered the OS/Browser dimensions!\r\n""), ('shimkiv', 'When it comes to UI we actually doing diverse testing, which includes different desktop operating systems like macOS/Windows/Linux, different mobile OS like iOS/iPadOS/Android, different browsers (Chrome, Firefox, Safari), etc..\r\n\r\nSpeaking of issue itself, an `OOM` might be happening on iOS devices as it was discovered by running project generated by `zkApp-CLI` + JS/TS Framework like `SvelteKit`.'), ('ryancwalsh', ""Hi @bkase ! Could you (or anyone who knows) please add steps to reproduce?\r\n\r\n(and any updates / insights / hypotheses from the past month)\r\n\r\nWhich combos of iOS / Safari have problems? Which don't?\r\n\r\nWhich simulators work, and which don't, and what exactly happens?\r\n\r\nWill anyone be assigned to this issue soon?\r\n\r\nThanks!""), ('mitschabaude', 'I think @shimkiv has found these issues and might be able to help with reproducing?'), ('jdsteinhauser', '@ryancwalsh, I was able to create it the following way, for my test project `wat`:\r\n- Install zkApp CLI (version `0.7.6`)\r\n- Create a new project `zk project wat`\r\n- Created accompanying UI project, using `svelte`\r\n- Created a SvelteKit skeleton project\r\n- Added type checking with TypeScript syntax\r\n- Selected no additional options\r\nAfter creating the project, I modified just the `ui/src/routes/+page.svelte` source file\r\n- Replaced L10 with `alert(""Let\'s try this"");`\r\n- Replaced L12 with `alert(""Hey it worked"");`\r\n- Added Berkeley `Add` zkApp address to L16: `const zkAppAddress = ""B62qkwohsqTBPsvhYE8cPZSpzJMgoKn4i1LQRuBAtVXWpaT4dgH6WoA"";`\r\n- Ran `npm run dev`\r\n\r\nWhen accessing `localhost` with Chrome and Safari (on macOS), both alerts will fire. However, with Safari on an iOS emulator, only the first alert is seen'), ('stevenpack', '@nicc have pushed this up the backlog for next sprint.'), ('shimkiv', ""@jdsteinhauser are you sure that Safari on iOS emulator won't do the same for any simple html+js you mentioned? Like they might prevent consequent alerts spawning by default for instance.\r\n""), ('shimkiv', ""Another interesting finding is that SnarkyJS won't work on WebKit built from sources. It was discovered by using Playwright's webkit installed by `npx playwright install --with-deps` then `~/Library/Caches/ms-playwright` and launch browser with script. It reflects same (most likely) issue as iOS browsers.\r\nIt is interesting because at least we have this issue on something that can be built [from sources](https://playwright.dev/docs/browsers#webkit) and hence, help with debugging.""), ('jdsteinhauser', ""> @jdsteinhauser are you sure that Safari on iOS emulator won't do the same for any simple html+js you mentioned? Like they might prevent consequent alerts spawning by default for instance.\r\n\r\nI haven't tried SnarkyJS alone without a framework in Safari on iOS""), ('shimkiv', '@jasongitmail I actually talking about any simple html + js alerts.'), ('mitschabaude', '> @jasongitmail I actually talking about any simple html + js alerts.\r\n\r\nyou tagged the wrong Jason :P'), ('shimkiv', 'hehehe sorry for that :) \r\n'), ('jdsteinhauser', '@shimkiv Ah, I gotcha now. Sorry for the confusion! Yes, I can get alert modals to show up with plain html/js on an iPhone emulator'), ('MartinMinkov', ""After some exploration, I successfully made a SnarkyJS build operate with Safari on iOS.\r\n\r\nThe critical adjustment involves modifying the requested WebAssembly memory within a particular function, which can be found at this link: https://github.com/o1-labs/snarkyjs-bindings/blob/9948427f992545da1f6919fa5d4445437da751d9/compiled/web_bindings/plonk_wasm.js#LL7746C77-L7746C90\r\n\r\nThrough experimentation, I discovered that the memory error ceases to occur by reducing the `maximum` memory value to a smaller amount, for instance, `16384` (each page is `64KiB`, which equates to 1 GiB of memory). \r\n\r\nHere is an example:\r\n```ts\r\nimports.wbg.memory = maybe_memory || new WebAssembly.Memory({initial:19,maximum:16384,shared:true});\r\n```\r\n\r\nThe **current** memory size is 4 GiB (65536 pages). This seems to be [fine for Chrome](https://v8.dev/blog/4gb-wasm-memory) but for iOS, there might be issues with that size. It's worth noting that doubling the memory to `32768` results in a failure due to memory exhaustion. Perhaps that could be some browser limit set for iOS devices? Trying to find any documentation related to memory usage is difficult, this doesn't seem to be easily accessible information :(\r\n\r\nThe implications of reducing the memory are unclear to me now - it could lead to downstream issues. One possible solution could be to perform a browser check and exclusively reduce memory for iOS agents if there is no issue of lowering memory. \r\n\r\n@mitschabaude, what kind of errors (if any) could occur from lowering the maximum memory requested from 4GiB to 1GiB?\r\n\r\nFinally, the requested memory is used to load the `plonk_wasm.js` file to provide additional context. Another potential solution would be lowering its size, but I'm unsure how feasible that is.""), ('mitschabaude', ""Awesome find @MartinMinkov! The Wasm memory limit should be as large as possible - it's the constraining factor for circuit size. So I'd be in favor of detecting iOS browsers, maybe we can look at 'navigator.userAgent'""), ('mitschabaude', ""@MartinMinkov I think we can create the memory in 'initSnarkyJS()', with limits depending on the user agent, and then pass it to the init() function ourselves""), ('MartinMinkov', ""Another potential issue I considered is that there might also be memory differences between iOS devices.\r\n\r\nI was testing an iPad Pro running iOS version `16.3.1`. I haven't confirmed the memory fix to work on iPhones as well, but I could imagine that smaller devices could have even a lower maximum memory parameter. I'll do some testing with an iPhone to make sure :D ""), ('MartinMinkov', 'I confirmed that 1GiB of memory also works for an iPhone SE running `16.1.1`. :tada: This should be a safe number for mobile iOS devices.\r\n')]"
821,"Provide an interface to specify absolute cliff time as dates, and fix docs",mitschabaude,open,"Time locked accounts currently don't work [as documented](https://docs.minaprotocol.com/zkapps/advanced-snarkyjs/time-locked-accounts), because the docs assume cliff time is set relative to the transaction which sets timing, while in reality it seems to be interpreted as an absolute slot number (of the slot at which the cliff time is over).

We should either fix the docs or (my suggestion) make the interface in snarkyjs treat the cliff time as a relative slot number, because that will be most certainly easier to use.

EDIT: plan changed, see below","[('mitschabaude', 'Instead of the above, we decided to keep the absolute time and provide an interface for converting times / dates into global slots\n\nPlus, we need to change the docs so that the cliff time is absolute! Including the image'), ('barriebyron', '@mitschabaude I opened PR https://github.com/o1-labs/docs2/pull/355 for updates to the the https://docs.minaprotocol.com/zkapps/advanced-snarkyjs/time-locked-accounts page\r\n\r\nI have to learn how to bring in that updated graphic.\r\n\r\nCan you use this PR for your changes? Teach me if there is a better way to work this. Thank yoU!'), ('mitschabaude', '> Can you use this PR for your changes? Teach me if there is a better way to work this. Thank yoU!\r\n\r\nYes that works 👍🏻 ')]"
819,isSuccess always returns true,Trivo25,closed,"fix `isSuccess` to be true only and only if the tx was successful, currently its always true

seems like we arent parsing the graphql response correctly - mid-size annoyance if you are running a live script","[('nicc', 'IRI: @MartinMinkov '), ('MartinMinkov', 'I have been failing to reproduce this issue. I have tried sending invalid transactions on purpose (like invalid nonce, invalid fee amount, invalid verification key), and `isSuccess` is correctly returning false. What counts as ""always"" returning true? :thinking: '), ('mitschabaude', ""@MartinMinkov with which graphql endpoint have you tested? It may work on some but not all. It didn't seem to work on the Mina node that's running inside the snarkyjs integration test for @Trivo25 ""), ('MartinMinkov', 'So far, just `berkeley.minaexplorer`s GraphQL endpoint. I will take a closer look at the integration tests and experiment with different URLs. Thank you!')]"
818,Deploy Error in 0.9.5,rpanic,open,"In 0.9.5 calling deploy with `zkappKey` throws following error
```
This function can't be run outside of a checked computation.

      at failwith (../../../../home/gregor/.opam/4.14.0/lib/ocaml/stdlib.ml:29:34)
      at run (../../../../workspace_root/src/lib/snarky/src/base/snark0.ml:729:13)
      at exists (../../../../workspace_root/src/lib/snarky/src/base/snark0.ml:1203:11)
      at caml_call3 (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7611:28)
      at witness_minimal (../../../../workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:1532:5)
      at caml_call_gen (../../../../builtin/+stdlib.js:32:12)
      at Function.<anonymous> (../../../../builtin/+jslib.js:252:14)
      at Function.Class.<computed> [as _witness] (node_modules/snarkyjs/src/snarky/proxy.js:20:52)
      at node_modules/snarkyjs/src/lib/circuit_value.ts:996:19
      at runWith (node_modules/snarkyjs/src/lib/global-context.ts:89:14)
      at Function.runWith (node_modules/snarkyjs/src/lib/global-context.ts:43:9)
      at Function.Circuit.witness (node_modules/snarkyjs/src/lib/circuit_value.ts:995:22)
      at memoizeWitness (node_modules/snarkyjs/src/lib/circuit_value.ts:1118:18)
      at Function.getSigningInfo (node_modules/snarkyjs/src/lib/account_update.ts:985:12)
      at AccountUpdate.sign (node_modules/snarkyjs/src/lib/account_update.ts:946:53)
      at Lender.deploy (node_modules/snarkyjs/src/lib/zkapp.ts:766:19)
      at Lender.deploy (src/lending/Lender.ts:82:15)
```

The same example works in 0.9.3",[]
816,Add nullifier to mina-signer,nicc,closed,RFC: https://github.com/o1-labs/snarkyjs/issues/756,"[('nicc', 'IRI: @Trivo25 / @ymekuria ')]"
815,Implement fallback url for Archive Node API,nicc,closed,,"[('MartinMinkov', 'Done here :D https://github.com/o1-labs/snarkyjs/pull/871')]"
814,Setting timing fails on local blockchain,mitschabaude,closed,,"[('jasongitmail', ""Closing as duplicate of https://github.com/o1-labs/snarkyjs/issues/821, per Gregor's request\n"")]"
813,Wrong verification key hash when updating the verification key from within a zkApp method,mitschabaude,closed,,[]
811,Better error message for not invoking AccountUpdate.requireSignature(),rpanic,closed,"Currently, if you forget to invoke `requireSignature()` on a AccountUpdate but try to test it on localBlockchain with proofs turned off, you get
``` 
Assert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1266:17
      at raise_error (../../../../home/gregor/.opam/4.14.0/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
      at apply_json_transaction (../../../../workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2933:11)
      at caml_call_gen (../../../../builtin/+stdlib.js:32:12)
      at Object.applyJsonTransaction (../../../../builtin/+jslib.js:289:12)
      at Object.sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:436:16)
      at sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:1021:10)
      at Object.send (node_modules/snarkyjs/src/lib/mina.ts:299:14)
      at Object.<anonymous> (src/lending/Lender.test.ts:427:20)
``` 

This error can lead to a lot of confusion and can be easily replaced by checking that in `sendTransaction` in the localBlockchain implementation","[('mitschabaude', 'duplicate of #808'), ('rpanic', 'The github outage must have duplicated them, sorry :)')]"
810,Better error message for not invoking AccountUpdate.requireSignature(),rpanic,closed,"Currently, if you forget to invoke `requireSignature()` on a AccountUpdate but try to test it on localBlockchain with proofs turned off, you get
``` 
Assert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1266:17
      at raise_error (../../../../home/gregor/.opam/4.14.0/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
      at apply_json_transaction (../../../../workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2933:11)
      at caml_call_gen (../../../../builtin/+stdlib.js:32:12)
      at Object.applyJsonTransaction (../../../../builtin/+jslib.js:289:12)
      at Object.sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:436:16)
      at sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:1021:10)
      at Object.send (node_modules/snarkyjs/src/lib/mina.ts:299:14)
      at Object.<anonymous> (src/lending/Lender.test.ts:427:20)
``` 

This error can lead to a lot of confusion and can be easily replaced by checking that in `sendTransaction` in the localBlockchain implementation","[('mitschabaude', 'duplicate of #808')]"
809,Better error message for not invoking AccountUpdate.requireSignature(),rpanic,closed,"Currently, if you forget to invoke `requireSignature()` on a AccountUpdate but try to test it on localBlockchain with proofs turned off, you get
``` 
Assert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1266:17
      at raise_error (../../../../home/gregor/.opam/4.14.0/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
      at apply_json_transaction (../../../../workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2933:11)
      at caml_call_gen (../../../../builtin/+stdlib.js:32:12)
      at Object.applyJsonTransaction (../../../../builtin/+jslib.js:289:12)
      at Object.sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:436:16)
      at sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:1021:10)
      at Object.send (node_modules/snarkyjs/src/lib/mina.ts:299:14)
      at Object.<anonymous> (src/lending/Lender.test.ts:427:20)
``` 

This error can lead to a lot of confusion and can be easily replaced by checking that in `sendTransaction` in the localBlockchain implementation","[('mitschabaude', 'duplicate of #808 ')]"
808,Better error message for not invoking AccountUpdate.requireSignature(),rpanic,closed,"Currently, if you forget to invoke `requireSignature()` on a AccountUpdate but try to test it on localBlockchain with proofs turned off, you get
``` 
Assert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1266:17
      at raise_error (../../../../home/gregor/.opam/4.14.0/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
      at apply_json_transaction (../../../../workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2933:11)
      at caml_call_gen (../../../../builtin/+stdlib.js:32:12)
      at Object.applyJsonTransaction (../../../../builtin/+jslib.js:289:12)
      at Object.sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:436:16)
      at sendTransaction (node_modules/snarkyjs/src/lib/mina.ts:1021:10)
      at Object.send (node_modules/snarkyjs/src/lib/mina.ts:299:14)
      at Object.<anonymous> (src/lending/Lender.test.ts:427:20)
``` 

This error can lead to a lot of confusion and can be easily replaced by checking that in `sendTransaction` in the localBlockchain implementation","[('Trivo25', ""I couldn't reproduce this error - can you give some more hints, please?""), ('Trivo25', ""Closing because I couldn't reproduce. Everything I tested (with proofs on and off, using the `LocalBlockchain`, mutating fields on the AU or sending funds) resulted in the following error message. Looks like this bug fixed itself :)\r\n```\r\nError: Transaction verification failed: Cannot update field 'xxx' because permission for this field is 'Signature', but the required authorization was not provided or is invalid.\r\n```""), ('Trivo25', '> It\'s a mismatch between authorizationKind and authorization, which results in a failing ""assert"" in the OCaml transaction logic, which has a bad error message\r\n\r\n\r\n\r\n\r\n')]"
806,[Bug] - Fetched events can have incorrect transaction IDs if the events are emitted in different AccountUpdates,MartinMinkov,closed,"# Description

`fetchEvents` uses the [Archive Node API](https://github.com/o1-labs/Archive-Node-API) to fetch events/actions from the Archive Node. When `fetchEvents` were [implemented](https://github.com/o1-labs/snarkyjs/pull/749), the internal type of Events was updated to reflect network information such as block and transaction information.

Due to a [bug in the Archive Node API](https://github.com/o1-labs/Archive-Node-API/pull/68), events have incorrect transaction information. Actions are not affected in this case since actions do not have transaction information fetched from the API. Only events do.

Currently, in SnarkyJS, the return value of `fetchEvents` is incorrect since transaction information should be defined for each event. To fix, we need to change the GraphQL query for `fetchEvents` and change the internal types used in SnarkyJS to add transaction information to events instead.",[]
804,this.reducer.getActions returns duplicate actions for the current chain tip ,garethtdavies,closed,"If there are multiple blocks at the chain tip, `this.reducer.getActions` will return duplicate values for actions. This results in a failure when reducing the actions as below. In this case there were 3 actions and 2 blocks at the chain tip:

```
Failed to derive correct actions hash for B62qkmJvYCoXrCPSx6kSH12KUwyNyfp2PLVrdS2pGxsnHCHpWJtdcTT.
            Derived hash: xkwdExB1EwPceGgXv5CAPm5wxsSFVCsNmnyJs8brLo8k9T7i9S, expected hash: xv5PGcNwLiabhbDcEYMUUsUSqq9A6yYxJWv4oBpPMS8swbUqeu).
            All action hashes derived: [
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""wf7dUpkwY3e8quBYqGn8F47nLJdZGmWPfAZQ4CVB3JtThRjPWD""
      },
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""xrnES4MUSvpgucrfMNEXptfbUva47kXH5z9uRtiLeyTDkjC2Ca""
      },
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""xv5PGcNwLiabhbDcEYMUUsUSqq9A6yYxJWv4oBpPMS8swbUqeu""
      },
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""xzfdTRNrq38qs33Ltj118bNz6vQbkB3qjaorCJ8Hr9wc7YBbse""
      },
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""wXc3yE33tMQAJ7fmV1iQG235zeeesn7Z8ihhE4egVBeBBT7NGX""
      },
      {
        ""actions"": [
          [
            ""1""
          ]
        ],
        ""hash"": ""xkwdExB1EwPceGgXv5CAPm5wxsSFVCsNmnyJs8brLo8k9T7i9S""
      }
    ]
            Please try a different Archive Node API endpoint.
```
While this can be resolved by waiting for an additional block before processing actions, perhaps it would be better to return no actions in this instance rather than duplicate, which is guaranteed to fail.","[('MartinMinkov', "" Good news - we've merged a workaround for this issue in https://github.com/o1-labs/snarkyjs/pull/817. The upcoming release of SnarkyJS will include this fix, so I'll be closing this issue.\r\n\r\nThis workaround follows a similar approach to events and serves as a temporary solution. Once we redeploy the Berkeley network, we'll be able to address the root cause of this issue. 😊\r\n\r\nYou can track that related issue here: https://github.com/o1-labs/Archive-Node-API/issues/7"")]"
802,Allow `Fetch.fetchActions` to derive actionHash from any block instead of calculating from beginning,MartinMinkov,closed,,"[('MartinMinkov', 'Work done for to support this in Archive Node API is done here: https://github.com/o1-labs/Archive-Node-API/pull/71')]"
800,Review Tutorial 10,jasongitmail,closed,[Tutorial 10](https://github.com/o1-labs/docs2/pull/313),"[('barriebyron', 'My review is completed for https://github.com/o1-labs/docs2/pull/313/files '), ('barriebyron', 'My review is completed for https://github.com/o1-labs/docs2/pull/313/files '), ('nicc', 'IRI: @jasongitmail / @barriebyron '), ('MartinMinkov', 'Closing this since the PR has been merged')]"
799,Data fetching with getAccount fails with Mina.Network,mitschabaude,closed,,[]
798,Cannot reduce multiple actions in the same block on Berkeley,garethtdavies,closed,"I am submitting multiple transactions containing an action that is being included in the same block e.g., this block contains 2 https://berkeley.minaexplorer.com/block/3NL7njoFxYFhLXdVQmbtp47KR2qnAGsdvYgrxgkXT8mD1M9KLmx3

When I reduce this, i.e.,

```
let { state: newCounter, actionsHash: newActionsHash } =
            this.reducer.reduce(
                pendingActions,
                // state type
                Field,
                // function that says how to apply an action
                (state: Field, _action: Field) => {
                    return state.add(1);
                },
                { state: counter, actionsHash }
            );

        Circuit.log('newCounter', newCounter);
        Circuit.log('newActionsHash', newActionsHash);
```

The result of this is:

```
console.log
    rolling up pending actions..

      at Object.<anonymous> (src/actions.test.ts:229:17)

  console.log
    state before: 0

      at Object.<anonymous> (src/actions.test.ts:231:17)

  console.log
    actionsHash 12935064460869035604753254773225484359407575580289870070671311469994328713165

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    pendingActions []

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newCounter 0

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newActionsHash 12935064460869035604753254773225484359407575580289870070671311469994328713165

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    actionsHash 12935064460869035604753254773225484359407575580289870070671311469994328713165

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    pendingActions [ [ '1', '1' ] ]

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newCounter 0

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newActionsHash 20181218591800334489462324119362690974902046257048050553209249805515233657889

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    actionsHash 12935064460869035604753254773225484359407575580289870070671311469994328713165

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    pendingActions [ [ '1', '1' ] ]

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newCounter 0

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13

  console.log
    newActionsHash 20181218591800334489462324119362690974902046257048050553209249805515233657889

      at node_modules/snarkyjs/src/lib/circuit_value.ts:1058:13
```

The sequence state of this account after these 2 actions have been included in the block is this. As the `newActionsHash` isn't the same the tx fails on a precondition. here https://berkeley.minaexplorer.com/transaction/5JtZjKU4jcmz8FXneSqXjmpqtvYS5rJARUvntTCPFm1Xy14ebkMM

```
""sequenceEvents"": [
        ""27901414991262126135412371664144148540281626029327762954351708127423118004668"",
        ""12935064460869035604753254773225484359407575580289870070671311469994328713165"",
        ""12935064460869035604753254773225484359407575580289870070671311469994328713165"",
        ""12935064460869035604753254773225484359407575580289870070671311469994328713165"",
        ""12935064460869035604753254773225484359407575580289870070671311469994328713165""
      ],
```

If I run this with only one action in the block, it works just fine, updating the on-chain state to `newCounter`. 

Could there be an issue with the way the API is handling the data when there are multiple actions in the same block?

Should be labelled ITN-zkApps-E2E-testing","[('garethtdavies', ""I think `pendingActions [ [ '1', '1' ] ]` should be `pendingActions [ ['1'], ['1'] ]`?""), ('garethtdavies', ""When running locally on tests that pass, the logging does indicate the formatting is incorrect:\r\n\r\n```\r\n console.log\r\n    pendingActions [ [ '1' ], [ '1' ] ]\r\n```""), ('mitschabaude', '@MartinMinkov we should check if there is an inconsistency between archive node and protocol ')]"
797,getAccount() fails to find Account: Could not find account for public key...,gordonfreemanfree,closed,"When using getAccount() with a token id other than the default (Mina) it throws an error:

 let newAccountInfo = Mina.getAccount(zkAppAddress, zkApp.token.id)

_getAccount: Could not find account for public key B62...GPmp7 with the tokenId yG...Umxi_

It looks like _getAccount_ is making a GraphQL query with an undefined public key and the default token id.
This can be found in the logs of GraphQL proxy:

""message"": ""Argument publicKey of type PublicKey expected on field account, found \""undefined\"".""
_{
  account(publicKey: ""undefined"", token: ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"") {
    publicKey
    token
    nonce
    balance {
      total
    }_
    
  
The issue is also discussed here:
 https://discord.com/channels/484437221055922177/1070807617586352260/1085598944593203304
 
 snarkyJS: 0.9.2
 (plz add ITN-zkApps-E2E-testing label)
    ","[('Trivo25', '@gordonfreemanfree does the issue continue to persists with SnarkyJS version 0.9.3?'), ('mitschabaude', 'Closing for now because I think it was fixed by that update')]"
795,Change internal types stored for actions data to be Fields rather than strings,MartinMinkov,closed,"Instead of doing the conversion to field => base58 format, we should keep the data as a field to save on the extra work that is being done.

here: https://github.com/o1-labs/snarkyjs/blob/9acec551e1cc51c3356d5bc3118fc026e104ea05/src/lib/fetch.ts#L735
here: https://github.com/o1-labs/snarkyjs/blob/9acec551e1cc51c3356d5bc3118fc026e104ea05/src/lib/mina.ts#L513

This means updating some type definitions used for actions to make TypeScript happy.",[]
793,Document Product Eng. Backlog Refinement,nicc,closed,"A step-by-step guide for running Backlog Refinement should be available in Notion. This eases onboarding, keeps us on track during the ceremony, allows us to explicitly record any process changes, and enables others to run the meeting if someone is unavailable","[('nicc', 'I created this internal issue in the wrong place, apologies.')]"
790,`Field.random` is circuit incompatible when used to update the contract set,Trivo25,closed,"Updating the state of a smart contract (`this.x.set()`) with a value which originated from a computation that uses `Field.random()` or `Circuit.witness(Field, Field.random)` results in an unsatisfied constraint error


```ts
class SimpleZkapp extends SmartContract {
  @state(Field) x = State<Field>();

  @method update() {
    let x = this.x.get();
    this.x.assertEquals(x);

	// this below works fine
	// same for Circuit.witness(Field, Field.random)
    let a = Field.random();
	
	// this is the problem
    this.x.set(a);
  }
}
```


```
Error when proving SimpleZkapp.update()
Error: ( ""Error: Constraint unsatisfied (unreduced):\
 \nChecked.Assert.equal\
 \nrule_main\
 \nstep_main\
 \n\
 \nConstraint:\
 \n((basic(Equal(Var 3)(Var 4484)))(annotation(Checked.Assert.equal)))\
 \nData:\
 \nEqual 20668686932801844266334470234757811891202773415958448182848973343511399700063 14031195169788612313117614081946252754914240362556182094100318148356441364122"")
    at raise_error (/home/gregor/.opam/4.14.0/lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
    at log_and_raise_error_with_messa (/workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:25:19)
    at null.<anonymous> (/workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:388:19)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.<anonymous> (/builtin/+jslib.js:252:14)
    at Object.eval [as assertEquals] (eval at caml_js_eval_string (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3636:44), <anonymous>:4:20)
    at null.checkPublicInput (/home/trivo/Development/snarkyjs/src/lib/zkapp.ts:513:17)
    at null.<anonymous> (/home/trivo/Development/snarkyjs/src/lib/zkapp.ts:279:17)
    at null.runWith (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:89:14)
    at Function.runWith (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:43:9)
    at null.<anonymous> (/home/trivo/Development/snarkyjs/src/lib/zkapp.ts:186:54)
    at null.runWith (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:89:14)
    at Function.runWith (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:43:9)
    at SimpleZkapp.wrappedMethod (/home/trivo/Development/snarkyjs/src/lib/zkapp.ts:174:35)
    at null.<anonymous> (/home/trivo/Development/snarkyjs/src/lib/zkapp.ts:685:38)
    at null.main (/home/trivo/Development/snarkyjs/src/lib/proof_system.ts:472:5)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at null._gJX_ (/workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2010:30)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:28)
    at null.<anonymous> (/workspace_root/src/lib/pickles/step_main.ml:292:15)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:28)
    at null.with_label (/workspace_root/src/lib/snarky/src/base/snark0.ml:1243:15)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at null.<anonymous> (/workspace_root/src/lib/pickles/step_main.ml:291:11)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:28)
    at null.with_label (/workspace_root/src/lib/snarky/src/base/snark0.ml:1243:15)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at null.main (/workspace_root/src/lib/pickles/step_main.ml:277:5)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:37)
    at null.<anonymous> (/workspace_root/src/lib/pickles/step.ml:834:43)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:28)
    at null.handle (/workspace_root/src/lib/snarky/src/base/snark0.ml:1227:15)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at null._iQf_ (/workspace_root/src/lib/pickles/step.ml:833:21)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:34)
    at null.mark_active (/workspace_root/src/lib/snarky/src/base/snark0.ml:1157:19)
    at null._pA8_ (/workspace_root/src/lib/snarky/src/base/snark0.ml:1278:52)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:34)
    at null.as_stateful (/workspace_root/src/lib/snarky/src/base/snark0.ml:737:15)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at handlers (/workspace_root/src/lib/snarky/src/base/runners.ml:82:22)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at null.<anonymous> (/workspace_root/src/lib/snarky/src/base/runners.ml:310:13)
    at caml_call4 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7609:28)
    at null.<anonymous> (/workspace_root/src/lib/snarky/src/base/runners.ml:278:34)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at caml_call5 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7611:46)
    at /home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:128517:38
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at caml_call6 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7615:16)
    at null.<anonymous> (/workspace_root/src/lib/snarky/src/base/snark0.ml:1278:19)
    at caml_call1 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7603:28)
    at null.finalize_is_running (/workspace_root/src/lib/snarky/src/base/snark0.ml:1257:15)
    at null.generate_witness_conv (/workspace_root/src/lib/snarky/src/base/snark0.ml:1277:7)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at caml_call4 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7609:43)
    at null.<anonymous> (/workspace_root/src/lib/pickles/step.ml:807:7)
    at null.caml_call_gen (/builtin/+stdlib.js:32:12)
    at null.caml_call_gen (/builtin/+stdlib.js:34:12)
    at null.<anonymous> (/builtin/+stdlib.js:42:14)
    at null.caml_call_gen (/builtin/+stdlib.js:28:22)
    at caml_call10 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7631:16)
    at null.wrap (/workspace_root/src/lib/pickles/compile.ml:751:34)
    at caml_call2 (/home/trivo/Development/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7605:28)
    at Array.prove (/workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:2279:7)
    at null.<anonymous> (/home/trivo/Development/snarkyjs/src/lib/account_update.ts:1927:38)
    at null.runWithAsync (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:105:20)
    at Function.runWithAsync (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:45:9)
    at null.<anonymous> (/home/trivo/Development/snarkyjs/src/lib/account_update.ts:1923:28)
    at null.runWithAsync (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:105:20)
    at Function.runWithAsync (/home/trivo/Development/snarkyjs/src/lib/global-context.ts:45:9)
    at Object.run (/home/trivo/Development/snarkyjs/src/lib/proof_system.ts:611:27)
    at null.addProof (/home/trivo/Development/snarkyjs/src/lib/account_update.ts:1919:43)
    at null.addMissingProofs (/home/trivo/Development/snarkyjs/src/lib/account_update.ts:1955:48)
    at Object.prove (/home/trivo/Development/snarkyjs/src/lib/mina.ts:281:44)
    at file:///home/trivo/Development/snarkyjs/src/examples/simple_zkapp.tmp.js:64:10
```","[('mitschabaude', ""`Field.random()` can't work because you'd be encoding a different constant in the circuit than at compile time. I wonder about `Circuit.witness` though 🤔 \r\nCan you reproduce this with other values returned from the witness callback?""), ('Trivo25', 'EDIT: long story short;  after looking at the error message in detail, the assertion `checkPublicInput(publicInput, accountUpdate);` fails https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L508\r\n\r\nSome further research reveals that the account update constructed by the prover doesn\'t match the account update constructed by the transaction block - because the appState update doesn\'t match (the prover things the update is `x`, whereas its actually `y` https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L235\r\n\r\nSeems like its a known error \r\n\r\n---\r\n\r\nI initially thought `Field.random` was already a witness, but seems like it isn\'t :D \r\nHere are some more clues:\r\n\r\n- With `Circuit.witness(Field, Field.random)`, the verification key after compile never changes, as expected\r\n- removing `this.x.set(a);`, while still invoking `Circuit.witness(Field, Field.random)`, ""fixes"" the error\r\n- testing with `Circuit.witness(Field, () => Field(x))`, where `x` is either `0`, `Field.ORDER - 1n` or `Field.ORDER / 2n` works fine, as expected\r\n- passing in a `Field.random` as method argument works `zkapp.update(Field.random());`, as expected\r\n- this also doesn\'t work:\r\n```ts\r\nlet a = Circuit.witness(Field, () => {\r\n    let n = Math.ceil(Math.random() * 1000);\r\n    return Field(n);\r\n});\r\n\r\nthis.x.set(a);\r\n```\r\n'), ('mitschabaude', ""Aaah now it's all clear to me! We run this twice and it creates different account updates with each run. Check out `memoizeWitness`, that's intended for this scenario""), ('Trivo25', 'Awesome, thanks!')]"
789,Signature.verify should handle dummy public key,mitschabaude,open,,[]
784,Explore WebGL for running expensive prover operations,mitschabaude,open,,[]
782,Check limits before proceeding with the heavy computations,shimkiv,open,"It will be very beneficial and great time saver if we can check limits before proceeding with the computations.

```txt
Error during transaction sending:
Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.
Each transaction needs to be processed by the snark workers on the network.
Certain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.
{""signedPair"":0,""signedSingle"":0,""proof"":8}
    at verifyTransactionLimits (snarkyjs.js:23538:11)
    at Object.sendTransaction (snarkyjs.js:23176:7)
    at sendTransaction (snarkyjs.js:23347:31)
    at Object.send (snarkyjs.js:22956:20)
    at exceedComputationalCostButtonWeb (helpers.js:1167:36)
    at async HTMLButtonElement.<anonymous> (app.js:245:7)
```

[Internal discussion](https://o1-labs.slack.com/archives/C028Q27R8UC/p1678116962801909).",[]
781,mini RFC: fallback URLs for archive node API and mina API,jasongitmail,closed,"I.e. if the first is non-responsive after a certain time period, send HTTP request to a 2nd URL.","[('mitschabaude', '## Mini-RFC: Fallback URLs\r\n\r\n### API\r\n\r\nWe keep the current API, but the `mina` and `archive` endpoints can be either a string or a _list of strings_:\r\n\r\n```ts\r\nMina.Network({\r\n  mina: [""https://berkeley.minascan.io/graphql"", ""https://berkeley.minaexplorer.com/graphql""],\r\n  archive: [""..."", ""...""]\r\n});\r\n```\r\n\r\n### Behaviour\r\n\r\nWe fetch from all endpoints simultaneously and use the first result that arrives, using `Promise.race`'), ('MartinMinkov', ""Is it worth supporting the Mina node's GraphQL API for the `mina` property? That way, if any services go down, someone always has the capability of spinning up their node and using a node as a final fallback. ""), ('mitschabaude', ""> Is it worth supporting the Mina node's GraphQL API for the `mina` property? That way, if any services go down, someone always has the capability of spinning up their node and using a node as a final fallback.\r\n\r\nDefinitely! Mina node graphql spec is what we always developed against, so would be wrong to not support it for some minor reason ""), ('jasongitmail', ""> either a string or a list of strings\r\n\r\n+1\r\n\r\n> Behaviour\r\n> \r\n> We fetch from all endpoints simultaneously and use the first result that arrives, using Promise.race\r\n\r\nSeems good in the short term because of the ease of implementation. Longer term, we probably don't want to enable devs to fetch from unlimited endpoints simultaneously, because of the unreasonable burden it'd put on API providers if the dev just lists every one they are aware of or something similarly silly because there is no downside to the dev to do this. So we might want to discuss waterfalling to fallback URLs after a timeout or throttling. But this is good for now.""), ('MartinMinkov', ""> Definitely! Mina node graphql spec is what we always developed against, so would be wrong to not support it for some minor reason\r\n\r\nI just mention this cause I'm not sure if the Mina node's GraphQL API matches exactly of what the other API providers are, if it is then easy work :D But I thought there could be a small chance of changing some of the queries.""), ('garethtdavies', ""> I just mention this cause I'm not sure if the Mina node's GraphQL API matches exactly of what the other API providers are, if it is then easy work :D But I thought there could be a small chance of changing some of the queries.\r\n\r\nIt'll be the same, it's just a reverse proxy in front of the daemon GraphQL API with the addition of removing some sensitive queries/mutations. Those left should behave exactly the same way."")]"
780,Research zkApp Auro Wallet compatibility bug ,jasongitmail,closed,,"[('jasongitmail', 'To confirm if an issue exists. High priority if so.'), ('mitschabaude', '<img width=""363"" alt=""SCR-20230305-sary"" src=""https://user-images.githubusercontent.com/20989968/223350301-e8cfc3ca-9e7a-4fc6-be02-41ef5302abc3.png"">\r\n\r\nTransaction JSON:\r\n[zkapp_command.json](https://github.com/o1-labs/snarkyjs/files/10906426/zkapp_command.txt)'), ('mitschabaude', 'Same error was reported by a user on discord: \r\nhttps://discord.com/channels/484437221055922177/1080198932992372776/1080808510566178869'), ('jasongitmail', 'Can we add to this issue how to reproduce the bug? '), ('mitschabaude', 'To reproduce, this should work:\r\n```ts\r\nawait window.mina.sendTransaction({\r\n  transaction: zkappCommandJson, // <--- JSON file linked above\r\n  feePayer: ... // any fee payer\r\n})\r\n```\r\nwhere `zkappCommandJson` is [zkapp_command.json](https://github.com/o1-labs/snarkyjs/files/10906426/zkapp_command.txt)'), ('iam-robi', 'I reported this issue on discord;  error occured in my ui after upgrading from snarky js 0.7.* to 0.9.* . code of ui & contracts is available here https://github.com/iam-robi/zkapp-monorepo. '), ('wjdfx', 'https://github.com/aurowallet/auro-wallet-browser-extension/commit/52ad21b4cc027588998fb2e49c23ac91e8a97fec has been solve this problem.\r\nWait about 1-2 days upgrade Auro Wallet to latest verion: V2.1.7\r\n\r\n'), ('nicc', 'Indirectly Irresponsible Individual: @ymekuria '), ('shimkiv', 'Indeed, `v.2.1.7` fixes the issue, thank you.')]"
779,Draft initial document with ideas around logic abstraction in SnarkyJS modularization,jasongitmail,open,Goal is to start the discussion.,"[('nicc', 'Indirectly Irresponsible Individual: @mitschabaude ')]"
778,Milestone code review for flash grants,jasongitmail,closed,To help out MF,"[('jasongitmail', 'Florian and Gregor attended this last week. Still need to look at code'), ('jasongitmail', 'Closing as redundant')]"
777,Export 'Events' from snarkyjs,maht0rz,open,"Would be amazing if we could import `Events` from snarkyjs directly.

This is the code/export i'd like to access from the main package:
https://github.com/o1-labs/snarkyjs/blob/main/src/provable/transaction-leaves.ts#L17

```
import { Events } from 'snarkyjs' 
```

Right now i have to do the following, which breaks a couple things down the line when i publish my library packages:
```
import { Events } from '../../../node_modules/snarkyjs/dist/node/provable/transaction-leaves.js';
```

^ This triggers error `ts(2742)` in my libraries when i try to use anything that relies on this specific import.
","[('mitschabaude', ""I'd merge a PR which adds 1 line of code to export `Events` as `AccountUpdate.Events` analogous to sequence events here: https://github.com/o1-labs/snarkyjs/blob/d6b7995aa81070c1dcc78eb751ae70578ddeb97a/src/lib/account_update.ts#L650""), ('maht0rz', 'Thanks, i’ll open a PR')]"
776,Can we make universality transitive in SnarkyJS/pickles/kimchi?,bkase,closed,"Mina’s L1 supports universality in the zkapp cpu his kimchi/pickles . Can we tap into universality at the programmable module layer? Can we define a recursive circuit in snarkyjs that can verify proofs of older versions of itself?
This would allow upgrades of the zk circuit during recursive aggregation without having to settle to the L1 in between.

Why:
Having this feature would make it more practical to build cross-communicating zkAppChain rollups + allow SnarkyJS/Kimchi to be directly used as the core for other recursively composable platforms like they can on the Mina L1 (L2s, L3s, L4s, etc that settle on Mina for example)","[('mimoo', 'we could easily do this now, but depending on the changes in the proof system it might become less and less ""easy"" and more and more of a nightmare. Basically, we will either have to fork the verifier circuit every time we do a breaking change in the proof system, or if we can, make the verifier circuit more general depending on configuration.\r\n\r\nEDIT: rereading the question I\'m not sure I fully understand it actually'), ('bkase', 'Slack discussion yielded yes on the pickles backend side using side loaded verification keys -- the work becomes how do we expose this in SnarkyJS with a nice API'), ('bkase', 'And this is already tracked here! https://github.com/o1-labs/snarkyjs/issues/673')]"
773,Can we identify and communicate txn failure due to stale verification key?,nicc,open,"See [this conversation](https://o1-labs.slack.com/archives/C028Q27R8UC/p1677694176302719).

The error message returned when trying to submit a proof to an address with a stale verification key is accurate but arguably not very informative, especially during zkApp development. Can we (and do we want to) identify stale keys more directly? Or is it appropriate to say nothing more than ""nope""?

To dicsuss.",[]
772,Implement hashing to curve,mitschabaude,closed,"Primitive needed for zk nullifiers & useful to have in general

IETF draft: https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-16.html
Twitter discussion: https://twitter.com/hdevalence/status/1630463319336435714","[('nicc', 'IRI: @mitschabaude '), ('Trivo25', ""Goal is to implement a nullifier, which requires a hash to curve scheme that includes some helper methods like [hash to field](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-hash_to_field-implementation) and map to curve described in [8.1 of the IETF draft](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-implementing-a-hash-to-curve)\r\n\r\nThe hash to field function is required to return two field elements instead of just one (like Poseidon currently does by default in SnarkyJS) - a potential solution for that could be to use the sponge construct to return multiple elements.\r\n\r\nThe pasta curves are of the form `y² = x³ + 5`, where `A = 0` and `B = 5`. \r\n\r\nAccording to the [IETF draft](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-deterministic-mappings-2) on hashing to curves, a mapping function can be constructed using the simplified Shallue-van de Woestijne method described in [6.6.1](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-simplified-shallue-van-de-wo) However, since the constants of the pasta curves are `A = 5` and `B = 5` and therefor `AB = 0`, we have to implement a special version described in [6.6.3](https://www.ietf.org/archive/id/draft-irtf-cfrg-hash-to-curve-10.html#name-simplified-swu-for-ab-0-2) for `AB = 0`, which requires us to find an auxiliary curve `E'` which is isogenous to `E`, apply the SWU algorithm and then map the points from `E'` to `E`. \r\n\r\nA [reference implementation](https://github.com/zcash/pasta_curves/blob/main/src/hashtocurve.rs) for the pasta curves is available in the official pasta curves repository. The required constants, including parameters of `E'` can be found in said repository - we would just have to implement all the necessary logic surrounding it (both in SnarkyJS' stdlib as well as making it available in mina-signer)\r\n\r\n\r\nQuestion: Is this approach valid or is there a better alternative? \r\n\r\n"")]"
771,Implement hashing to curve,mitschabaude,closed,,[]
770,Improve UX of setting timing & permissions,mitschabaude,open,"There are two account fields which are a bit annoying to set, because they are big objects of many properties, all of which need to be set at once; but the developer might only care about setting a few of the properties.

We should go for a DX where the developer only has to specify a subset of values:
```ts
this.account.permission.set({ editState: Permissions.proofOrSignature() });
this.account.timing.set({ initialMinimumBalance: x, cliffAmount: x, cliffPeriod: y });
```

TBD: what to use as default values. I think

* Permissions should use existing permissions as backdrop default (but need to handle cleverly in `deploy()` to not override the setting of `Permissions.default()` with user-defined permission setting
* Timing should just use fixed default values. There would be some restriction -- initial minimum balance can't be left out, and either `cliffAmount` + `cliffTime`, or `vestingIncrement` should be provided, to avoid a setting where the tokens can never unlock

Related DX improvement: Snarkyjs should fail early if `timing.vestingPeriod` is set to `0`, because the protocol doesn't allow that","[('jasongitmail', 'For context where this came up in docs review: https://github.com/o1-labs/docs2/pull/276#discussion_r1121792532 ')]"
769,Eslint doesn’t have global context as it’s currently configured,bkase,open,If a ZK contract calls another in another file eslint misses it.,"[('mitschabaude', ""Not sure I understand what the linter misses! Why shouldn't a zkApp contract call another in another file?\r\n\r\nI think, as currently configured, eslint doesn't process TS files at all. We rely on `ts` (built into VS code) as the linter, which enforces correctness of syntax & types. It _is_ true that TS sometimes misses if things aren't declared & used in the right order, so something is actually undefined because it is used before declared"")]"
768,extending a smart contract causes state to access the same values ,Trivo25,open,"@maht0rz ran into the following problem:

Extending smart contract causes state to access the same value (index in the state array), if the contract that is being extended already has state

```ts

class A extends SmartContract {
	@state(Field) a1 = State<Field>();
}

class B extends A {
	@state(Field) a2 = State<Field>();
	@state(Field) b2 = State<Field>();
}

```  

In this case, `a1` and `a2` will access and modify the same value
","[('mitschabaude', ""There are a couple of other things that I believe don't work when extending. E.g. decorated methods on the base contract are not available for proving. It's completely broken""), ('maht0rz', 'Would be great to see support for all the decorators in extende classes 👍 ')]"
766,zkIgnite: extra office hours for electors week of 13 - 17 March,nicc,closed,,"[('nicc', 'wrong repo! closing to recreate elsewhere')]"
765,Rename sequence state to action state,mitschabaude,closed,,[]
763,Discussion: Filter out all blocks at the tip of the network if there is more than 1 ,MartinMinkov,open,"## Description 

Related too https://github.com/o1-labs/snarkyjs/pull/749

Should we filter out all blocks at the max height of the network? 

The issue with blocks at the tip of the network is that since Mina's finality cannot guarantee that a fork will not happen at the tip of the network, a block that contains event/action data could be replaced with one that doesn't, changing the state of the network in the viewpoint of the caller of `fetchEvents`/`fetchActions`.

To give a higher probability that a block will be considered canonical as part of the chain, we will filter out all blocks at the best tip of the network if multiple ones are being considered. This will introduce a delay of `maxBlockHeight - 1` for fetching events/actions data to give a higher probality that the transaction will be part of the network. 

## Impact

By filtering out blocks at the tip of the network, users of `fetchEvents` or `fetchActions` will have to wait for an additional block to give a higher probability that their transaction will not be forked by another block that replaces it. It trades off the speed of receiving events/actions data for more reliance on the data being part of the network.

If we do not want to filter out blocks at the highest tip, we will have to return a block that _can_ be replaced, which gives an inconsistent view of a user of a zkApp depending on events/actions data, but users will not have to wait for an additional block to be included.","[('mitschabaude', ""One concern I have is that, for all the other network and account state, we currently fetch the latest block (`bestChain(maxLength: 1)`), so we would be using a view on the chain that's inconsistent with other data we use.\r\n\r\nOn the other hand, it might not be a problem if events and actions are lagging behind a bit, and in contrast to other state they don't get invalidated by newer blocks -- they just get appended to. The increased reliability of the events that are returned is definitely a good point.\r\n\r\nI'd vote for making this a config option, with the default probably being what you suggested @MartinMinkov!""), ('MartinMinkov', 'In light of this PR: https://github.com/MinaProtocol/mina/pull/12750\r\n\r\nThe Archive API will be able to use the data in the new schema to return the block with the highest chain strength. ')]"
762,Discussion: Supporting richer filtering options related to fetching events/actions,MartinMinkov,closed,"## Description

Related too https://github.com/o1-labs/snarkyjs/pull/749

Should we change the `fetchEvents` and `fetchActions` method signatures to take in more filtering options? I propose we add support for filtering by block heights (with `to` and `from` or `start` and `end` variables). 

## Impact

By allowing filtering by block height, users of `fetchEvent` or `fetchAction` will get a more precise data set of events/actions when they are being fetched. It's unnecessary to return _all_ events/actions data unless the user wants to do that (the default behaviour is if they do not pass in any filtering options). This will also put less burden on the GraphQL server itself since it has to process fewer rows if filtering is being added.","[('mitschabaude', ""+1 for filtering by block height, and we don't need filtering by slot then IMO""), ('Trivo25', 'Definitely! I wonder if it would be useful to also filter by event type '), ('MartinMinkov', ""Sweet! I'll close this out since we have an agreement on the API now. :D "")]"
761,Add Community NPM Packages to README,jasongitmail,closed,With a bulleted list of community packages. Goal to highlight them in a lightweight way. ,"[('nicc', 'Add instruction for contributors to fulfil community contributor requirements and create a PR to add their own package to the list'), ('nicc', 'Indirectly Irresponsible Individual: @jasongitmail '), ('mitschabaude', 'Done!')]"
760,Allocate time to support grantee working on ZEXE,jasongitmail,closed,Mentioned by Yasin. Will ask them to reach out via Discord.,"[('nicc', 'Indirectly Irresponsible Individual: N/A?'), ('Trivo25', 'Looks like this can be closed, @nicc ? ')]"
759,Add community package contributor standards / requirements to SnarkyJS ReadMe,jasongitmail,closed,"- [ ] A README.md should exist.
- [ ] Include a license. We recommend [Apache 2.0 license](https://github.com/o1-labs/snarkyjs/blob/main/LICENSE).
- [ ] For code consistency, your package should be created using the [zkApp CLI](https://github.com/o1-labs/zkapp-cli) (which will contain the desired configs for Prettier, ESLint, Jest, tsconfig, etc), _or_ your project should contain the configuration files for [Prettier config](https://github.com/o1-labs/snarkyjs/blob/main/.prettierrc.cjs), [ES Lint config](https://github.com/o1-labs/snarkyjs/blob/main/.eslintrc.json), [tsconfig.json](https://github.com/o1-labs/snarkyjs/blob/main/tsconfig.json) found in the [SnarkyJS repo](https://github.com/o1-labs/snarkyjs) & [jest.config.js available here](https://github.com/o1-labs/snarkyjs/blob/main/jest.config.js). This will ease code review and reuse by others.
- [ ] Tests should be included. 
- [ ] One or more tests should demonstrate the use of your package's methods successfully running inside ""provable code"", to demonstrate that compatible, SnarkyJS-based types are used and the library functions as intended within a ZK smart contract.
- [ ] JS Doc comments should exist and appropriate comments throughout.
- [ ] Comments & README should be in English, American spelling preferred, for consistency. 

Any others to add @Trivo25 ?","[('nicc', 'Indirectly Irresponsible Individual: @jasongitmail '), ('mitschabaude', 'Done')]"
757,LocalBlockchain vs Mina protocol handling of max event elements,maht0rz,closed,"The LocalBlockchain enforces that the total amount of elements emitted across account updates, regardless of the contents of the event, should be 16. This behaviour is implemented [here](https://github.com/o1-labs/snarkyjs/blob/ecb4da0c092cffb2c4d150f2fc3f5af1710a2c22/src/lib/mina.ts#L1165).

Based on my limited OCaml understanding, [this protocol code](https://github.com/MinaProtocol/mina/blob/7d9e2f544680a3cbf9ad564ab17500a716e4b777/src/lib/mina_base/zkapp_command.ml#L1989) implements the same logic, constraining the total number of events across all account updates, regardless of event contents.

However based on my discussion with @mitschabaude, it seems like:
- The actual behaviour should be to constraint the amount of field elements within events to be 16. Which means 16 field elements total after summing up contents of all events and account updates.
- Which then opens the question of what is the max allowed amount of events themselves?

Note: the limit of '16' is a protocol/genesis constant in the mina protocol.

I'd like to understand which of these described behaviours is correct (per protocol), and also depending on the outcome of this discussion, i'd like to propose an increase in the limits (e.g. 64 fields in total, or 64 events in total with no content constraints).

These event limits will become very noticable when trying to design an offchain storage ecosystem/library, it creates extra overhead when you write a rollup, since you might emit events inside the reduce itself, or outside on the already reduced state to decrease the amount of events you emit. All of the above is an extra overhead and potentially a hard limitation of the Mina's smart contract platform. 

I believe that we can find a reasonable limit that would accommodate snarky rollups/reducers without having to worry too much about the number of emitted events","[('mitschabaude', '> I\'d like to understand which of these described behaviours is correct (per protocol)\r\n\r\nIn my reading of the code you linked, it checks for ""total amount of field elements"", not events! Specifically, this function used in that code counts the field elements in a list of events:\r\nhttps://github.com/MinaProtocol/mina/blob/7d9e2f544680a3cbf9ad564ab17500a716e4b777/src/lib/mina_base/zkapp_command.ml#L1940-L1941\r\n\r\n> Which then opens the question of what is the max allowed amount of events themselves?\r\n\r\nI don\'t understand why there should be a total max of events when we already have the max on field elements. The one implies the other: if your events have minimal size (1 field element per event), then the max # events is 16. When your events are bigger, the max # becomes less.'), ('mitschabaude', 'Tagging @deepthiskumar to comment on increasing the protocol limit'), ('maht0rz', '@mitschabaude fair enough on the max field elements vs max events, having max field elements covers all the relevant cases. \r\n\r\nWhat about the LocalBlockchain behaviour? Assuming i tested and understood the local blockchain code correctly, it checks for the amount of events, not field elements.'), ('mitschabaude', ""> What about the LocalBlockchain behaviour? Assuming i tested and understood the local blockchain code correctly, it checks for the amount of events, not field elements.\r\n\r\nthat's true, working on a fix"")]"
756,RFC: PLUME nullifiers in mina-signer + snarkyjs,mitschabaude,closed,"## Motivation

**Nullifiers** are a tool needed by privacy zkApps to keep track of actions that should be only allowed once per user, _without revealing anything about the user_. Examples:
- ZCash uses nullifiers to ensure that a user can't spend a UTXO twice
- Private voting zkApps use nullifiers to ensure a user can't vote twice

In concrete terms, a nullifier is a large number derived from a user's private key + some application data, which
- is only recoverable by the user in question;
- is _hiding_, i.e., can not be used to learn the user's private or public key. 

To perform some action, like spending a UTXO, users need to check the nullifier inside a SNARK (in a way that proves its link to a certain public key) and ""emit"" the nullifier and public key as public output / event. The application then checks that it never saw the same nullifier before. If this is the case, the user is allowed to perform the action. The application then stores the nullifier in a list among all the other nullifiers ever spent. This ensures that, would the user attempt to  perform the action a second time, the application could reject it.

**Problem statement**: We don't currently support any nulilfier scheme where a user can derive their identity from their Mina wallet. This inhibits secure & practical implementations of anything using nullifiers, such as private voting, mixers etc. 

## Requirements for a nullifier implementation

- Includes SnarkyJS code to verify nullifiers inside a SNARK
- Does not require the user's private key as SNARK input
- A method to create equivalent nullifiers should also be built into mina-signer, so that wallets can support it and users can use their normal wallet to interact with zkApps that rely on nullifiers

## Proposal

I propose that we implement Aayush Gupta's ""PLUME"" scheme in mina-signer + snarkyjs.

* Paper: https://eprint.iacr.org/2022/1255.pdf
  * The nullifier construction to be implemented is described on pages 19 and 20 of that paper
* Blog post: https://blog.aayushg.com/posts/nullifier
* Implementation can use available primitives. The only missing primitive is a `hashToCurve` function, which has to be added to the snarkyjs stdlib as part of this implementation.
  - Tracked as separate issue here: https://github.com/o1-labs/snarkyjs/issues/772

We add the following interfaces:

**mina-signer**
- `createNullifier(message: Field[], privateKey: PrivateKey): JsonNullifier`

**SnarkyJS**

`Nullifier` which is a `Struct` with the following properties:
- `nullifier.publicKey` which is used to check inclusion of the public key in a given set, e.g. Merkle tree
- `nullifier.message` which attests that the nullifier is associated with the given message. The message is defined by the application and allows for application-specific checks such as ""this is a valid nullifier for voting round no 3 of my voting zkApp""  
- `nullifier.nullifier` which is used as the key / Merkle leaf when we check that the nullifier isn't spent yet
- extra data which won't be accessed by the developer directly but is necessary to verify the nullifier, see below

`Nullifier` comes with at least two essential methods:
  - `Nullifier.fromJSON(n: JsonNullifier): Nullifier` to read in the nullifier returned from mina-signer
  - `nullifier.verify(): boolean` which checks inside the SNARK that the nullifier belongs to the user + message
  
  ## Other architectures considered, tradeoffs
  
A popular nullifier scheme that can easily be built with SnarkyJS (and has been built already) is **Semaphore**, where nullifiers are derived from a private key which also has to be input to the SNARK. In practice, this means the private key can't sit in the user wallet, since these wallets don't (and shouldn't) expose any private keys to websites. Thus, when advocating for this scheme we would shift a huge burden to zkApp developers to build their own way of managing user private keys from the browser.","[('bkase', 'I agree with the premise; it would be best to implement some nullified scheme that doesn’t require the private key as a private input and moreover that we should be providing some first class nullified built-in to our tool stack so other people don’t need to figure these things out.\r\n\r\nYour proposed nullifier scheme seems like it could work! My question is: Are there other alternatives to consider before choosing this one?'), ('mitschabaude', ""> Are there other alternatives to consider before choosing this one?\r\n\r\nI'm not aware of others but also haven't looked for them!""), ('mimoo', ""So, the only thing wrong with just doing something like this in a circuit is that you need to use the `secret_key` directly?\r\n\r\n```js\r\n// prove that the secret key is linked to the public key\r\ngenerator.scale(secret_key).assert_equal(public_key);\r\n// create the nullifier\r\nlet nullifier = poseidon(domain_separation, secret_key, public_key);\r\n```\r\n\r\n(I'm guessing this is what zcash-scheme nullifier looks like, although I haven't looked at these things in a long time.)\r\n\r\nIf that's the only downside is it worth fixing it now? My argument was that these things are simple enough that it might not be super useful to expose in a stdlib, but if we think it is maybe this is enough?\r\n\r\nOn the other hand, looking at the paper, you'd need an enclave to implement a number of operations (including a poseidon hash function) and I'm guessing this is not going to happen until a long time. So one idea could be to just offer the simple way (what zcash/tornadocash/etc. are doing) and mention in the lib that for schemes that want to take advantage of enclaves then they could implement that paper. wdyt?\r\n\r\nPS: I think exposing a `hash_to_curve` in the stdlib would be something useful!""), ('mitschabaude', '> On the other hand, looking at the paper, you\'d need an enclave to implement a number of operations (including a poseidon hash function) and I\'m guessing this is not going to happen until a long time.\r\n\r\nThe ""enclave"" in the paper just refers to the software that has access to the private key. In our case, this is the wallet. Wallets rely on mina-signer which already has Poseidon, EC arithmetic etc built in (needs it for signing transactions)'), ('mitschabaude', ""> So, the only thing wrong with just doing something like this in a circuit is that you need to use the secret_key directly?\r\n\r\nYes!\r\n\r\n> If that's the only downside is it worth fixing it now? My argument was that these things are simple enough that it might not be super useful to expose in a stdlib, but if we think it is maybe this is enough?\r\n\r\nI don't think this is enough, because an architecture that requires you to pass a private key into a smart contract (which is running on a website) is super awkward in practice and won't be adopted.\r\n\r\nAnd I don't think the zk nullifier scheme is that hard to implement either -- it's basically just implementing that `hashToCurve` function plus stitching together a few already existing gadgets. But it's hard enough to be useful in the stdlib of snarkyjs. And super useful to include the nullifier generation method in mina-signer, because wallets won't create this on their own and they rely on mina-signer as the lib to implement the hard stuff for them.\r\n""), ('mimoo', ""> Wallets rely on mina-signer which already has Poseidon, EC arithmetic etc built in (needs it for signing transactions)\r\n\r\nOh I see, so the ledger already has support for that you're saying : o? I'm wondering if we can use this scheme as a way to perform signing then (which might be cheaper than schnorr?)""), ('mitschabaude', ""> > Wallets rely on mina-signer which already has Poseidon, EC arithmetic etc built in (needs it for signing transactions)\r\n> \r\n> Oh I see, so the ledger already has support for that you're saying : o? I'm wondering if we can use this scheme as a way to perform signing then (which might be cheaper than schnorr?)\r\n\r\nAh, no I was talking about browser wallets :D Like Auro wallet -- they will load mina-signer and they'll be able to create that nullifier when they have the user's private key.\r\n\r\nHowever, you bring up an excellent point that I didn't consider -- this won't support private keys which sit on a Ledger or similar. I think that's OK for now; users would need to create a hot wallet for interactions where nullifiers are needed, which presents a security trade-off but already enables lots of useful applications where security requirements are not THAT high""), ('Trivo25', ""> However, you bring up an excellent point that I didn't consider -- this won't support private keys which sit on a Ledger or similar. I think that's OK for now; users would need to create a hot wallet for interactions where nullifiers are needed, which presents a security trade-off but already enables lots of useful applications where security requirements are not THAT high\r\n\r\nI would actually argue that hardware wallets are the easier use case here, since they could simply delegate their rights to an auxiliary key (then it could also be input to the SNARK), so I wouldn't worry too much about hardware wallets at this stage""), ('nicc', 'Indirectly Irresponsible Individual: @Trivo25'), ('jasongitmail', ""+1 on creating this too. Looks great. And +1 for making this part of SnarkyJS because, even if it's easy to implement, it's a fundamental piece to have and we can remove the need for people to think about it--to do research on properties it should have, etc. SnarkyJS aims to make things easy. \r\n\r\nSent a few small comments earlier via DM. ""), ('mitschabaude', 'From the [paper](https://eprint.iacr.org/2022/1255.pdf), my original impression was that the wallet needs to store the ""secure randomness `r`"" (see page 19) alongside the user\'s private key.\r\n\r\nHowever, reading it again I understand that this value can actually be ephemeral. It is not used to produce the `nullifier` (which we potentially should be able to reproduce), but only the additional public output `s` which acts as a one-time hint for verifying correctness of the nullifier. Therefore, the value `r` can just be created from secure randomness in mina-signer during the `createNullifier` method, used to create the output, and not stored anywhere.\r\n\r\nThis resolves a remaining question we had @jasongitmail @bkase '), ('iam-dev', 'Some research I have done on this:\r\nI understand the RFC, by reading it for a day without sleep.\r\nIn this Circom test, they verify the witnes with only public key and commitment/ without any secrets\r\n```\r\ntest(""a/b^c subcircuit"", async () = {\r\nconst p = join(__dirname, ’a_div_b_pow_c_test.circom’)\r\nconst circuit = await wasm_tester(p)\r\n\r\n// Verify that gPowS/pkPowC = gPowR outside the circuit, as a sanity check\r\nconst gPowS = Point.fromPrivateKey(s);\r\nconst pkPowC = testPublicKeyPoint.multiply(hexToBigInt(c))\r\nexpect(gPowS.add(pkPowC.negate()).equals(gPowR)).toBe(true);\r\n\r\n// Verify that circuit calculates g^s / pk^c = g^r\r\nconst w = await circuit.calculateWitness({\r\na: pointToCircuitValue(gPowS),\r\nb: pointToCircuitValue(testPublicKeyPoint),\r\nc: scalarToCircuitValue(hexToBigInt(c)),\r\n})\r\nawait circuit.checkConstraints(w)\r\nawait circuit.assertOut(w, {out: pointToCircuitValue(gPowR)});\r\n});\r\n```\r\nhttps://github.com/zk-nullifier-sig/zk-nullifier-sig/blob/6052e45b8f7571b79247fb58eaef80d305dbcc82/circuits/test/vfy_nullifier.test.ts#L130\r\n\r\nWhich make it non-interactive, you only needs public key and the commitment which can be stored in Merkle Tree\r\nBut this Nullifier Scheme is a project it self\r\n\r\n\r\nReferences:\r\n- https://docs.google.com/presentation/d/1mKtOI4XgKrWBEPpKFAYkRjxZsBomwhy6Cc2Ia87hAnY/edit#slide=id.g13e97fbcd2c_0_86\r\n- https://blog.aayushg.com/posts/nullifier\r\n- https://github.com/zk-nullifier-sig/zk-nullifier-sig\r\n- https://ethbogota-2022.netlify.app/\r\n- https://github.com/piotr-roslaniec/ethbogota-2022\r\n'), ('Divide-By-0', '> However, you bring up an excellent point that I didn\'t consider -- this won\'t support private keys which sit on a Ledger or similar. I think that\'s OK for now; users would need to create a hot wallet for interactions where nullifiers are needed, which presents a security trade-off but already enables lots of useful applications where security requirements are not THAT high\r\n\r\nThis scheme is specifically designed such that the nullifier signature and corresponding signals can be generated in 40kB of memory on a Ledger, and we are actively searching for devs down to take on this problem and make a PR to their wallet code!\r\n\r\n> From the [paper](https://eprint.iacr.org/2022/1255.pdf), my original impression was that the wallet needs to store the ""secure randomness r"" (see page 19) alongside the user\'s private key. However, reading it again I understand that this value can actually be ephemeral.\r\n\r\nCorrect, it can be ephemeral! That is a great clarification, I can update the paper. (Edit: Done, should be live soon!)\r\n\r\n> On the other hand, looking at the paper, you\'d need an enclave to implement a number of operations (including a poseidon hash function) and I\'m guessing this is not going to happen until a long time.\r\n> The ""enclave"" in the paper just refers to the software that has access to the private key. In our case, this is the wallet. Wallets rely on mina-signer which already has Poseidon, EC arithmetic etc built in (needs it for signing transactions)\r\n\r\nSorry, my wording in the paper was a bit sloppy and should be fixed. Correct, ""enclave"" refers to any wallet. In terms of an actual secure hardware enclave, the scheme is designed such that the secure hardware enclave with the secret key only needs to compute exponents of the secret key (which is already an API usually), and the non-enclave chip\xa0(that\'s still part of the wallet) can compute all of the hash functions. In software wallets there is usually no distinction between the chip and the enclave, and I refer to both as the ""enclave"" in the paper. I\'ve clarified and fixed this in the [updated paper on my site](https://aayushg.com/thesis.pdf).\r\n\r\n> an architecture that requires you to pass a private key into a smart contract (which is running on a website) is super awkward in practice and won\'t be adopted.\r\n\r\nYes, with this scheme, the secret key does not leave a users wallet.\r\n\r\nAnother note is that we are calling the scheme PLUME (pseudonymously linked unique message entities) to avoid confusion with guarantees on ""nullifying"" double-spending, as the scheme is for much more generic identities! I have also updated the [blog post today](https://blog.aayushg.com/posts/nullifier) to make it a bit easier to read.'), ('mitschabaude', ""Thanks @Divide-By-0 for the feedback! I'll close this as we got broad alignment on the RFC. Next step is to implement it :D"")]"
753,live network test fails on certain node version ,Trivo25,open,"Recently, the berkeley integration test (which is connected to the public berkeley testnet) fails unexpectedly with a timeout error, when waiting for tx inclusion in a block (`tx.wait()`)

```
got fetch error
{
  statusCode: 500,
  statusText: 'Unknown Error:
  {""cause"":	{""name"":""HeadersTimeoutError"",""code"":""UND_ERR_HEADERS_TIMEOUT"",""message"":""Headers Timeout Error""}}'
}
```

Locally, the test succeeds - even with different nodejs versions (v16 - v18). But remotely, v18 causes it to throw an error. Downgrading the CI nodejs version to 16 fixed it.

For now, the berkeley live test is disabled until we figure out why this bug is caused specifically on version 18 and within the CI.
",[]
745,Revert mina-signer signature type,mitschabaude,closed,,[]
744,Move `Bool` class to JS,mitschabaude,closed,,"[('nicc', 'IRI: @shimkiv @Trivo25 @bkase \nCan we do a walk-through of changes during sprint review or a video?')]"
743,Handle assertions errors in JS with better error message,shimkiv,closed,"```shell
Expected pattern: /^(.*)zkApp State update failed(.*)Error: assert_equal: 14161 != 119(.*)$/i
Received string:  ""2/21/2023, 7:52:43 PM - zkApp State update failed. Reason: (\""Error: assert_equal: 0x0000000000000000000000000000000000000000000000000000000000003751 != 0x0000000000000000000000000000000000000000000000000000000000000077\"")""
```
- [Internal discussion](https://o1-labs.slack.com/archives/C028Q27R8UC/p1677007160776089)","[('mitschabaude', 'blocked on #744 (since it would be inefficient to invest in polishing the existing OCaml classes)')]"
742,Change all references in SnarkyJS to sequence events to actions,bkase,closed,,[]
740,Deploy voting sample zkApp to Berkeley,nicc,closed,"This serves to test the live network. Depends on issue [#739](https://app.zenhub.com/workspaces/zkapps-product-eng-6130fedb3b0fc600123d8796/issues/gh/o1-labs/snarkyjs/739). @mitschabaude has confirmed that the app runs with the account update limit enabled. Are there any other reasons it is not deplpoyable to Berkeley?

Once deployed, we should run the app to exercize the Archive Node API on Berkeley.","[('nicc', 'Indirectly Irresponsible Individual: @MartinMinkov ')]"
739,Update the voting sample zkApp to also use events,nicc,closed,"The app currently emits actions but not events. In order to serve as a test case for the Archive Node API, we want it to emit both actions and events.","[('nicc', 'Indirectly Irresponsible Individual: @MartinMinkov ')]"
738,jsoo can't parse large data structures ,Trivo25,open,"jsoo seems to have issues parsing large javascript data structures (arrays, objects) that exceed some limit.

```ts

class LargeStructure extends Struct({
	a: Field,
	b: Field,
	c: Field,
	d: Field,
	//...
}) {}

const Prover = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [Circuit.array(LargeStructure, 4)],

      method(publicInput: Field, arr: LargeStructure[]) {
        publicInput.equals(1);
      },
    },
  },
});


```

while 4 elements in the array work, 8 won't. Easy workaround: Splitting up large structures into multiple smaller ones `myFunc(a: SmallStruct, b: SmallStruct, c: SmallStruct)`","[('mitschabaude', 'is it a stack overflow error? would be nice to trace where it comes from, we might be able to refactor the OCaml code'), ('nicc', ""Check in before committing to fix if it's a lot of effort. We could provide a better error message instead""), ('mitschabaude', 'other related issues:\n#144\n#147')]"
735,Make circuits async: JS side,mitschabaude,open,"Why:
* @mrmr1993 might work on allowing async circuits in Pickles
* Smart contracts need the result of async computations inside circuits (fetch accounts / best chain), and currently have error-prone workarounds; huge simplification if we could just fetch
* Users would also like to do async operations, and have no workarounds currently","[('maht0rz', 'Having an async Circuit.witness could enable much nicer UX on 3rd party library side'), ('maht0rz', 'We\'ve run into a performance bottleneck again while building https://protokit.dev, I\'ll try to briefly explain what exactly we have to do in the current block production pipeline and how async witnesses could help.\r\n\r\nFor Smart Contracts / zkApps the on-chain state is preloaded at once (all 8 fields) and therefore synchronously accessible within the smart contract method, e.g. using a synchronous `Provable.witness(Field, () => Field(1))`. This is only possible since the on-chain state size is known upfront.\r\n\r\nIf the execution of a smart contract relies on additional private inputs (not known upfront), that depend on the partial result of computation of the method, and these inputs have to be fetched from somewhere - API, DB, etc. Then the code looks something like this:\r\n\r\n```\r\n// in @method()\r\n\r\n// some in circuit computation of known inputs\r\nfunction getUser(a: Field, b: Field) {\r\n  const key = Poseidon.hash([a,b]);\r\n  \r\n  // non-async witness\r\n  const user = Provable.witness(User, () => {\r\n     // access the user data statically, since the witness is synchronous, the data must be prefetched\r\n     const data = prefetchedData[key];\r\n     return new User(data)\r\n  })\r\n  \r\n  // alternative async witness (not possible today)\r\n  const user = Provable.witness(User, async () => {\r\n     // access the user data from an API directly, since we can pause the circuit until the witness is resolved\r\n     const data = await fetch(""https://my-api.com/"" + key)\r\n     return new User(data)\r\n  })\r\n}\r\n```\r\n\r\nWhat the synchronous witness approach results in is that if we can\'t reliably determine what data needs to be prefetched for the circuit execution, we end up with re-running the circuit to try and populate all the prefetched data one by one. This becomes especially noticeable if prefetching of ""data 2"" relies on the result of prefetching ""data 1"". \r\n\r\nTo sum it up, async witnesses would greatly increase the performance of Protokit block production by decreasing the complexity of the implementation as well.'), ('mitschabaude', 'Note: async witness is easy to implement purely in o1js if only we have async circuits')]"
733,Update transaction hash v1 algorithm in mina-signer,mitschabaude,closed,,[]
732,ECDSA signature creation and verification,jasongitmail,open,"Creating this issue for tracking on the zkApps roadmap. 

Why? Because it's a very common primitive in other ecosystems that can be useful for Mina to interop with other chains in various ways.",[]
731,sha256 hash,jasongitmail,open,"Why? It's an very common hashing function in other ecosystems, which makes it useful for many architectural designs. For example, many bridge designs require a common hashing function on each side.","[('mitschabaude', '@garwalsh This is now easy to do by using existing custom gates, and is still something that people regularly ask for. I also consider this an opportunity to showcase the power of our new gates (bitwise AND, XOR, NOT etc) directly within snarkyjs, for the first time'), ('garwalsh', 'One gadget to be exposed, bitwise shift')]"
730,Dynamic length strings,jasongitmail,open,Why? It's a pre-requisite to JSON parsing.,[]
728,Prepare for zkIgnite architecture workshop,jasongitmail,closed,"Goal is to come up with a specific zkApp idea that we can talk through how to build this with our existing feature set for zkApps. No code needed, this isn't a tutorial, it's a discussion of our feature set and how it can be used to solve a business use case. Minimal slides is okay. , but we may want an architecture diagram highlighting features. 

Output:
1. Idea to discuss
2. Identify DRI to present, and 1-2 additional devs to attend to support audience Q&A. 

CC @nicc 
","[('jasongitmail', 'auction?'), ('jasongitmail', 'Accepted idea: voting with access gated by an email oracle'), ('nicc', 'Indirectly Irresponsible Individual: @Trivo25 and @jasongitmail '), ('mitschabaude', 'Done! :D')]"
727,Release 0.9,mitschabaude,closed,"* merge berkeley into main (should be quick, because mina was just merged to berkeley)
* sort out the clear mina side branch that corresponds to the new `main` (should be compatible with testnet & snarkyjs and be able to merge to `release/2.0.0`
* add missing stuff to changelog
* bump version","[('nicc', ""Indirectly Irresponsible Individual: @mitschabaude \n(Gregor, if you end up taking this work on then let me know and we'll find someone else)"")]"
726,Investigate memory consumption of workers,mitschabaude,closed,,"[('mitschabaude', ""here are some statistics of memory consumption with different # threads.\n```\n#threads | baseline memory (MB) | +compile/prove | DEX (compile x3)\n-------------------------------------------------------------------\n 1  300    X    X\n 2  500 1100 2400\n 4  800 1600 2800\n 8 1500 2300 3400\n16 3200 3400 4600\n```\n\nNote:\n* #threads = #workers + 1, because the main thread is running as well\n* Baseline = memory consumption when sleeping after importing snarkyjs\n* Compile/prove isn't working with 0 workers, that's why numbers in the first row are missing"")]"
725,`parseFetchedAccount` fails to fetch account details in case if SC was deployed,shimkiv,closed,"Checked with [Mina](https://github.com/MinaProtocol/mina/tree/test/berkeley-test-feb-10) and [SnarkyJS](https://github.com/MinaProtocol/mina/tree/merge-release-develop)

---

Account fetching fails on this one: https://github.com/o1-labs/snarkyjs/blob/52bd53245cbbf20cd553e1aba10fcfad14baa78b/src/lib/fetch.ts#L251

```shell
Fetching account details...
Something went wrong. Error: Type ""undefined"" cannot be converted to a field element
    at raise_error (/nix/store/bgdmsbs4z200hmhhspk4c8igmzfpg26n-js_of_ocaml-compiler-4.0.0/lib/ocaml/4.14.0/site-lib/js_of_ocaml-compiler/runtime/jsoo_runtime.ml:110:3)
    at t14 (/workspace_root/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml:130:11)
    at caml_call_gen (/builtin/+stdlib.js:32:12)
    at /builtin/+jslib.js:252:14
    at new eval (eval at caml_js_eval_string (/builtin/+jslib.js:328:42), <anonymous>:4:26)
    at Class (file:///Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/src/snarky/proxy.js:11:14)
    at parseFetchedAccount (file:///Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/src/lib/fetch.ts:251:13)
    at fetchAccount (file:///Users/shymkiv/projects/o1/mina/src/lib/snarky_js_bindings/snarkyjs/src/lib/fetch.ts:73:18)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async fetchAccountDetails (file:///Users/shymkiv/projects/o1/zkApps/e2e-zkapp/e2e-zkapp-ui/utils/ZkAppUtils.ts:325:22)
    at async file:///Users/shymkiv/projects/o1/zkApps/e2e-zkapp/e2e-zkapp-ui/routes/api.ts:157:20
Error: Type ""undefined"" cannot be converted to a field element
    at fetchAccountDetails (file:///Users/shymkiv/projects/o1/zkApps/e2e-zkapp/e2e-zkapp-ui/utils/ZkAppUtils.ts:332:11)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
    at async file:///Users/shymkiv/projects/o1/zkApps/e2e-zkapp/e2e-zkapp-ui/routes/api.ts:157:20
```","[('mitschabaude', 'This includes adding a deriver for the account type, so it stays in sync'), ('nicc', 'Indirectly Irresponsible Individual: @Trivo25 ')]"
723,Review assertion error messages for clarity,jasongitmail,closed,"**Problem:**
It sounds like current assertion error messages are very unclear, enough that this should be prioritized. https://github.com/o1-labs/docs2/pull/264#discussion_r1103067405 

**Proposed Solution:**
Let's have a few people review these for clarity. 

Could someone add a link to the default assertion error messages please? ","[('mitschabaude', 'the errors for stuff like `field.assertEquals(other)` (without a custom message) get thrown from OCaml:\r\nhttps://github.com/o1-labs/snarky/blob/ff2631f47bb644f7a31fd30be16ee0e5ff5279fa/src/base/checked.ml#L84'), ('mitschabaude', 'As soon as we implement the `Field` class in snarkyjs we can catch and throw with a different message'), ('mitschabaude', 'Another topic are the errors coming from transaction application (recent discussion: https://github.com/o1-labs/docs2/issues/263). For those, we started a file where we can add handlers for each to add an explanatory message (and link!).\r\nSo far it contains only one handler:\r\nhttps://github.com/o1-labs/snarkyjs/blob/e9779b80d6ad8f4019355c03d12d3c3334e4b2b6/src/lib/errors.ts#L7-L8')]"
721,RFC: Quickcheck-like testing in snarkyjs,mitschabaude,closed,"## Motivation

In order to ensure that critical operations like signing transactions with mina-signer work correctly, we need to include test cases with a wide diversity of different examples (https://github.com/o1-labs/snarkyjs/issues/712), including negative tests for invalid examples.

We could keep writing these test cases by hand:
https://github.com/o1-labs/snarkyjs/blob/756733f8e5edc91d2f84d36e9c4dc77001c2c9ac/src/mina-signer/src/test-vectors/accountUpdate.ts#L6-L12
But that comes at a cost:
* Since the structures that should be tested -- various kinds of transactions -- are very large, creating non-trivial examples takes a lot of time and code.
* Some of the structures (zkApp transactions) change frequently. Every time this happens, hard-coded examples need to be updated. This would be extremely annoying if we had more than 1-2 hand-written examples.

This RFC proposes a **solution to the problem of testing a large variety of transactions in an automated way.**

## Proposal: Home-grown quickcheck

> This proposal is partially implemented here: https://github.com/o1-labs/snarkyjs/pull/718

We propose to add our own framework for specifying random generators of complex structures. This builds on two observations:

1. Transactions are built out of only a handful of simple ""leaf"" types, like ""uint64"", which are combined in arrays and records. 
2. It's easy to create random generators for the leaf types
3. With the right API, it becomes easy to combine leaf random generators into generators for higher-level structures. In part, this can even be automated because we have a system of auto-generating a description of the structure of some complex types, from OCaml code: https://github.com/o1-labs/snarkyjs/blob/756733f8e5edc91d2f84d36e9c4dc77001c2c9ac/src/provable/gen/js-layout.ts

The core random generator type looks like this:
```ts
type Random<T> = { next(): T };
```

Example simple implementation for a boolean:
```ts
const boolean: Random<boolean> = { next: () => Math.random() > 0.5 };

// or, slightly prettified using a constructor
const boolean: Random<boolean> = Random(() => Math.random() > 0.5);
```
(note: our actual implementation exclusively uses secure randomness instead of `Math.random()`)

Example for what combining generators can look like:
```ts
// some combined type
type AccountBalance = { address: PublicKey, balance: Uint64 };

// generator for combined type
const AccountBalance: Random<AccountBalance> = Random.record({
  address: Random.publicKey,
  balance: Random.uint64
};
```

Creating random examples just means calling `.next()`:
```ts
let example = AccountBalance.next();
```

Examples of useful combinators are `record`, `map`, `array`, `oneof`, `constant`, `reject`. All of them are trivial to build.

Generators for types like public key, are easy to build on top of our existing custom cryptography:
```ts
let privateKey = Random(PrivateKey.random);
let publicKey = map(privateKey, sk => PrivateKey.toPublicKey(sk));
```

Important consideration: Often, great testing value comes from checking a few typical edge cases, like a 0, or the max uint64, or an empty array. Therefore, core generators are carefully built to produce a number of special values with much increased probability.

For positive numbers, we will typically use a log-uniform distribution, where a number of size $2^n$ has a similar probability to be generated, for every `n`. In other words, small values are much more likely than large ones.

Here are some interfaces we propose for generating positive numbers:
```ts
nat(10); // positive number from 0 to n, bias towards special values like 0, 1, n; log uniform
uint32, uint64; // log uniform positive bigints with predefined max value; bias for special values
field, scalar; // special range that fits our finite fields; bias for special values; otherwise, _uniformly_ distributed (not log) as is typically the case for hashes etc
```

Structures like arrays take a size parameter which can be either a number or -- more useful -- a number generator:
```ts
array(field, nat(1000)); // array of field elements, of size up to 1000
```

Note that because of the log uniform distribution, most generated arrays will be small, even if we allow a fairly high max value like 1000. The bias towards values like 0 in `nat` ensures that empty arrays will be among the generated cases, which is always useful.

### Test runner

The core need outlined above is basically covered by only having generators for transaction structures in place. However, it's only a small step from there to add a convenient test runner which will check assertions against 10-100 random examples:

```ts
test(publicKey, (pk, assert) => {
  let g = PublicKey.toGroup(pk);
  assert(Group.isOnCurve(g), ""public key can be converted to a valid curve point"");
});
```

Proposal: the test runner just tries to be smart and run at least 10 tests (or 20?), then check how long the tests took, and if its fast enough to fit in 100ms, runs up to 100 tests.

> Remark: currently, our `assert` is much less polished than something like `expect` (from Jest, but available stand-alone), which is able to display deep diffs between objects in a pretty way. We plan to often just use a good solution like expect inside a `test` run. Throwing an error is equivalent to failing an assert: the test is stopped and the counter-example printed, along with the error / assert message

It should also be possible to specify hand-picked test cases that have to be used with 100% probability. The intention is to achieve this via the normal `Random<T>` interface, by specifying a generator that is guaranteed to generate some specific values first. Example for a test where we definitely want to test an all-zeros array, and an all-ones array:

```ts
let array_: Random<bigint[]> = withHandPicked(
  array(uint32, nat(10)),
  [0n, 0n, 0n],
  [1n, 1n, 1n]
);

test(array_, (...));
```

### Invalid cases

We propose a pattern where most of the core types have generators for invalid values (like, out of range for numbers) attached right next to them:

```ts
Random.uint64 // valid uint64
Random.uint64.invalid // numbers out of uint64 range
```

Combinators like `array` and `record` will have an ""invalid"" version where they intelligently generate just _slightly_ invalid examples, like a record where _one_ of the fields has an invalid value. This is typically much more useful than testing cases where all values are invalid. They can do so by inspecting the opional `.invalid` property of their input generators.

If we want fine-grained control over the type of invalidity we are testing, of complex structures, this will be easiest to achieve with `map`:

```ts
const InvalidNonceAccountUpdate = map(AccountUpdate, Random.uint32.invalid, (update, nonce) => {
  update.body.preconditions.account.nonce.value = { lower: nonce, upper: nonce };
  return update;
});
```

The test runner is planned to support a runner for negative tests where every input is expected to either throw or fail some assertion:

```ts
// only succeeds if _each_ test case ends negative (throws or exhibits a falsy assert)
testNegative(Random.signedPayment.invalid, (payment, assert) => {
  assert(verifyPayment(payment));
});
```

## Alternative approaches

Two main alternatives emerged during the research on this problem:

- Building on top of a well-designed quickcheck-style library: https://github.com/dubzzz/fast-check
  - Pro: battle-tested, includes convenience capabilities that we won't implement, like shrinking and replayable seeds.
  - Con: harder to specialize towards our needs than home grown solution
    - integration with derivers is an unknown
    - custom generators like `publicKey` would have to be built by extending [a complex class](https://github.com/dubzzz/fast-check/blob/c96b3f49317fa588fca852b5671827fdb2fe8d11/src/check/arbitrary/definition/NextArbitrary.ts#L12)
    - invalidity testing that's useful for us doesn't seem to be built in
  - Con: scope way beyond what we need, at the cost of complexity
  - Conclusion: the pros are just nice to haves; the cons are too expensive

* Exposing [existing quickcheck generators](https://github.com/MinaProtocol/mina/blob/f95214174fad14e6f221ab8a946f6b280ed5757e/src/lib/mina_generators/zkapp_command_generators.ml#L1507-L1509) for transactions from OCaml, and using those
  - Pro: battle-tested
  - Pro: already solved the non-trivial problem of generating transactions that are valid / invalid (from the point of view of the tx logic)
  - Con: additional work of writing and maintaining bindings
    - converters from and to JS values for each operation
    - maintain matching types on the TS side (types / nice to use surface is often > half the work)
  - Con: loses the fast iteration speed and easy remixability of a JS solution
    - new binding for new generator; new binding for new combinator; instead of just `let newStuff = map(something, () => {..})`
  - Con: harder to parse stack traces; much harder to debug when test fails  
  - Con: overhead cost of separate repo, seperate language, separate build step, separate branches
  - Conclusion: cons are too costly of justifying for simple immediate use cases like mina-signer (where transactions don't need to be valid against tx logic). We want a JS solution either way for quick iteration, arbitrary use cases.
    - Could be handy if more complex use cases are needed and turn out to pose difficulties when implementing in JS
   ","[('mitschabaude', ""Update: I think I'll tweak the generator interface to implement a way to reset / start or to create a fresh instance, in order to implement generators with memory -- like those that generate a fixed set of examples first""), ('mitschabaude', 'Open question re: invalid testing:\r\n\r\nIs it enough to test invalid cases which have the _correct type_? Or should there be a mode of passing in random garbage instead of values with the proper type? Almost like a fuzzing mode?'), ('nicc', 'This is very helpful! 🤸\r\n\r\nMy reflexive response is that we shouldn\'t reinvent this wheel but you do make a solid argument for building a new thing. I would love to hear what others think about the ongoing effort to build and maintain it.\r\n\r\nAnecdotally, I’ve had terrible experiences leaning into generative testing just because I thought it was cool. I don\'t mean to suggest that we\'re doing this here! I just want to share my mistakes 😅 ...\r\n\r\nThe main issue I experienced was that we weren\'t careful with the kind of tests that required generated data. We used it everywhere and it became a huge pain to generate sequential interactions that made sense and actually tested the flows we were after. We\'d constantly generate something, then have to write a bunch of very specific functions that generated a second thing based on the first, and so on. Of course this can be done properly or at least better than we did it, we just stumbled into it without realising there\'s a fair amount of domain modelling to be done. So we unded up reusing the actual generators but still had this proliferation of interdependencies between generated values and it became a huge hassle to constantly constrain the generators on a case-by-case basis to exercise the top-level use cases we were after. It certainly wasn\'t a case of ""let the test suite generate test cases for you, yay"". I suspect this was due to using generated data for high-level tests without properly building a kind of ""domain simulator"". Unit-level tests were a lot easier.\r\n\r\nTo be fair, that was in untyped languages. I suspect that something like quickcheck works because it leverages a solid type system to lift you into this property-based assertion at the function level - e.g. reverse reverse. I think there\'s a notable difference between that - declaring properties such as invariants on functions - and hand-crafting tests of indeterminate scope using generated data. So I do worry about the maintainability of passing individual generators into a higher-order function where you wire up a test by hand. Mostly for the reasons stated above - actually generating usable data _sets_ as required by high-level tests can become a whole little domain model on its own.\r\n\r\nDo we have a sense of which kinds of tests would use generators and which ones would not? I think that would help me assess this decision.'), ('mitschabaude', ""Thanks @nicc, these are some very interesting learnings! Definitely the kind of global, domain-specific interdependencies needed in complex structures like transactions where on my mind since I started this, and I came to a clear picture about the small amount of domain modelling that will be needed for my immediate use cases in mina-signer. Similar to what you described, I anticipate this to be done in a custom `map` function where we override some of the initial (naive, locally-random) fields with good values. For signing tests, this only has to be done for a single account update field (callDepth), as far as I'm aware.\r\n\r\n> Do we have a sense of which kinds of tests would use generators and which ones would not? I think that would help me assess this decision.\r\n\r\nI think given your experiences, we should be mindful of when to use this -- specifically in cases where we need many _examples_ but not too many / too complex operations on those. It could also be that sometimes we only want to uses generated values and not the test runner.\r\n\r\nThere are two kinds of tests where I definitely want to use them right away:\r\n* generating many examples of simple transactions: payments / stake delegations\r\n* generating many examples of zkapp transactions\r\n\r\nIn both cases, the main use cases are to check that\r\n* hashing / signing these is consistent between different implementations\r\n* invalid inputs are rejected with the expected error\r\n\r\nBut I can think of other use cases right away as well, like\r\n* low-level crypto tests where the generated values are elliptic curve points and field elements\r\n  * this is classic property testing. like, we check that some expected algebraic law holds\r\n  * for things like this, there's no big advantage over what we do now, it's just a more convenient syntax for running something on many random examples\r\n\r\n> I think there's a notable difference between that - declaring properties such as invariants on functions - and hand-crafting tests of indeterminate scope using generated data.\r\n> ...\r\n> actually generating usable data sets as required by high-level tests can become a whole little domain model on its own.\r\n\r\nI thought that quickcheck has pretty much the same problem - that its hard to craft useful data sets / generators for complex processes.\r\n\r\nI pondered making the API more like quickcheck (input == function that returns a boolean, instead of an arbitrary function which can do arbitrary checks), but it's just less flexible and would incur a higher cost of generating inputs, because you need to run many small tests, each with many inputs. (note - generating some of our inputs, like public keys, is quite costly)""), ('mitschabaude', ""TL;DR - there are some use cases where we definitely need the random generation (for variety and maintainability of the tests).\r\n\r\nAnd apart from those, we don't need to lean into this framework where it doesn't have a clear purpose""), ('mitschabaude', ""Updated type interface which allows random generators with memory (https://github.com/o1-labs/snarkyjs/pull/718/commits/5e9c5a95fe29f341ca93ab4333a73a2babb95559)\r\n```ts\r\ntype Random<T> = { create(): () => T }\r\n```\r\nthere's one more layer of function call: the `create()` function creates one instance of the generator. The instance is just a function that returns values, like the `next()` function before.""), ('mitschabaude', ""Update: this RFC can now be viewed in full action in a test where random payments and delegations are tested: https://github.com/o1-labs/snarkyjs/pull/718/commits/d0f009741578b59278114ddcb4070e80ceec972b\r\n\r\nFun fact: This test would have caught the same bug (binprot serialization of numbers) that Joseph caught during the mina-signer audit. (I had to cherry-pick the binprot fixes to make it work.) The bug would've been uncovered not by writing any new test logic, but just by auto-generating a wider variety of inputs than we had previously hard-coded. Which demonstrates the point of doing all this pretty well :D""), ('nicc', 'Thanks @mitschabaude, this is sounding good. Hope I haven\'t kept you waiting on a reply!\r\n\r\n> we should be mindful of when to use this -- specifically in cases where we need many examples but not too many / too complex operations on those\r\nVery much agreed and this makes me a lot more comfortable with the approach. This is a matter of discipline, which is easy to say and harder to do so we should just remember this decision and be willing to pull back on generative tests early if we see signs that it\'s becoming cumbersome.\r\n\r\nI also like the examples you gave. That seems like appropriate use of generative testing to me.\r\n\r\n> I thought that quickcheck has pretty much the same problem - that its hard to craft useful data sets / generators for complex processes.\r\nThat\'s interesting! I guess it substantiates that the real focal point is the scope of the test. Type-inferred generators allow us to declare properties about functions more  directly / more ""functionally"" but it\'s really about the volume and interdependence of data where things go wrong. A hypothesis anyway. Very interesting.\r\n\r\nLet\'s go ahead with it on the understanding that we keep an eye on the things we\'ve surfaced here. I\'ll approve the PR and link back to this. Thanks Gregor!\r\n'), ('bkase', ""I think we'll need another mini-RFC before we go forward re-implementing the quickcheck generators for zkapp transactions given the pain the protocol team went through to build valid generators for those. Is that alright @mitschabaude ?""), ('mitschabaude', ""> I think we'll need another mini-RFC before we go forward re-implementing the quickcheck generators for zkapp transactions given the pain the protocol team went through to build valid generators for those. Is that alright @mitschabaude ?\r\n\r\n@bkase yes, I can describe that in a small paragraph, or show it with code.\r\nBut the answer is, the protocol team had much more complex needs: generating sets of valid transactions that each pass the tx logic and can be applied to a ledger.\r\nOur need for mina-signer is just that the transactions have to be syntactically correct on a basic level. The signing code doesn't check any preconditions or balances.\r\n\r\nTherefore, our needs can be addressed very easily, but an RFC might be warranted if we'd want to use the framework for complex testing like the protocol team.""), ('nicc', ""Thanks @bkase, good call. I can buy into the rationale that it's reasonable to generate simple, isolated transactions within mina-signer tests but duplication of any significant complexity would definitely present a problem. Very much agreed that we should take note of input from the protocol team""), ('jspada', 'This sounds like extremely useful work.  There are two things that I think are important requirements, which may already be covered, but I will note them just in case\r\n* Special common test cases such as `zero`, `max`, `max + 1` should always be covered.  We do not want to leave it to randomness that these tests are present and could (even with very low probability) be missing.\r\n* All tests should be easily reproducible to the developer should any of them fail.'), ('mitschabaude', ""Closing this because it's implemented!"")]"
720,Build in replay protection for userland signatures?,mitschabaude,open,"Attack scenario:

zkApp guards some high-stakes action (like, paying out funds / voting) by requiring a signature from authorized users as input, and verify that signature. It will verify that
* the public key on the signature matches the authorized user (which could be encoded in various ways, like hard-coded constant, on-chain state, leaf of a Merkle tree,...)
* the signed message specifies the respective action

Two problems:
* Signatures are deterministically derived from the message
* and don't distinguish between different networks

So if you create a signature for a high-stakes action, and send it to me to include in a proof, that means I use it any number of times as proof input. For example, if your signature authorizes me to withdraw amount X to address Y, I could withdraw X to Y an infinite number of times.

In the case you have the same account address on testnet / mainnet, then your testnet signature could even be used to withdraw real mainnet funds.

**Should we build in automatic defense against cases like that?**

Ideas:

@ replay on different network:
* automatically include the network type in the signature, and also hard-code it into every smart contract, such that our tooling (zk deploy) sets the right constant when deploying to either network
* tag generated private keys with the network type, so that wallets can reject it if you want to restore a wallet for the wrong network

@ replay on the same network:
* provide an interface that makes it easy for wallets to pass in the user's account nonce as an argument which becomes part of the message, plus an interface in snarkyjs that makes the circuit compare that nonce to the signer's account nonce and do a nonce increment on that account
",[]
719,investigate and improve apple silicon performance,Trivo25,closed,"during the last office hours, we have received complains about degraded (or rather no improvement at all compared to before the original fix https://github.com/o1-labs/snarkyjs/pull/683) apple silicon performance in snarkyjs 0.8.0

another nice-to-have could be benchmarks that users can run, potentially baked in to the zk cli","[('jasongitmail', ""@Trivo25 If you're able to contact these devs, can you ask them to provide the output from `zk system` please? To add to this issue""), ('maht0rz', ""here's my `zk system`:\r\n\r\n```\r\n✗ zk system\r\nPlease include the following when submitting a Github issue:\r\n\r\n  System:\r\n    OS: macOS 13.0\r\n    CPU: (10) arm64 Apple M1 Max\r\n  Binaries:\r\n    Node: 17.8.0 - ~/.nvm/versions/node/v17.8.0/bin/node\r\n    Yarn: 1.22.17 - /usr/local/bin/yarn\r\n    npm: 8.5.5 - ~/.nvm/versions/node/v17.8.0/bin/npm\r\n  npmPackages:\r\n    snarkyjs: ^0.8.0 => 0.8.0 \r\n  npmGlobalPackages:\r\n    zkapp-cli: 0.5.4\r\n```\r\n\r\n\r\nWe've tried proving worlde or some other zkApp with Jack at the last office hours and we found out the performance was still degraded.""), ('Trivo25', 'seems like bindings got overwritten '), ('mitschabaude', 'hm, I would like to understand this. in `main`, the changes are in the bindings -- search for `get_efficient_num_workers` in this file: https://raw.githubusercontent.com/o1-labs/snarkyjs/main/src/node_bindings/snarky_js_node.bc.cjs'), ('Trivo25', ""If i am not mistaken the bindings weren't up to date with the fix with the state from release 0.8.0 (which they should have) - but they are now https://raw.githubusercontent.com/o1-labs/snarkyjs/c5a36207a7d345d4b96038569d7db66101ec07cd/src/node_bindings/snarky_js_node.bc.cjs so it seems like a PR remove the fix and another one after that re-added the change - probably some out of sync work on the Mina side ""), ('Trivo25', 'Just confirmed my assumption. Tested by looking for the added code snippet in the bindings `get_efficient_num_workers` as well as running a handful of tests on my M2 from release tag 0.8.0 and main - version 0.8.0 shipped without the fix but the next update will have the updated bindings')]"
715,Consolidate snarkyjs tests: move `tests` folder to proper node package,mitschabaude,closed,"**Why**: The snarkyjs unit test recently was very flaky in CI (https://buildkite.com/o-1-labs-2/mina/builds/27032#01862744-d9f3-48be-97f4-cfd19132c88e). This is wasting engineering time.

Could be easily fixed by moving tests in `snarky_js_bindings/test` to within snarkyjs, for example. Or possibly delete them as far as they are redundant","[('mitschabaude', 'this solved itself with https://github.com/MinaProtocol/mina/pull/12949')]"
713,Build a simple browser wallet,mitschabaude,open,"This might be a bit out there, but: I really think it would be helpful for O1 to maintain its own, _simple_ browser wallet which supports zkApps.

**The goal**: Have a reference implementation of the snarkyjs - provider - wallet - mina-signer flow which is
* tested in our CI along with changes in our codebase
* updated in sync with snarkyjs releases
* serves as a working fallback for developers who struggle testing their zkApps in other wallets

**Non-goal** is to provide a nice UX and publish something polished for end-users. This would be a developer tool and reference implementation to help maintainers of proper wallets, like Auro.","[('jspada', 'I like this idea.  Having a reference implementation could help 3rd parties develop their own implementations.  It could also be a good testing ground for us to see if our own APIs are sensible and smooth for those wishing to implement wallets.')]"
712,Address mina-signer audit,mitschabaude,closed,,"[('nicc', 'Indirectly Irrersponsible Individual: Joseph')]"
711,Dummy vk for good DX with proofs disabled on berkeley,mitschabaude,closed,"As of now, in snarkyjs there's a mode `proofsEnabled: false` for testing, where we put dummy proofs on account updates, and don't check the proof before applying it to the local ledger. So far, when using this mode you also didn't have to store a verification key on the account, so you saved the time to compile your contract. The zkapp_command_logic accepted it if there was `authorizationKind: Proof` even without a vk on the account.
However, with [this change](https://github.com/MinaProtocol/mina/pull/12380), that won't be possible - zkapp_command_logic will enforce that there's a vk in the account, matching the vk hash.

So for local testing it'd be nice to have a dummy vk plus hash which is set during compile automatically if you haven't compiled your contract, and `proofsEnabled = false`. I assume such a dummy vk plus hash should be easy to add to the ocaml bindings.","[('Trivo25', 'fixed via #724 closing manually')]"
709,mina-signer delegation result unexpected,psteckler,closed,Using mina-signer's `signStakeDelegation` produces a result that looks like a payment without the amount. It does not contain the expected fields `delegator` and `newDelegate`.,"[('mitschabaude', 'The input/output type of `signStakeDelegation` looks as follows:\r\n```ts\r\ntype StakeDelegation = {\r\n  to: PublicKey;\r\n  from: PublicKey;\r\n  fee: UInt64;\r\n  nonce: UInt32;\r\n  memo?: string;\r\n  validUntil?: UInt32;\r\n};\r\n```\r\nAs far as I can see, this exactly matches the GraphQL API which defines the `sendDelegation` query as follows:\r\nhttps://github.com/MinaProtocol/mina/blob/f6756507ff7380a691516ce02a3cf7d9d32915ae/src/lib/mina_graphql/mina_graphql.ml#L2771-L2778\r\n\r\nIn both cases, the fields that define the newDelegate / delegator are ""to"" and ""from"". I think it\'s right that mina-signer matches the GraphQL API (because wallets will take a result from mina-signer and post it to the API).\r\n\r\n@psteckler does this answer the issue? Or should we open another one to change the GraphQL API + mina-signer?'), ('psteckler', ""I suppose it's OK, I was expecting it to match the output in `app/client_sdk/client_sdk.ml`."")]"
707,Literal BigInt is not supported on react-native,chezhe,open,"Literal BigInt is not supported on react-native, better get rid of them like Aptos https://github.com/aptos-labs/aptos-core/pull/3943","[('mitschabaude', ""I think bigint literals are important. If this was the thing preventing snarkyjs to work in RN, then I'd look into transpiling the literals away; possibly on the RN build pipeline and not here.\r\n\r\nHowever, AFAIK, Wasm and web workers are not supported in React native, which prevents any chance for snarkyjs running in RN, so this doesn't seem relevant right now?""), ('chezhe', 'For me, I am using `mina-signer` package in my react-native project, it contains BigInt literals and cannot be compiled on react-native. If `BigInt(0)` is same with `0n`, and it can runs on more platforms, it will be a better choice in coding.\r\n\r\nOr maybe the BigInt literals can be transformed with babel after build.'), ('mitschabaude', ""That's a great point @chezhe. We want mina-signer to be compatible with RN. Yeah maybe you can try to transform them with babel or another tool in your build""), ('chezhe', ""I tried to change all BigInt literals into BigInt(n), but I don't know how to transform \r\n```\r\ntype Bool = 0n | 1n\r\n```\r\n`|` can not be assigned to `BigInt`.""), ('mitschabaude', 'Cool! You could transform `0n | 1n` to `bigint`')]"
706,Support advanced account updates (prover bug reloaded),mitschabaude,open,"The DEX prover fails when witnessing a proper account update layout. The error that's thrown is the same as the one we resolved here: https://github.com/o1-labs/snarkyjs/issues/498

A peculiar thing about this error is that it's thrown from a completely unexpected place, which gives no info at all about what to debug.

Last time when we resolved this error in snarkyjs, it was caused by a compile vs prover discrepancy in a part of snarkyjs that's complex and not tested well. I assume the same is the case now.

The same type of error was also reported by two community members (@maht0rz and @rpanic), and afaik was resolved by fixing something in their code.

There are two tasks here:

**Task 1**: resolve the concrete error occurring in the DEX, by finding the concrete compile vs prove discrepancy and adding thorough tests for the involved snarkyjs internals. This is product-eng work.

**Task 2**: Investigate why this (likely) compile/prove discrepancy is ending up as an error in a seemingly unrelated part of Pickles. Add invariant assertions to make sure snarky or Pickles catch this error earlier and are able to tell the users that something is wrong with their circuit. Make snarky robust enough so that problems in one circuit cannot leak 'outside' of it and mess up a different part of the proving process. This is crypto work, and captured separately in the following issue: https://github.com/o1-labs/snarkyjs/issues/629

How to reproduce:

- check out `snarkyjs/main`, run `npm i` and `npm run build`
- Comment out the line of code after this comment, and instead uncomment the block of code directly below it (see all-caps comments) https://github.com/o1-labs/snarkyjs/blob/52ec32befaf7d4364ca8e71ebb4c3b73ed182afd/src/examples/zkapps/dex/dex.ts#L434
- run the following:
```
./run src/examples/zkapps/dex/happy-path-with-proofs.ts --bundle
```",[]
704,Add nice ways to inspect and understand circuit gates,mitschabaude,open,"follow-up to #668. we now can get a list of gates from each smart contract methods, but these are huge and hard to interprete",[]
701,Simplify mina-signer API,mitschabaude,closed,,[]
696,Replace panics with Results in the Rust bindings for much more descriptive failures,bkase,closed,"via @mrmr1993  There's a 2 line change to the WASM bindings which will give you a descriptive error instead of panicking when proving fails.

Make https://github.com/MinaProtocol/mina/blob/a3661e44e01b2c400d6eb5ac254c6ab7a91b3623/src/lib/crypto/kimchi_bindings/wasm/src/plonk_proof.rs#L551 return a Result<WasmProverProof, JSValue>
Change https://github.com/MinaProtocol/mina/blob/a3661e44e01b2c400d6eb5ac254c6ab7a91b3623/src/lib/crypto/kimchi_bindings/wasm/src/plonk_proof.rs#L612 to return maybe_proof.map_err(|str| str.into()) (or something like that), which will make it return the error as a JS exception

Additionally, https://github.com/MinaProtocol/mina/blob/a3661e44e01b2c400d6eb5ac254c6ab7a91b3623/src/lib/crypto/kimchi_bindings/wasm/src/plonk_proof.rs#L585","[('nicc', '@nicc chat to Jo about whether zkApps Prod Eng. should be doing this'), ('nicc', ""For now zkApps Product should hold off and not implement this. It's likely to be a crypto thing. Will confirm""), ('jasongitmail', '@nicc Following up on your last comment. I believe the comment is out of date and Product Eng can pursue this, is that your current understanding too? '), ('jasongitmail', '@mitschabaude  thinks this can likely be closed. Will confirm with crypto team first'), ('mitschabaude', ""The line `Err(JsValue::from_str(err.to_string()))` makes wasm-bindgen throw a string. It's definitely better to throw a JS `Error`, which `panic!` seems to do as well. So we should do something like `Err(JsError::from(...))`""), ('mitschabaude', 'This is how it should be done:\r\n```rust\r\nreturn match maybe_proof {\r\n    Ok(proof) => ...,\r\n    Err(err) => Err(JsError::from(err))\r\n}\r\n```'), ('mitschabaude', 'Or like this:\r\n```rust\r\nErr(str) => Err(JsError::new(str)),\r\n```')]"
695,Add OCaml source maps to our production build,bkase,open,"via @mrmr1993  has reported that source maps for him on the js-of-ocaml bits ""just worked"" -- this would be a huge improvement over the garbled exceptions (though of course, still not being sufficient)

For the sourcemap:

dune docs `((js_of_ocaml (flags --source-map-inline)))`
js_of_ocaml --help includes:
```
       --source-map-inline
           Inline sourcemap in the generated JavaScript.

       --source-map-no-source
           Do not inline sources in source map.

       --source-map-root=VAL
           root dir for source map.

       --sourcemap, --source-map
           Generate source map.
```
which can be passed in that dune stanza

",[]
694,Draft mini RFC for SnarkyJS API to expose ECDSA/Keccak gadgets,bkase,open,"Initially the crypto team is going to expose these gadgets to SnarkyJS via OCaml bindings with the plan to push them down to the Rust layer later.

Foreign fields are triples of native fields which we should make opaque at the SnarkyJS layer.

Sometime in the latter half of May, crypto team should be able to provide stub APIs to work towards in SnarkyJS in order to parallelise the work.

Since this exposes the ability to prove a new thing, it would entail exposing a new surface area to the SanrkyJS API. As such, we can prepare by putting together a mini RFC that determines the API, interaction flows and test plan.

The feature essentially allows SnarkyJS to prove with an ECDSA signature that the signer owns a particular ethereum address. What does that look like in SnarkyJS? How would it fit into an interaction flow within a UI? 

PRD for primitive support can be found [here](https://www.notion.so/minaprotocol/Ethereum-Primitives-Support-PRD-d89af720e1c94f7b90166709432e7bd5).","[('stevenpack', ""@nicc pushing this higher in the backlog for discussion next sprint planning.\n\nECDSA verification is blocking some of the more promising commercial / large scale uses of SnarkyJS. I tried to get a handle on all the moving parts here: https://www.notion.so/minaprotocol/Ethereum-Primitives-Dependencies-21e56244b1cd43b1807aac39fdd25117?pvs=4\n\nIt sounds like there are 2 things for Product eng. here:\n\n1)  Expose to SnarkyJS (item 3 in the doc)\n2) Consume in SnarkyJS (item 5 in the doc).\n\nIf I got it right, 5) is a no-brainer for Product Eng, but it sounded like there was a chance to parallelize if Product eng could item 3, with crypto team providing a 'stub API' to work off, so the two streams could happen in parallel.\n\ncc @bkase "")]"
690,Publish RFC on design for retrieving actions and events from archive node,nicc,closed,"In order to retrieve actions and events from the archive node
We need to circulate an RFC on the proposed design

The PRD can be found [here](https://www.notion.so/minaprotocol/Archive-Node-API-PRD-b337b18c6f3d4b16bf213090db36d744). This should cover all requirements.

This issue will be complete when the RFC is made public.","[('nicc', 'RFC has been drafted in Notion ( @nicc to link ).\nOutstanding:\n- @jasongitmail to review and text Martin about publishing\n- put in github somewhere\n- communicate to community'), ('nicc', 'Indirectly Irresponsible Individual: @bkase '), ('nicc', 'Duplicated by [this issue](https://app.zenhub.com/workspaces/zkapps-product-eng-6130fedb3b0fc600123d8796/issues/gh/o1-labs/archive-node-api/9). Closing')]"
688,Fetch actions (from Archive Node API),jasongitmail,closed,Related: https://github.com/o1-labs/snarkyjs/issues/606 ,"[('nicc', 'Indirectly Irresponsible Individual: \n- @bkase if Martin does the work\n- @MartinMinkov if someone else does')]"
684,Improve error seen by dev when invalid_fees_excess occurs,jasongitmail,open,"We've had a couple user reports of a confusing error message when transaction fee is insufficient. E.g.

> Error due to the cost when deploying a smart contract to testnet aren't really helpful to tell me what to fix when it happen. ( ex: invalid_fees_excess ? where ? what to fix ? no idea, but I eventually found something )

Any ideas why this is occurring? Is the fee calculation method incorrect? Once the SnarkyJS side is improved, we should discuss how to better expose this via the zkApp CLI too.",[]
678,Mina-signer: match the old interface 1:1 and prepare publishable package,mitschabaude,closed,Completing this will also close #611,[]
677,Mina-signer: implement base58 check,mitschabaude,closed,"Remove the OCaml dependency for base58 check. Instead, either use a third-party library (if one exists) or implement base58 check on top of existing building blocks",[]
676,Require the type argument in `Circuit.if`,mitschabaude,open,"Currently, this is the function signature for `Circuit.if`:

```ts
declare class Circuit {
  static if<T>(b: Bool | boolean, ctor: ProvablePure<T>, x: T, y: T): T;
  static if<T>(b: Bool | boolean, x: T, y: T): T;
}
```

It optionally takes a ""provable"" (the `ctor`) which it needs to get the `.toFields` and `.fromFields` methods of its inputs `x`, `y`. If this `ctor` is left out, `Circuit.if` tries to find `.toFields` and `fromFields` as instance methods, and if that fails it tries more fallbacks which basically won't work.

The second function signature clashes withthe design of  `Struct`, where Structs are intended to be equivalent to plain JS objects, and therefore don't have instance methods like `.toFields` on them. This essentially blocks moving to `Struct` with most of our custom types: In all our other major APIs besides `Circuit.if`, we already require a separate argument for the type (example: `Circuit.witness`).

**Proposal**

Deprecate the second function signature (without `ctor`), and make the first one the documented one:

```ts
declare class Circuit {
  static if<T>(b: Bool | boolean, ctor: ProvablePure<T>, x: T, y: T): T;
  /**
  * @deprecated use this function with an explicit type argument, for example:
  * ```
  * Circuit.if(someBool, Field, x, y);
  * ```
  */
  static if<T>(b: Bool | boolean, x: T, y: T): T;
}
```",[]
675,"Move the `Circuit` class to JS, in part as a wrapper",mitschabaude,closed,"Right now, the `Circuit` class is created in OCaml: https://github.com/MinaProtocol/mina/blob/3faca1de030be8c43212cd3d59dd065164f511e2/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L1593

Subsequently it is heavily monkey-patched in snarkyjs, to add functionality or wrap OCaml functions:
https://github.com/o1-labs/snarkyjs/blob/5c6ce17ba44467ca78e3d2d3e7593c748918f9a4/src/lib/circuit_value.ts#L942-L943

Also, the `Circuit` interface for writing simple (non-Pickles) circuits has its API surface (the class that users interact with) living in OCaml, which makes it hard to maintain and refine that surface. Which is probably why `Circuit`, at this moment, is not integrated with `ZkProgram`, and is neither properly documented nor used very often.

In summary, `Circuit` is a natural place to start the migration of the snarkyjs core (Field, Bool,..) from OCaml to JS.

**How to migrate:**
- Some logic is already basically written in JS, just inside OCaml (which is ugly and unmaintainable), and/or is easy to write in JS on top of lower-level primitives like `Field.mul`, `Field.add`, `Field.assertEquals`. Functions like this should just be moved to JS entirely, using the lower-level building blocks. Examples:
  - `Circuit.if`
  - `Circuit.toFields`
  - `Circuit.assertEqual`
- Some logic can be just replaced by equivalents we already re-built in JS, which will remove [known bugs](https://github.com/o1-labs/snarkyjs/issues/65):
  - `Circuit.inProver`
  - `Circuit.inCheckedComputation`
- Finally, some logic is more involved under the hood, like the circuit-writing interface with functions like `Circuit.generateKeypair` and `Circuit.prove`. Here, the API _surface_ should be moved to JS, but it should still rely on access to a module-like object exposed from OCaml, which has functions like snarky's `constraint_system` and `Keypair.generate` on it.
- Supporting classes like Keypair and VerificationKey should be moved to JS, while also relying on the low-level snarky-wrapping module from OCaml

**Other goals:**

One of the goals of this task is also to feel out what a minimal API surface from JS to the future `snarky-rs` needs to look like. This should inform the [ongoing RFC process for speccing out snarky-rs](https://github.com/o1-labs/snarky/discussions/774) and in particular its interaction with snarkyjs.","[('bkase', 'One important consideration as we start to think about this rewrite is that should be able to support writing circuit snippets in the snarky-rs layer and “seamlessly” using them from JS layer. There’s a lot of ways we could do this and different interpretations of seamless but just wanted to call it out to make sure it’s being considered.'), ('mitschabaude', ""That's a good point!""), ('mitschabaude', ""## Mini-RFC: Renaming `Circuit` to `Provable`\r\n\r\nI propose that, when moving `Circuit` to JS, we also split up\r\n* the `Circuit` class for creating proofs, and\r\n* the `Circuit` utility module with functions like `Circuit.if`, `Circuit.witness`, `Circuit.array`\r\n\r\ninto two different namespaces.\r\n\r\nWe rename the utility module to 'Provable', so it becomes\r\n* `Provable.if`, `Provable.switch`, `Provable.witness`, `Provable.array`\r\n\r\nThere should be a deprecation period, but I think long-term we want to get away from 'Circuit' as a term for provable code.""), ('nicc', 'IRI: @shimkiv @Trivo25 @bkase \nCan we do a walk-through of changes during sprint review or a video?')]"
674,Get rid of `shutdown` by running workers only when needed,mitschabaude,closed,"IS: Workers are started when snarkyjs gets loaded and they keep running throughout the JS process, so that we need to shut them down at the end.

SHOULD: Workers should be started on demand when we start to compile, prove or verify (these are the functions that currently make use of workers). They should be shut down again when those functions terminate.

IMPACT: We can remove `shutdown` which is inconvenient, especially in Jest tests, and is a source of CI failures (forgetting to add `shutdown` to a script means the script will run indefinitely in CI). We also reduce the time to `isReady`, to zero in the case of nodejs (the web version still needs `isReady` since the Wasm bundle can only be loaded asynchronously. We could discuss loading it synchronously with top-level await, to get rid of `isReady` altogether)","[('mitschabaude', ""Note: I'm tagging this with `move-to-js` since it likely moving the worker setup in node, from `node_backend.js` which lives in `mina/src/crypto` and is compiled by JSOO, into the main snarkyjs code base.""), ('nicc', 'Indirectly Irresponsible Individual: @MartinMinkov ')]"
673,Expose side loaded verification key to snarkyjs,mitschabaude,open,"""Side-loaded"" verification keys are used by Pickles to recursively verify proofs which aren't baked into the verifying circuit at compile time. This is for example necessary for zkApp proofs, which are verified in the transaction snark but can't be baked in at compile time. This seems to be an alternative way of using proof recursion, which is more flexible w.r.t. what proofs can be verified. A user reports needing this feature:

> A few weeks back we talked about verifying Proofs inside ZkPrograms / Contracts with a dynamically passed verification-keys (not baked in ones). This is a feature I need for a project I want to develop

This would also be needed to develop ZkPrograms which are mutually recursive (they can verify the proofs of each other, not just in one direction). Right now, in ZkProgram there is a strict order in which the verification keys have to be compiled: If Program A wants to verify proofs of Program B, then compiling Program A requires the verification key / tag of Program B to be already available. So, there is no way that Program B could depend on Program A.

The goal is to expose the more flexible recursion style to snarkyjs.","[('rpanic', 'This would enable more general-style rollups which could have a ""network""-state on their own, making the development of more efficient and distributed rollups possible versus the current trustless but centralized per-contract idea. \r\n\r\nAlso, more contract patterns could emerge, like upgradable proxy contracts, etc.'), ('maht0rz', ""Would an API like this possibly made sense? What are the technical limitations and requirements of side loading?\r\n\r\n```typescript\r\nclass ZkApp extends SmartContract {\r\n  @method\r\n  verify(proof: AnyProof) {\r\n      // bring in a verification key as private input\r\n      const vk = Circuit.witness(VerificationKey, () => new VerificationKey())\r\n      // verify the VK is one of the 'right ones'\r\n      const isValidVk = vk.equals(vk1).or(vk.equals(vk2));\r\n      isValidVk.assertTrue();\r\n      // verify the proof\r\n      vk.verify(proof);\r\n  }\r\n}\r\n```""), ('mitschabaude', 'That would be a nice API @maht0rz! I imagine something like this should be possible, I think the OCaml code that verifies zkApp proofs in a circuit looks similar'), ('maht0rz', ""@mitschabaude i'd love to contribute by implementing this but i am currently bottlenecked by my knowledge of Kimchi, and how it could be exposed into snarkyjs. I personally don't know why exactly this doesnt work already, so that makes it difficult to try and figure out what needs to change in the first place.""), ('rpanic', ""I'd be very interested in the reasons why that is not exposed by default. Is it just a matter of API or is there a different mechanism for the side-loaded keys under the hood? How does the side-loading mechanism actually work on a abstract level?""), ('mitschabaude', ""@maht0rz @rpanic it's not exposed already / by default because to expose something from ocaml generally some work needs to happen, and back when I exposed pickles to make proving work for smart contracts I didn't have this on my radar (https://github.com/o1-labs/snarkyjs/pull/115)\r\n\r\nWork usually needs to happen on the ocaml side in this file: https://github.com/MinaProtocol/mina/blob/dfc3a21ce43904bd9d23a3d3ce2c3a2c570071f2/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L2231""), ('mitschabaude', '> Is it just a matter of API or is there a different mechanism for the side-loaded keys under the hood?\r\n\r\nThere\'s a different mechanism! Pickles supports two kinds of verification keys: ""compiled"" (these are what snarkyjs currently uses) and ""side-loaded"":\r\nhttps://github.com/MinaProtocol/mina/blob/dfc3a21ce43904bd9d23a3d3ce2c3a2c570071f2/src/lib/pickles/tag.ml#L5'), ('maht0rz', ""I'd love to see this feature hit o1js as soon as possible, this will make circuit design & design of 3rd party libraries much easier.\r\nWe want to allow users not to recompile their Protokit application chains, when they want to change what kind of off-chain proofs their Runtime accepts. Thats just one of many features that would be possible with sideloading. Is there any way to prio the implementation of the API?"")]"
672,React hooks (and equivalent for vue/svelte) for common zkApp UI interactions,bkase,open,,[]
671,Native web-worker support,bkase,open,Avoid having to build custom web worker clients ala this tutorial https://docs.minaprotocol.com/zkapps/tutorials/zkapp-ui-with-react,"[('mitschabaude', 'Smaller issues that build up to this and likely come first: #674 #227')]"
670,Get rid of decorators,mitschabaude,open,Probably means getting rid of the SmartContract class,"[('maht0rz', ""Is there a new proposed API as this sounds like `@method` or `@state` are going away? I'm asking since we're designing a new library to extend snarkyjs and want to make sure our API design wont become obsolete.""), ('mitschabaude', ""It's still TBD if we even want to act on this issue, but the only replacement candidate for decorators that I'm aware of is the API we have for ZkProgram, where `method` and `privateInputs` are separate keys to an object which described the circuit"")]"
669,Split Field.Constant / Field.Variable,mitschabaude,open,,"[('mitschabaude', 'Should also keep in mind user defined data types')]"
668,Expose JSON constraint system from Rust for SmartContract,mitschabaude,closed,,[]
667,Mina-signer: implement transaction hash,mitschabaude,closed,,[]
664,Refactor events to be better typed (like reducer),mitschabaude,open,,[]
661,"Expose `reduce` to ZkProgram, use for rolling up Merkle tree updates",mitschabaude,open,"We should make it easier to roll up updates to a Merkle tree with actions /.reducer.
Ideal (IMO) architecture is laid out here: https://github.com/o1-labs/snarkyjs/issues/659#issuecomment-1361320687",[]
659,RFC: Witness merging in reducer,45930,closed,"# Motivation
The actions/reducer(link) paradigm looks very promising as a way to handle mutli-user, async state update events.  However, it is currently not so obvious how to process these events for state which happens to be the root of a merkle tree.  The ability to merge `Witness` objects would allow developers to reduce multiple `Action`s of the form `{ witness: Witness, leafValue: Field }` into a new root hash which incorporates each separate action and does not require the full tree to be loaded in order to generate a new root.

# Current State
Imagine a scenario in which we have a zkapp with some state which represents the root hash of a merkle tree.  The merkle tree can store the current balance for each user in the zkapp.  We have 3 users, Alice, Bob, and Charlie who each wish to deposit into the app.

## Standalone Transaction
This can be accomplished without using a reducer, for instance:

```
@state root = State<Field>();

@method
deposit(user: PublicKey, amount: Field, witness: Witness) {
	// Simplified function calls
	this.root.assertEquals(this.root.get());
	this.root.assertEquals(witness.computeRoot(amount));
	user.send(this.account, amount);
	this.root.set(witness.computeRoot(amount));
}
```

The problem with this implementation is that it has a max throughput of one deposit per block (later transactions attempting to update the root will fail the second assertion.  Their witness is now out of date).  This is not acceptable for a variety of apps.  In particular, imagine some kind of ""mint"" or auction event which goes live at a certain time with hundreds or thousands of users.  I.e. ~20 transactions per hour might be appropriate in steady state for some apps, but there are certainly other apps with burst usage which far exceeds this rate.

## Actions/Reducer
The best available way to solve our problem is to emit actions in the deposit method, then reduce them into one state update.  This solves the problem of only allowing one transaction per block to succeed but it introduces a new problem.

### Naive Solution
```
class MerkleUpdate extends Struct({ witness: Witness, newLeaf: Field }) {};

-----------------------------------------------------

@state root = State<Field>();
@state actionsHash = State<Field>();
reducer = Reducer({ actionType: MerkleUpdate})

@method
deposit(user: PublicKey, amount: Field, witness: Witness) {
	// Simplified function calls
	this.root.assertEquals(this.root.get());
	this.root.assertEquals(witness.computeRoot(amount));
	user.send(this.account, amount);
	this.reducer.dispatch({ witness: witness, newLeaf: amount })
}

@method
reduceMerkleUpdates() {
	let root = this.root.get();
	let actionsHash = this.actionsHash.get();
	
	let { state: newRoot, actionsHash: newActionsHash } = this.reducer.reduce(
		this.reducer.getActions(actionsHash),
		MerkleUpdate,
		(state: Field, action: MerkleUpdate) => {
			return action.witness.computeRoot(action.newLeaf);
		}
	);
	
	this.root.set(newRoot);
	this.actionsHash.set(newActionsHash);
}

```

This seemingly solves the problem and would probably run, but there's an issue.  This reduction does not fail when multiple users make an update, but the root hash that ends up on the chain will not reflect the sum of all three state changes.  It will only reflect one of the state changes, whichever one happens to go last.  That's becuase the `Witness` being used in `action.witness.computeRoot(action.newLeaf);`  is the stale witness to the existing tree whose root is on chain, not to a tree which has already processed the other updates.

It turns out that in order to process all of these updates at once, we'd have to build the full tree in javascript, make the updates on that tree, then compute the new root after all of the updates are done.  This is a little weird since `MerkleTree` is not provable and can't be used as a parameter to the method.  We would need the full tree to exist outside of the scope of the method.  It also limits who is capable of running the reducer method to someone who has the enitre state stored.

# Proposal
A more elegant, and scalable, solution would be to merge witnesses to the same tree into a single witness of a new tree.

An API for this could look like:

```
BaseMerkleWitness {
	/*
	 Observes the value of this witness with the value of leaf
	 merges the paths of the other witness with the paths of this after observing the leaf
	 @returns a new witness of the related path as other, but with hashes updated based on this' observation of leaf
	*/
	merge(leaf: Field, other: BaseMerkleWitness);
}
```

And usage in a reducer could look like
```
let initialWitness = actions[0].witness;
let leaf = actions[0].leaf;
finalWitness = (state: Witness, action: MerkleUpdate) => {
	newWitness = action.witness.merge(leaf, action.witness);
	leaf = action.newLeaf;
	return newWitness;
}

this.root.set(finalWitness.computeRoot(leaf));
```

The algorithm I am imagining looks like:
- Confirm that witnesses are the same heght and not identical
	- If pass then these witnesses are mergable
- Identify the height within the path at which the witnesses differ (`h`)
	- example:
	- tree with height of 4, leaf count is 8
	- 1 and 5 are on different halves of the tree, so they differ at level 3
	- 7 and 8 are on the same half of the same half of the tree, so they differ at level 1
	- 6 and 8 would be 2
	- I believe this idea could be generalized
- calculate the hash of witness1 at the leaf up to `h` (`hash`)
- create a new witness with the same path at witness2 (`w3`)
- set the path of `w3` at index `h` to `hash`
- returrn `w3`","[('Trivo25', 'Thanks for the write up! This sound reasonable and I believe would be a nice addition to the existing merkle tree (witness) implementation. Hiding the abstraction behind a simple API like you mentioned is important - the new witness should also be fed into the circuit using `Circuit.witness` to not impact prover performance.'), ('mitschabaude', ""Thanks for the write-up! From a technical standpoint, this checks out for me: It's a method for ensuring that the reducer can be run _without access to the Merkle tree_.\r\n\r\nI don't yet understand what seems to be the premise: that requiring access to the Merkle tree for each user who dispatches an action is better than requiring it for the reducer.\r\n\r\nI also don't agree that the following is a limitation / challenge:\r\n\r\n> This is a little weird since MerkleTree is not provable and can't be used as a parameter to the method.\r\n\r\nActually, the whole sequence of Merkle witnesses that are used in the reducer can be computed outside the circuit, in whatever way is best, and the full list of witnesses can be given to the circuit as a method input. This is analogous to how in each individual action dispatch, the Merkle witness would be computed outside the circuit and passed in as a method input.""), ('Trivo25', ""> I don't yet understand what seems to be the premise: that requiring access to the Merkle tree for each user who dispatches an action is better than requiring it for the reducer.\r\n\r\nIdeally I think no one should need the original merkle tree to invoke a contract method (unless they want to do verification of the data themselves of course). If the entity that invokes the reducer method is a central entity that has access to the tree anyway I don't see an issue with using the tree within the reducer directly. \r\n\r\nHowever, using merkle proofs with the proposed solution seems to be a cleaner lightweight solution when there are multiple moving parts in the system, or it is required to parallelize work in some way or another. I think both ways are valid, depending on the scenario.""), ('45930', 'Thanks for the discussion guys.  I\'ll try to clarify a few things then work on implementation.\r\n\r\n@mitschabaude \r\n\r\n> This is a little weird since MerkleTree is not provable and can\'t be used as a parameter to the method.\r\n\r\ne.g. in my personal project in which I plan to implement this solution\r\n```\r\n ● Test suite failed to run\r\n\r\n    Argument 1 of method reduceCollateralActions is not a provable type: class MerkleTree\r\n```\r\n\r\nTo the idea of why combine witnesses vs. use the whole tree: I really like the idea of emitting actions which are inherently reducible.  Perhaps there could be service providers which just run reducers for app developers.  Perhaps users will run them for apps which they use.  Seems like a needless complication to require for all calls to this method to include the full tree as a param, even just for simplicity\'s sake.  For performance and speed I\'m not so sure.  It seems like there\'s some tradeoff where a merkle tree could be too big to store locally, especially on weaker machines, but it also seems like there could be enough witnesses to merge that the time to calculate and recalculate and recalculate the new path is too long.  I guess that\'s a conversation to be had in the future.\r\n\r\n\r\n@Trivo25 - not sure what you mean by ""the new witness should also be fed into the circuit using Circuit.witness to not impact prover performance""\r\n\r\nTo both of you: Do you agree with the the method name `merge`?  I wonder if that\'s too loaded of a term, or if we keep that name if `w1` should be the proof that ""survives"" rather than `w2`.  Since you actually lose the witness of one of the paths, this isn\'t really merging 2 proofs.  It\'s more like updating one of the proofs.  Would take some input on the naming convention here.'), ('mitschabaude', '>  really like the idea of emitting actions which are inherently reducible. Perhaps there could be service providers which just run reducers for app developers.\r\n\r\nThanks for fleshing this out, makes sense to me now!\r\n\r\nI agree that `Circuit.witness` should be used to bring in new witnesses by the way -- what @Trivo25 said. Or in other words: `.merge()` should happen outside the circuit'), ('Trivo25', '>  not sure what you mean by ""the new witness should also be fed into the circuit using Circuit.witness to not impact prover performance""\r\n\r\nRunning code within `Circuit.witness` doesn\'t run the code as part of the proof generation, but entirely outside of the circuit/proof and only feeds a ""witness"" (input) back into the circuit. You can think of it as an additional input argument to your circuit.\r\n'), ('45930', 'Here\'s a starting point:\r\n\r\n```\r\n/**\r\n   * Merges in another witness which claims to be of the same tree at a different path\r\n   * @param leaf Value to observe at the other path\r\n   * @param other Witness which will be used to merge paths\r\n   * @returns New MerkleWitness with the merged paths of the inputs\r\n   */\r\n  merge(leaf: Field, other: BaseMerkleWitness): Witness {\r\n    const otherHeight = other.height();\r\n    if (this.height() !== otherHeight) {\r\n      throw Error(""witnesses of different height are not mergable"");\r\n    }\r\n\r\n    const index = Number(this.calculateIndex().toString());\r\n    const otherIndex = Number(other.calculateIndex().toString());\r\n\r\n    let levelWithDivergance: number = 0;\r\n    let x = 2 ** (this.height() - 1) / 2;\r\n    for (let i = 1; i < this.height(); i++) {\r\n      const bothUpperHalf = index > x && otherIndex > x;\r\n      const bothLowerHalf = index <= x && otherIndex <= x;\r\n\r\n      if (bothUpperHalf) {\r\n        x = x + (x / 2);\r\n      } else if (bothLowerHalf) {\r\n        x = x / 2;\r\n      } else {\r\n        levelWithDivergance = this.height() - i;\r\n      }\r\n    }\r\n\r\n    // calculate hash just a bit...\r\n    let hash = leaf;\r\n    for (let i = 0; i < levelWithDivergance; ++i) {\r\n      const left = Circuit.if(other.isLeft[i], hash, other.path[i]);\r\n      const right = Circuit.if(other.isLeft[i], other.path[i], hash);\r\n      hash = Poseidon.hash([left, right]);\r\n    }\r\n\r\n    const newWitness: Witness = this.isLeft.map((isLeft, i) => {\r\n      return {\r\n        isLeft: isLeft.toBoolean(),\r\n        sibling: this.path[i]\r\n      }\r\n    });\r\n    newWitness[levelWithDivergance].sibling = hash;\r\n    return newWitness;\r\n  }\r\n}\r\n```\r\n\r\n\r\n```\r\nimport {\r\n  isReady,\r\n  Field,\r\n  MerkleTree,\r\n} from \'snarkyjs\';\r\n\r\nimport { MerkleWitness } from \'../lib/merkle_tree.js\';\r\n\r\nawait isReady;\r\n\r\nlet tree = new MerkleTree(4);\r\nclass MyMerkleWitness extends MerkleWitness(4) { };\r\n\r\ntree.setLeaf(0n, Field(10));\r\ntree.setLeaf(1n, Field(100));\r\ntree.setLeaf(2n, Field(1000));\r\ntree.setLeaf(3n, Field(20));\r\ntree.setLeaf(4n, Field(200));\r\ntree.setLeaf(5n, Field(2000));\r\ntree.setLeaf(6n, Field(30));\r\n\r\nconst root = tree.getRoot();\r\n\r\nconsole.log(root.toString());\r\n\r\nconst w1 = new MyMerkleWitness(tree.getWitness(1n));\r\nconst w2 = new MyMerkleWitness(tree.getWitness(2n));\r\n\r\nconst w3 = new MyMerkleWitness(w1.merge(Field(150), w2));\r\n\r\ntree.setLeaf(2n, Field(150));\r\n\r\nconsole.log(tree.getRoot());\r\nconsole.log(w3.calculateRoot(Field(100)));\r\n```'), ('45930', ""So the `merge` method here is decidedly not in the circuit.  Is this the pattern you had in mind?\r\n\r\nI don't like that `MyMerkleWitness#merge` returns a different type.  That seems confusing.  If you know a way to cleanly resolve that I'd love to know.\r\n\r\nThe other question is where you recommend wrapping code in a `Circuit.witness`?  And if someone can just run any version of this function that they want, then isn't there a risk of them writing invalid data to state?  It's not clear to me why this would be allowed to operate outside the circuit.""), ('45930', ""I guess to elaborate on that, the point of this api is to reduce 2 existing proofs into 1 proof.  If the conversion of 2 into 1 is not itself proved, then it seems like you get essentially a random field as output.  It's not useful.\r\n\r\nBut I wonder with a merkle witness of size 128, a proof that this was at least somewhat constrained would be that the other 127 fields in the path are equal to the starting path.  In other words, only the expected level changed.  But that's still not sufficient to say the merge was valid (if the computation is not checked as well).\r\n\r\nThere are some artifacts in my code above from attempting to do the whole thing with circuit-compatible code.  I think it's possible but would be more verbose.  So I wanted to do a temperature check and ask about it.""), ('mitschabaude', ""@qcomps I think that we don't need to prove that we merge Merkle witnesses correctly. At a higher level, this is the process of updating a Merkle tree, inside a SNARK:\r\n\r\nInput: an old leaf; a new leaf; an old Merkle root; a new Merkle root; a Merkle witness (= the siblings in the Merkle path)\r\nOnly _one_ of these inputs is anchored to on-chain state: the old Merkle root. The rest can be anything, it's user input.\r\n\r\n1. Check that, when hashing the old leaf along the path given by the Merkle witness, you get the old Merkle root.\r\n   - This proves that your old leaf was in the tree, **irrespective of what the Merkle witness is**\r\n2. Compute the new root, using the new leaf instead of the old, but using **the same Merkle witness**\r\n   - This proves that the new root is the correct result of transitioning from the old leaf to the new leaf\r\n  \r\nI think we have to perform this 2-step process for every action in the reducer. If we do that, nothing else about the Merkle witnesses has to be proved""), ('Comdex', ""Personally, I think the above solution is not realistic and scalable under the current mina zkApp design. I think the reducer in the contract is not suitable for most applications that need to use the merkle tree. There are two main reasons (if I made a mistake, please correct me): \r\n\r\nFirst, the events or actions of each zkApp transaction has a size limit (this is also a limitation of network performance), if I am not mistaken, the current limit is 16 fields per transaction, In this way, adding leaf data to the action is already very stressful, and it is basically impossible to add a merkle witness of a common size. \r\n\r\nThe second is to use a merkle witness of a common size in the reducer to verify and generate a new root, without other business logic, even if fewer actions are processed, it is easy to reach the upper limit of the circuit constraint size. Although we may be able to configure the number of actions processed by the reducer to be smaller to circumvent the limit (this requires sending multiple reducer transactions), we have a risk that if our zkApp has a lot of transactions in a short period of time, the actions we process in a reducer transaction may often fail to catch up with the oldest of the 5 sequence states that exists on the network.\r\n\r\nFor zkApp that needs to use merkle tree, I am exploring a more lightweight solution than building a complete rollup application: Actions + zkProgram.  If the transaction volume is certain and the processing time is properly controlled, I can always catch up with the sequence state that exists on the network in a transaction, if you are interested, you can take a look at my example: https://github.com/Comdex/nft-zkapp , this solution works well under the current zkApp architecture design and limitations (there may be some issues that need to be addressed that I haven't found yet 😅), I wonder if it is more valuable to provide an api like a reducer in zkProgram?""), ('mitschabaude', 'Yes @Comdex, what you say is on point. I agree that the nft-zkapp design is what we should expose in SnarkyJS'), ('mitschabaude', 'Yeah the actions size limit kind of kills this witness merging solution for now, I hope we can lift that limit at some point :/'), ('45930', 'Dang!\r\n\r\nThanks for the comment @Comdex'), ('45930', '@mitschabaude \r\n\r\n> \r\n> 1. Check that, when hashing the old leaf along the path given by the Merkle witness, you get the old Merkle root.\r\n>         This proves that your old leaf was in the tree, irrespective of what the Merkle witness is\r\n> 2. Compute the new root, using the new leaf instead of the old, but using the same Merkle witness\r\n>        This proves that the new root is the correct result of transitioning from the old leaf to the new leaf\r\n\r\nI think after we merge 2 witnesses (at least as implemented here) then it no longer is the same merkle witness.  If the value at index 8 is 10 on chain and the value at index 1 is 5 - and I have 2 actions, one per index, both with the value of 15 - then after I perform one update, the other witness is invalid.  The point of this was to change the siblings in one witness so that it was a valid witness to the tree after the other update is done.  But that removes the tether to state, and you now have untrusted witnesses, which cannot produce a root which matches state.  So I still think the computation would have to be checked, which just adds more constraints...\r\n\r\nLook at my example where we produce `w3`, a witness to index one of a tree which is different than the original one.\r\n\r\nSo it sounds like this is not viable for now.  I will read more about zkprograms.\r\n'), ('mitschabaude', '@qcomps to clarify, I think you should take the new (merged) witness, and with it perform the two steps of checking old root & upodating new root, for each action. so its the same witness because you do it with the same witness'), ('Comdex', '> Yes @Comdex, what you say is on point. I agree that the nft-zkapp design is what we should expose in SnarkyJS\r\n\r\nTo make this soluation more reliable, I think there may be two points that need to be improved urgently. 😅\r\n\r\nOne is that the circuit size limit of zkProgram needs to be configurable. Although we could batch a small number of actions by running smaller circuits and then recursively merge the state, this would consume significantly more time, even if we were using multiple threads. In my nft-zkapp example, although the logic is relatively simple, the limitation of the circuit size makes it possible to process only 15-28 Actions in one batch. We need to make the processing of actions catch up with the sequence state in the network within a limited block time. Such performance is obviously risky. Larger circuits can significantly process more Actions in one batch. Compared with recursively merging the processing results of more small batch actions, it has a time advantage.\r\n\r\nThe second is to solve the annoying ""stack overflows"" problem. Many times we will encounter this problem before we touch the upper limit of the circuit size. I have tested that for a simple contract, if the input parameter size of the contract method exceeds 1200 fields, there is a high probability that this problem will occur. If I\'m not mistaken, this probably only handles 4-5 signatures? This problem is a roadblock for such use cases that require better performance and greater throughput.')]"
657,"All fetch errors are interpreted as ""Could not find account""",mitschabaude,open,"TODO: Better discriminate between different kinds of errors in places like `Mina.getAccount`. Example:
* If the endpoint doesn't respond, that should always result in an error
* A missing, on the other hand, account is sometimes an error (e.g. in `getAccount`) and sometimes just information that this account doesn't exist yet (in `hasAccount`)",[]
654,Permissions error in  merkle_zkapp.ts,garyrob,closed,"The Merkle Tree page[1] in the Advanced SnarkyJS section of the docs  links to an example source file, merkle_zkapp.ts[2].

That source file does not compile. It gives the error: 
 TS2339: Property 'permissions' does not exist on type '{ nonce: { get(): UInt32; assertEquals(value: UInt32): void; assertNothing(): void; } & { assertBetween(lower: UInt32, upper: UInt32): void; }; ... 5 more ...; isNew: { ...; }; }'.



[1] https://docs.minaprotocol.com/zkapps/advanced-snarkyjs/merkle-tree
[2] https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/merkle_tree/merkle_zkapp.ts
","[('mitschabaude', ""The source file compiles in the snarkyjs `main` branch, where it's located.\r\nSo, the docs link to an example which doesn't work with the released version. This is a temporary issue: We plan to release that new version next Tuesday."")]"
646,type mismatch for `Proof` as ZkProgram input,Trivo25,closed,"There's a type mismatch for ZkProgram method arguments of type `Proof` caused by https://github.com/o1-labs/snarkyjs/blob/main/src/lib/circuit_value.ts#L1140


```ts
proveSomething: {
      privateInputs: [SelfProof],

      method(publicInput: Field, proof: SelfProof<Field>) {
      },
},

// ..

await MyProgram.proveSomething(Field(1), proof);
/*

Argument of type '[Proof<Field>]' is not assignable to parameter of type 'TupleToInstances<[typeof SelfProof]>'.
  Type '[Proof<Field>]' is not assignable to type '[{ prototype: { publicInput: any; proof: never; maxProofsVerified: never; shouldVerify: { toField: {}; not: {}; and: {}; or: {}; assertEquals: {}; assertTrue: {}; assertFalse: {}; equals: {}; sizeInFields: {}; toFields: {}; toString: {}; toJSON: {}; toBoolean: {}; }; verify: {}; verifyIf: {}; toJSON: {}; }; publicIn...'.
    Type 'Proof<Field>' is missing the following properties from type '{ prototype: { publicInput: any; proof: never; maxProofsVerified: never; shouldVerify: { toField: {}; not: {}; and: {}; or: {}; assertEquals: {}; assertTrue: {}; assertFalse: {}; equals: {}; sizeInFields: {}; toFields: {}; toString: {}; toJSON: {}; toBoolean: {}; }; verify: {}; verifyIf: {}; toJSON: {}; }; publicInp...': prototype, publicInputType, tag, fromJSONts(2345)
*/

```","[('mitschabaude', 'this was fixed in https://github.com/o1-labs/snarkyjs/pull/698')]"
641,converting large 32 byte values to Field fails,marekyggdrasil,closed,"example value

as hex `2452644332eebb5ea3174fcb1724b2b8826a600d4455b65e3a93609d58ae80c6`
as base58 `3SnYbQym9awSs3dTJVcDTJ5AVPXYgfca1u43Y7VgHPYy`
as bigInt `89785303736691784847086092688526102755694609368157008008048180906112472863268n`
as `number[]`

```
[
        36,  82, 100,  67, 50, 238, 187,  94,
        163,  23,  79, 203, 23,  36, 178, 184,
        130, 106,  96,  13, 68,  85, 182,  94,
        58, 147,  96, 157, 88, 174, 128, 198
    ]
```

## using fromBytes

```typescript
const data_field: Field = Field.fromBytes([
        36,  82, 100,  67, 50, 238, 187,  94,
        163,  23,  79, 203, 23,  36, 178, 184,
        130, 106,  96,  13, 68,  85, 182,  94,
        58, 147,  96, 157, 88, 174, 128, 198
    ]);
```

throws

```
    RuntimeError: unreachable

      at __rust_start_panic (wasm:/wasm/00e653d2:1:3312693)
      at rust_panic (wasm:/wasm/00e653d2:1:3307369)
      at std::panicking::rust_panic_with_hook::hb01d8793e567b040 (wasm:/wasm/00e653d2:1:3117430)
      at std::panicking::begin_panic_handler::{{closure}}::h60108af06f38ef3d (wasm:/wasm/00e653d2:1:3238474)
      at std::sys_common::backtrace::__rust_end_short_backtrace::h761906d06428c797 (wasm:/wasm/00e653d2:1:3303652)
      at rust_begin_unwind (wasm:/wasm/00e653d2:1:3285422)
      at core::panicking::panic_fmt::hffbf0f027a7fa92d (wasm:/wasm/00e653d2:1:3299960)
      at core::result::unwrap_failed::haf3f6481b8d95ef1 (wasm:/wasm/00e653d2:1:3264758)
      at <plonk_wasm::arkworks::pasta_fp::WasmPastaFp as wasm_bindgen::convert::traits::FromWasmAbi>::from_abi::h663aac302268cfb2 (wasm:/wasm/00e653d2:1:2752067)
      at caml_pasta_fp_to_bigint (wasm:/wasm/00e653d2:1:2261046)
```

## using Ledger

```typescript
const f: Field = Ledger.fieldOfBase58('3SnYbQym9awSs3dTJVcDTJ5AVPXYgfca1u43Y7VgHPYy');
```

throws

```
    thrown: Array [
      0,
      Array [
        248,
        MlBytes {
          ""c"": ""Base58_check.Invalid_base58_checksum"",
          ""l"": 36,
          ""t"": 0,
        },
        199,
      ],
      MlBytes {
        ""c"": ""Token ID"",
        ""l"": 8,
        ""t"": 0,
      },
    ]
```

## Using bigInt conversion

```typescript
function bytesToBigInt(bytes: Uint8Array) {
    let x = 0n;
    let bitPosition = 0n;
    for (let byte of bytes) {
        x += BigInt(byte) << bitPosition;
        bitPosition += 8n;
    }
    return x;
}

console.log(new Field(bytesToBigInt(data)));
```

where data is same array but as `Uint8Array`. This throws

```
    caml_pasta_fp_of_bigint

      54 |     console.log(v.toString());
      55 |     */
    > 56 |     console.log(new Field(bytesToBigInt(data)));
         |                 ^
      57 |     return [chunk_1, chunk_2, chunk_3, chunk_4];
      58 | }
      59 |

      at raise_error (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:430864:44)
      at of_string_exn$0 (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:430915:72)
      at value$6 (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:430946:34)
      at caml_call_gen (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
      at node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3643:18
      at new eval (eval at caml_js_eval_string (node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3630:44), <anonymous>:4:26)
      at new Class (node_modules/snarkyjs/src/snarky/proxy.js:11:14)
      at grinAddressToFields (src/helpers.ts:56:17)
      at Object.<anonymous> (src/helpers.test.ts:40:34)
```

","[('marekyggdrasil', 'forgot to mention, I am using SnarkyJS `0.7.3`'), ('mitschabaude', ""This is expected - the value you have is larger than the size of the field. With `Encoding.bytesToFields`, you can get two field elements.\r\n\r\nOr, if you don't mind to let the value wrap around modulo p, you can do `Field(bigint % Field.ORDER)`"")]"
640,Bug in merkle_tree example?,garyrob,closed,"
I created a new project with `zk project`. I copied the code from [1] into `src/index.ts`. I compiled with `tsc`. I ran `node build/src/index.js` and got the output:

> Deploying leaderboard..
> Initial points: 0
> Making guess..
> assertion failed [block != nullptr]: BasicBlock requested for unrecognized address
> (BuilderBase.h:550 block_for_offset)


What could be wrong here?



[1] https://raw.githubusercontent.com/o1-labs/snarkyjs/main/src/examples/zkapps/merkle_tree/merkle_zkapp.ts","[('garyrob', ""OK. I only get this problem on my Mac running MacOS. On  Linux box, I don't. It may be relevant that it's an Apple Silicon machine where my terminal evironment is running under Rosetta for Intel compatibilty. But this is the very first problem I've had; I run Python stuff this way all the time without incident.""), ('mitschabaude', 'Interesting.. Sounds like a problem that lies deeper than our library. Maybe it helps to search for this error in the context of node / apple M1'), ('mitschabaude', 'Did you try with different node versions? '), ('garyrob', ""I'm running node v19.2.0 both on MacOS and Linux with identical results.\r\n\r\nThe only thing I've found so far with Google that might be relevant is [this](https://www.google.com/search?q=macos+m1+%22assertion+failed+%5Bblock+%21%3D+nullptr%5D%3A+BasicBlock+requested+for+unrecognized+address%22&hl=en&ei=mx6WY5iIN5CP0PEPh_eWkAw&ved=0ahUKEwjYwbmklvL7AhWQBzQIHYe7BcIQ4dUDCA8&uact=5&oq=macos+m1+%22assertion+failed+%5Bblock+%21%3D+nullptr%5D%3A+BasicBlock+requested+for+unrecognized+address%22&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQA0oECEEYAEoECEYYAFAAWJoLYKoPaABwAHgAgAFgiAHJBZIBATiYAQCgAQHAAQE&sclient=gws-wiz-serp). I'm thinking that my own solution will just be to develop Mina stuff on Linux!""), ('mitschabaude', ""Ok it seems to be an M1 problem\r\nhttps://github.com/ethereum/solidity/issues/13523\r\nhttps://github.com/PowerShell/PowerShell/issues/17655\r\n\r\nI'm going to close this!"")]"
638,Make test accounts have normal permissions,45930,closed,"Repro steps:

Fill in a user private key in this script and attempt to run (private key must be to a funded account on Berkeley).  **Expected behavior** is that the funded account will send the smart contract 1000 base units of Mina, and the contract state (merkle root) will update to reflect the user's deposit.  **Observed behavior** is that the transaction gets built just fine but gets an error on the blockchain [for example](https://berkeley.minaexplorer.com/transaction/CkpZ5gkKzH8ir83oitm3F349DuQN266GFrgTh95tC4FM4BWoLf6FE).  The current root hash on the chain is `2273112294...`.  If that root hash has changed, then that probably means a deposit has worked and the error is resolved.

Script:
https://github.com/pico-labs/coinflip-executor-contract/blob/ee63f90acfb435f06723e08ce00c2792083f8afb/src/berkeleyRun.ts

Deployed Contract:
https://berkeley.minaexplorer.com/wallet/B62qjb2oGVMGiPad6GKTBh6MqgFJ3ExhkfegBuUiynLoyCSbTfM62vW","[('mitschabaude', 'I get it actually. You\'re missing the following in your deposit method:\r\n```ts\r\ndepositUpdate.requireSignature();\r\n```\r\ntherefore, the account update has no authorization on it. The reason it works in tests is that those predefined ""test"" accounts have their permissions set to not require any authorization.\r\n\r\nI think that test behaviour might have been useful at an earlier stage where snarkyjs was less mature, but should be changed now, to not give misleading test results. If you don\'t mind, I\'ll change the description of this issue to be about changing permissions on the test accounts'), ('45930', ""Yup, I understand the issue now.  I was implicitly expecting `#send` to require the signature for me, if a signature was required on the sending account.  For instance, I was signing the transaction with the player's private key, but I now realize since nothing was asking for a signature, that that was useless.\r\n\r\nI guess I would suggest that calling `#sign` with private keys that are never requested should log a warning or really my preference would be an exception, but maybe that's too strong.  And since `send` is a literal permission on accounts, I think `AccountUpdate#send` should require a signature implicitly, if a signature is required on that account.  Like we've already configured what is needed to send, so why do I have to tell it again?  Either or both of those changes would have allowed me to catch this a lot earlier!  (In addition to your suggested change of making the test account permissions the same as default accounts on chain)""), ('mitschabaude', ""> I think AccountUpdate#send should require a signature implicitly, if a signature is required on that account\r\n\r\nthat makes sense to me. it's just a lot more involved to require the signature depending on the current account permissions (we're in a SNARK, it's all static). also, we have no way of verifying that the prover provides the correct permissions, there's no precondition for permissions (which doesn't pose a security issue here, as far as I can tell). given all that, I'm not sure making this implicit is worth it.\r\n\r\nI'll start by properly documenting all those functions like `requireSignature()`""), ('45930', ""Yeah that all makes sense but to me it is still kind of weird. `#send` exists primarily as a convenience method right? To hide `account1.balance.add(x); account2.balance.sub(x);` or whatever is actually going on. But then the dev 99,999 times out of 100,000 is going to add this `requireSignature` call which feels out place to, say, a solidity programmer. So I wonder why not just go back and use the more explicit `balanceChange` API which feels more natural in snarkyjs?\r\n\r\nI am seeing this in the source code:\r\n\r\n[snarkyjs/src/lib/account_update.ts](https://github.com/o1-labs/snarkyjs/blob/fb0946773a46e3aac865b4eb20bca9b6db9e6f9e/src/lib/account_update.ts#L754)\r\n\r\n```\r\n        // Require signature from the sender accountUpdate\r\n        Authorization.setLazySignature(sender);\r\n```\r\n\r\nThat makes it sounds like the intention actually was that update requires a signature implicitly. But then the source code for lazy signature looks more like it's for testing purposes.\r\n\r\nI'll leave you to figure it out. Just leaving my opinions.""), ('mitschabaude', ""@qcomps the suggestion I get from that is that `accountUpdate.send()` should just add `requireSignature()`, always (not looking at the permission).\r\nBut `SmartContract.send()` shouldn't because most smart contracts would send with a proof, not a signature.""), ('mitschabaude', '> this requireSignature call which feels out place to, say, a solidity programmer.\r\n\r\nHa! I think that the problem might be that we have the same generic type (AccountUpdate) for both zkApp account updates, and normal user updates. Which are completely different. If we\'d create a special type for a ""user account update"" then we would have methods on it that feel natural, for example because _every_ send from a user needs a signature, so it\'s added by the method'), ('mitschabaude', '> I am seeing this in the source code: \r\n\r\nThis is the token send method, not the one we were talking about, where we decided to require the signature by default. (in part because sending tokens from a zkApp needs a more complicated API anyway)')]"
636,UInt.assertGte doesn't fail with user defined error message,mitschabaude,closed,"instead it fails with `rangeCheckHelper: ...`, because an error is (incorrectly) thrown from OCaml","[('mitschabaude', ""I don't know when we fixed this bug but it's fixed"")]"
635,Pass in fee payer as a public key,mitschabaude,closed,"I think we should change the way we pass fee payers to transactions.

**Now:** the fee payer in a transaction is either left undefined or passed in as a private key, or a more complicated object containing a private key:
```ts
Mina.transaction(() => { ... });
Mina.transaction(privateKey, () => { ... });
Mina.transaction({ feePayerKey: privateKey, ... }, () => { ... });
```

**Why is this bad:** In a real zkApp, the private key won't be available. That means, the only option is to leave the fee payer undefined. _However_, it is a very common feature request to be able to access the _public key_ of the fee payer of the current transaction within a zkApp method, analogous to `msg.sender` in Solidity which people are used to. However, if the fee payer isn't passed in anywhere, we can't provide this feature.

**Solution:** We change the fee payer argument to be a public key, instead of a private key. We also make sure zkApp devs can access this public key from a wallet. We also establish the standard practice of passing in this public key, and provide a convenient API to access it similar to `msg.sender`.
I think it's ok to keep the option of leaving it undefined: we could make `msg.sender` throw an error in that case. Which means that, if you want your zkApp to use `msg.sender`, make sure that the fee payer public key is passed in.

Proposed API:
```ts
Mina.transaction(() => { ... });
Mina.transaction(publicKey, () => { ... });
Mina.transaction({ sender: publicKey, ... }, () => { ... });
```

If the transaction like also needs to be signed by the fee payer (for testing / non-browser usage), then the private key will have to be passed in to `tx.sign()`, like other signed account updates:

```ts
let tx = await Mina.transaction(publicKey, () => { ... });
await tx.sign([privateKey]).send();
```
","[('nicc', 'Can we overload this so that both types are supported to avoid a breakling chance? Ideally with deprecation message on receiving the PrivateKey type.')]"
634,Mina-signer: Serialize test signatures to JSON format for consumption by other implementations,mitschabaude,open,,[]
633,Integrate DynamicArray,mitschabaude,open,"There's a working, very high quality dynamic array implementation from the builder's program: https://github.com/gretzke/zkApp-data-types

We should add it to snarkyjs!","[('jasongitmail', '@mitschabaude What are the limitations or differences between this solution vs one built when the underlying proof system supports extended lookup tables (currently in Kimchi, but not yet in Pickles, as of today)?'), ('mitschabaude', ""> @mitschabaude What are the limitations or differences between this solution vs one built when the underlying proof system supports extended lookup tables (currently in Kimchi, but not yet in Pickles, as of today)?\r\n\r\nI think this solution already has the final API, so implements what we want feature-wise. The future version with proof system support would then make some of the operations more efficient.\r\n\r\nFor example, an array lookup currently creates `O(N)` constraints, where `N` is the static max array size. In the future, it should be `O(1)` (actually, close to 1) constraints.\r\n\r\nNote, I don't think we can avoid the static max size, even with extended lookup tables. (Same for strings.) I'm also not sure if all of the basic operations can be brought down from `O(N)`.\r\n"")]"
632,Mina-signer: sign legacy/mainnet tx,mitschabaude,closed,,[]
631,`this.send()` ignores send permission setting,dexterslabor,closed,"#### Description

When using `this.send()` to send Mina from a smart contract, the `send` permission setting `Permissions.signature` (default setting) is ignored. When signing the transaction with `tx.sign([key]).send()` the transaction fails with `Update_not_permitted_app_state`.

#### Steps to reproduce the issue

```typescript
@method withdraw(address: PublicKey) {
    ...
    this.send({
      to: address,
      amount: UInt64.from(5),
    });
  }
  deploy(args: DeployArgs) {
    super.deploy(args);

    // setup permissions
    this.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
      send: Permissions.signature(),
    });
  }
...
```

#### What's the expected result?

Negative balance update for the smart contract and a positive balance update for the recipient.

#### What's the actual result?

Transaction fails with `Update_not_permitted_app_state`.

#### Additional details 

The following workaround is not desired, because it could change the `editState` permission.

```typescript
@method withdraw(address: PublicKey) {
    ...
    this.self.requireSignature();
    this.send({
      to: address,
      amount: UInt64.from(5),
    });
  }
```

Notes on the API:
As an SDK user, I would expect that `this.send()` returns an `AccountUpdate` where I could do `.requireSignature()`.","[('mitschabaude', 'Hey thanks for reporting! I\'m a bit confused because I wouldn\'t think that `Update_not_permitted_app_state` is related to the use of `this.send()`, because sending doesn\'t update ""app state"". App state refers to the 8 state fields. For `this.send()` in your example, the failure I would expect is `Update_not_permitted_balance`.\r\n\r\nHowever, you are describing a problem that makes sense to me, so I\'m going to answer the following:\r\n- How do we make a zkApp method authorize a payment with a signature?\r\n- Why do we need `requireSignature()`?\r\n- What do we do if we additionally want to change zkApp state, but we want the `editState` permission to be ""proof""?\r\n\r\nTo the third question: The general model is that each account update can have just one authorization on it. Proof, signature, or none. So, if you want to apply two different updates, one with signature auth, another with proofs, then fundamentally you need to create two different account updates (for the same account).\r\n\r\nAnother thing to say is that `SmartContract` and the `@method` decorator are designed to make it easy to create account updates with proofs. A `@method` will always create a proof-authorized account update on `this.self`, except if it\'s explicitly overriden with `this.requireSignature()` (but then again, such an override doesn\'t make much sense, because you wouldn\'t need a `@method` to do that -- you could create your account update more explicitly, outside a method).\r\n\r\nBut what you can do, and makes sense to me the desired permissions of `editState: proof, send: signature`, is to create a second account update for the zkApp, from which you send:\r\n\r\n```ts\r\n@method withdraw(address: PublicKey) {\r\n  // ... update state on `this` ...\r\n  \r\n  // create separate account update for sending from zkApp\r\n  let update = AccountUpdate.create(this.address);\r\n  update.requireSignature();\r\n  update.send({ to: address, amount: UInt64.from(5) });\r\n}\r\n```\r\n\r\nThere\'s the question of whether you need this `send` code to be part of your `@method`. If it\'s in the method, it\'ll be included in the proof (those sub account updates we create become public input for the proof), and thus linked to whatever else you do in `withdraw` -- which might be what you want.'), ('mitschabaude', 'closing for house keeping')]"
629,Reliably catch compile/prove discrepancies,mitschabaude,open,"Follow-up to #624
- Investigate why a discrepancy between compilation & proving caused an out of bounds error during the `compute_witness` in the Pickles wrap prover
- Exactly identify what in that bug was the underlying problem, and what the course of downstream effects, at a low level
- Find a way to identify this error earlier in the process, such that the error is more closely related to the cause
- Reliably communicate the underlying problem to the user","[('mimoo', ""Interesting, reading https://github.com/o1-labs/snarkyjs/issues/498 it seems like we're trying to access a witness value as part of `exists` (witness generation) or `as_prover` (debug). I think without better errors this will be hard to debug, so if this not urgent perhaps we can wait on getting better errors first""), ('mitschabaude', ""This again cropped up as an important issue as several zkApp testers ran into these kinds of issues and they proved to be extremely hard to debug. A simple first step would be to reliably tell the user if there is a compile / prover discrepancy. It seems to do that we'd need to create a constraint system in the prover and return its digest, in a way that it can be used if the proof fails to identify this as a problem"")]"
627,SnarkyJS error in fetchEvents when multiple event types exist,JPGarzonE,closed,"## Overview

Our team Solus is building a Mixer for Mina Protocol. For the Mixer to work we are emitting a **Deposit event** as a primitive approach to store the Merkle Tree outside the smart contract, also we are emitting a **Nullifier event** to track withdrawals and avoid double-spending. It looks something like this:

```jsx
export class MixerZkApp extends SmartContract {
	...
	events = {
		deposit: DepositClass,
    nullifier: NullifierClass
	}
	...
	@method updateMerkleTree(commitment: Field) {
		...
		this.emitEvent('deposit', deposit);
		...
	}
	@method emitNullifierEvent(nullifierHash: Field) {
		...
		this.emitEvent('nullifier', nullifierEvent);
		...
	}
}
```

Until here everything is ok. The problem comes when **we fetch the events** from the smart contract.

```jsx
...
let zkapp = new MixerZkApp(zkappAddress);
let rawEvents = await zkapp.fetchEvents();
```

On the **first request the events are fetched and all it’s fine**. But, in the second request ( `await zkapp.fetchEvents()` ) this error starts to appear:

![image](https://user-images.githubusercontent.com/45469385/205505547-8a4184ef-9a61-42f8-99bb-b0c9a54845b9.png)

We needed this logic to work to finish the Mixer so we debugged to find if the mistake was on our side. After debugging for a while, we found that the error comes directly from SnarkyJS. Specifically, it happens in the fetchEvents function of the SmartContract class: [https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L971](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L971).


## Conditions to replicate the error

1. The smart contract has more than one type of event.
2. The `smartContract.fetchEvents(…)` function is called more than once.
3. The smart contract is executed on a local blockchain.

## The error in SmartContract.fetchEvents

The problem that is happening between the first and the second request lies on the way Mina stores the events in the LocalBlockchain and the instruction: `event.shift()` in the line 1004 ([https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L1004](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L1004)).

In the Local Blockchain events are stored as an object in memory:

```jsx
const events: Record<string, any> = {};
```

When the events of a specific Public Key are fetched from Mina (the Local Blockchain) the function  `fetchEvents(...)` is not returning a new object, it is returning a reference to the `events` object that already exists. This is due to the way how JS stores compound objects in memory. 

```jsx
// mina.ts in the Local Mina Blockchain
// Line 510:
async fetchEvents(
  publicKey: PublicKey,
  tokenId: Field = TokenId.default
): Promise<any[]> {
  return events?.[publicKey.toBase58()]?.[TokenId.toBase58(tokenId)] ?? [];
}
```

```jsx
// zkapp.ts in SmartContract.fetchEvents(..)
let events = (await Mina.fetchEvents(this.address, this.self.body.tokenId))
      .filter((el: any) => {
        let slot = UInt32.from(el.slot);
        return end === undefined
          ? start.lte(slot).toBoolean()
          : start.lte(slot).toBoolean() && slot.lte(end).toBoolean();
      })
      .map((el: any) => el.events)
      .flat();
// events = [event, event]
// Where each event inside events is a reference to the original event stored in memory.
```

Each one of the events come as an array in the following format:

```jsx
events[i] = event = [eventTypeIndex, ...n]
// where n are the n parameters that the event has.
```

When the map function iterates over each `event` if the smart contract has more than one type of event it executes the following code:

```jsx
...
} else {
  // if there are multiple events we have to use the index event[0] to find the exact event type
  let type = sortedEventTypes[event[0]];
  // all other elements of the array are values used to construct the original object, we can drop the first value since its just an index
  event.shift();
  return {
    type,
    event: this.events[type].fromFields(
      event.map((f: string) => Field(f))
    ),
  };
}
```

The problem happens in line 1007 ([https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L1007](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L1007)) when `this.events[type]` ends up being **undefined** and therefore `this.events[type].fromFields`  fails. The reason why `this.events[type]` is undefined is because in the second request we make (`zkapp.fetchEvents()` )the variable `type` is **undefined**, while in the first request no error occurs because `type` is indeed the type of the event. In our case “deposit” or “nullifier”.

When `event.shift()` is executed it deletes the first element of the `event` array and is logical to think that it doesn’t modify anything beyond the local scope of the callback function inside `events.map` , because the map function by itself is non-destructive. However, the callback inside the map function could be destructive and each event inside `map()` is not a new array, but a reference pointing to the original event array that was fetched from the `Mina` local blockchain at the beginning of the function. So the original events object ends up being mutated.

That is why on the second request to `smartcontract.fetchEvents(...)` the type is ******************undefined,****************** this happens because the element at the first index of the `event` array  is not anymore the index of the type of event (it was deleted in the last execution with the `event.shift()`). Instead it is the element that should be at `event[1]`.

## Quick solution

It could be solved using a non-destructive function such as `.slice()` that creates a new array from the original `event` array.

```jsx
...
} else {
  // if there are multiple events we have to use the index event[0] to find the exact event type
  let type = sortedEventTypes[event[0]];
  // all other elements of the array are values used to construct the original object, we can drop the first value since its just an index
  let eventProps = event.slice(1);
  return {
    type,
    event: this.events[type].fromFields(
      eventProps.map((f: string) => Field(f))
    ),
  };
}
```

## Finally

It is useful to clarify that this error is only an error that happens in local testing when the local blockchain is executed.

When the `fetchEvents` function is implemented in the original Mina network, a remote request to the blockchain is going to be implemented instead of a simple in-memory reference to an `events` object stored in local memory.

```jsx
async fetchEvents() {
  throw Error(
    'fetchEvents() is not implemented yet for remote blockchains.'
  );
},
```

I hope the explanation was not too long.
Thank you for reading guys.",[]
626,The execution result of SmartContract.analyzeMethods() cannot display 'rows',Comdex,closed,"Example code:
```typescript
export class Add extends SmartContract {
  @state(Field) num = State<Field>();

  init() {
    super.init();
    this.num.set(Field(1));
  }

  @method update() {
    const currentState = this.num.get();
    this.num.assertEquals(currentState); // precondition that links this.num.get() to the actual on-chain state
    const newState = currentState.add(2);
    this.num.set(newState);
  }
}

let result = Add.analyzeMethods();
console.log('Add analyze result: ', result);
```

Screenshot of the result:
![issue](https://user-images.githubusercontent.com/3725514/205472806-c7c3f3da-c5a4-459c-aa81-7823b94cb1a6.PNG)

Also, does ZkProgram have a method similar to analyzeMethods?","[('mitschabaude', ""Thanks! I noticed this recently as well and it's already fixed in a PR: https://github.com/MinaProtocol/mina/pull/12123\r\n\r\n`ZkProgram` currently only has `digest()` for the digest, but it would be very easy to add `analyzeMethods()`""), ('mitschabaude', 'done')]"
625,A type error occurs when a Struct containing an array is used as an on-chain variable,Comdex,closed,"This is a test after applying the #567 update：
```typescript
class MyStruct extends Struct({ a: Field }) {}

class MyStructB extends Struct({
  a: Circuit.array(Field, 5),
}) {}

export class TestZkapp extends SmartContract {
  @state(MyStruct) myStruct = State<MyStruct>(); // work
  @state(MyStructB) myStructB = State<MyStructB>(); // type mismatch error
}
```","[('mitschabaude', ""Thanks! The issue makes sense to me - the type error occurs when the state is not guaranteed to consist only of field elements, and Circuit.array doesn't currently return a type which distinguishes this case (in contrast to Struct itself) "")]"
623,Local graphQL endpoint for UI development,mitschabaude,open,"Raised by community member in discord

IS: When developing a UI, the current flow seems to be to deploy the smart contract to Berkeley, and interact via Auro with the deployed contract. This is an awful DX because developing the UI often goes hand in hand with developing / fixing the contract itself. The implied flow seems to be frequent redeployments / refunding, which can't be right.

SHOULD: It's easy to spin up an environment which simulates production, entirely locally. In particular, should include a local graphQL endpoint that Auro can talk with.
","[('bkase', 'I think the easiest way to do this that’s guaranteed to be compatible with Mina is to create some new small ocaml executable that shares the graphql logic. A lot is functored already but we’d probably need to functor a little more to fully make it work. And/or add a flag to the main Mina binary that runs the graphql server but disconnects it from actually doing anything dangerous'), ('Trivo25', 'I wonder if we can directly integrate the web node with SnarkyJS for that purpose  ')]"
621,Regression testing to check that snarkyjs changes don't change deployed circuits,mitschabaude,closed,,"[('Trivo25', 'We could just add a basic verification key comparison to all our integration tests as a short term solution. thoughts? '), ('mitschabaude', '> We could just add a basic verification key comparison to all our integration tests as a short term solution. thoughts?\r\n\r\nI like this idea! We could simply have a command that dumps these into a file, which is checked into git. Then we see when they change. CI could simply check consistency of these dumped vk hashes which the current code')]"
619,merging two proofs causes a domain size error,Trivo25,closed,"```ts
let MyProgram = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [],

      method(publicInput: Field) {
        publicInput.assertEquals(Field(0));
      },
    },

    inductiveCase: {
      privateInputs: [SelfProof, SelfProof],

	  // no good
      method(publicInput: Field, p1: SelfProof<Field>, p2: SelfProof<Field>) {
        // p1 and p2 are proofs from MyProgram.baseCase
        p1.verify();
        p2.verify();
      },
    },
  },
});

```


Merging two proofs recursively `await MyProgram.inductiveCase(Field(1), p1, p2);` causes a domain size error

```
Error: This circuit was compiled for proofs using the wrap domain of size 15, but a proof was given with size 14. You should pass the ~override_wrap_domain argument to set the correct domain size.
```


Would it be enough to pass in the requested argument on the side of SnarkyJS?

https://github.com/MinaProtocol/mina/blob/develop/src/lib/pickles/step_main.ml#L435

note: this is with the ""more up to date"" bindings from mina@develop","[('mitschabaude', '> Would it be enough to pass in the requested argument on the side of SnarkyJS?\r\n\r\nSounds like it!')]"
616,TokenSymbol length check mismatch  ,dkuehr,closed,"In JavaScript the string length property returns the size in number of **characters**, however `String.length` in OCaml returns the size in **bytes**.

Length check in SnarkyJS:
```
class TokenSymbol extends Struct(TokenSymbolPure) {
  static get empty() {
    return { symbol: '', field: Field(0) };
  }

  static from(symbol: string): TokenSymbol {
    if (symbol.length > 6)
      throw Error('Token symbol length should be a maximum of 6');
    let field = prefixToField(symbol);
    return { symbol, field };
  }
}
```

Length check in OCaml:
```
module Token_symbol = struct
  [%%versioned_binable
  module Stable = struct
    module V1 = struct
      module T = struct
        type t = string [@@deriving sexp, equal, compare, hash, yojson]

        let to_latest = Fn.id

        let max_length = 6

        let check (x : t) = assert (String.length x <= max_length)
```
This can end in an inconsistent size check if non-ASCII characters are used, for example:
**node:**
```
> a = '₿₿₿₿₿₿';
'₿₿₿₿₿₿'
> a.length
6
> (new TextEncoder().encode(a)).length
18
```

**utop:**
```
# String.length ""₿₿₿₿₿₿"";;
- : int = 18
```","[('mitschabaude', 'good catch, thanks! @Trivo25 small guardian task?')]"
615,`ZkProgram` integration test,Trivo25,closed,"The recursion API is arguably one of SnarkyJS' main feature, and will potentially play an important building block in larger zkApp applications, yet we dont have any tests for it, which allows to easily sneak in bugs or small mistakes like this one https://github.com/o1-labs/snarkyjs/issues/605

TODO first: fix https://github.com/MinaProtocol/mina/blob/develop/src/lib/snarky_js_bindings/test_module/inductive-proofs.js","[('mitschabaude', 'I think the most important item would be improving the recursion test which is already in the Mine repo (since that is where recursion is most likely to break): https://github.com/MinaProtocol/mina/blob/develop/src/lib/snarky_js_bindings/test_module/inductive-proofs.js')]"
614,Change permissions hash input to ease mina-signer compatibility,mitschabaude,closed,,[]
611,Reduce Mina Signer below <4MB,jasongitmail,closed,"FireFox has a file size limit for extensions of 4MB. Achieving this will allow Firefox-extensions wallets to support zkApps!

Work is underway currently that should contribute to this goal.

Tagging @bitcat365 so you can track this.

Creating an issue to track on the roadmap.",[]
610,Reduce SnarkyJS MB file size,jasongitmail,open,"Creating an issue to track for the roadmap. Goal to make zkApp UIs more performant given SnarkyJS is is required to be loaded client side, it should be a reasonable KB/MB size.

To discuss and plan approach.

Targeted Q1 2023.","[('stevenpack', 'How big is the bundle now?'), ('mitschabaude', ""> How big is the bundle now?\r\n\r\n@stevenpack It's about 13MB iirc""), ('MartinMinkov', 'https://bundlephobia.com/package/snarkyjs@0.9.5 \r\nJust slightly less :D '), ('jasongitmail', ""@stevenpack Worth mentioning that the primary cause is due to the JSOO (JS of Ocaml) library's code generation and related headaches and barriers to refactoring that it causes. Nonetheless, Product Eng team came up with ideas to help mitigate this in a material way during our team off site, which I'll document into a PRD."")]"
609,Reduce SnarkyJS memory requirements,jasongitmail,closed,"Creating an issue to track for the roadmap. Goal to make SnarkyJS and zkApp work on more run times, such as free-tiers of serverless functions like Vercel and Cloudflare Pages.

To discuss and plan approach.

Targeted Q1 2023.","[('jasongitmail', 'Next step is to Investigate memory consumption of workers https://github.com/o1-labs/snarkyjs/issues/726')]"
608,SnarkyJS for off-chain use cases (i.e. P2P use cases),jasongitmail,open,"Goal: Allow SnarkyJS to be used for generating ZKPs and verifying them even without Mina.

To discuss:
- Is ZkProgram already sufficient for this?
- If so, we should document as a section in the ReadMe, overviewing that it can be used for this purpose, and where to find full documentation for this type of use case. We might even want a tutorial describing this.

Likely Q1 2023, unless it fits in this Q4.",[]
607,Develop matrix tests to ensure SnarkyJS runs across more target platforms,jasongitmail,open,"Q1 2023. Creating an issue to track on roadmap.

- Browsers: Chrome, Firefox, Safari, Brave.
- Platforms: Mac, Windows, Linux
- Mobile (lower priority): Android (Chrome & Brave), iOS (Chrome & Brave)

To discuss if others should be added.",[]
606,Fetch events (from Archive Node API),jasongitmail,closed,"Creating an issue to track on roadmap.
Related: https://github.com/o1-labs/snarkyjs/issues/606 ","[('nicc', 'Indirectly Irresponsible Individual: \n- @bkase if Martin does the work\n- @MartinMinkov if someone else does')]"
605,verifying a `ZkProgram` proof inside a smart contract breaks ,Trivo25,closed,"works before SnarkyJS `0.7.0`

```ts

let MyProgram = Experimental.ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [],

      method(publicInput: Field) {
        publicInput.assertEquals(Field(0));
      },
    },
  },
});

class MyProof extends Proof<Field> {
  static publicInputType = Field;
  static tag = () => MyProgram;
}

class SimpleZkapp extends SmartContract {
  deploy(args: DeployArgs) {
    super.deploy(args);
    this.setPermissions({
      ...Permissions.default(),
      send: Permissions.proof(),
    });
  }

  @method verify(p: MyProof) {
    p.verify(); // no good
  }
}

```
`bad verify: dlog_check`

edit: bindings need to be updated to include the original fix https://github.com/MinaProtocol/mina/pull/11698


after some investigating, i figured using the bindings from https://github.com/MinaProtocol/mina/pull/11698 work for both the example above as well as https://github.com/o1-labs/snarkyjs/blob/main/src/examples/program.ts#L53
but a newer change in the mina repo broke both code snippets, not sure which one yet - it seems to be similar to https://github.com/MinaProtocol/mina/issues/11389, which has been fixed a while ago and worked fine after the fix","[('mitschabaude', ""noooo! 😭 \r\n\r\n> but a newer change in the mina repo broke both code snippets, not sure which one yet\r\n\r\nthat's a great find, could mean this can be fixed fairly easily.\r\n\r\nwe need a unit-test in the Mina repo to prevent this in the future!"")]"
604,Profile SnarkyJS CI testing,bkase,closed,"Bonus points if CI runs always generate the speeds of the runs of the tests

And suggest plan to make improvements","[('Trivo25', ""## 'Benchmark' existing tests\r\n\r\n### Option 1:\r\n\r\n\r\nGitHub actions lets us display console output (markdown) under the [Summary tab of each PR.](https://github.com/o1-labs/snarkyjs/actions/runs/3627763351) We can slightly modify existing tests to print and temporary store output, capturing the time it takes to run each integration test and its sections, and then displaying it under the Summary tab.\r\nThis would require us to simply add a handful of helper functions to the integration tests and modify the CI workflow slightly. This could also be extended to include automatic commenting on PRs after the CI ran.\r\n\r\n![image](https://user-images.githubusercontent.com/22175568/205929970-0cb7a171-a920-4d40-b22e-e151f9a4c8eb.png)\r\n\r\n\r\n#### Benefits: \r\n- simple and straightforward - no additional JS or GitHub Action library required ([such as this one](https://github.com/benchmark-action/github-action-benchmark))\r\n\r\n### Option 2:\r\n\r\n\r\nA second option would be to use an existing GitHub Action library, [such as this one.](https://github.com/benchmark-action/github-action-benchmark). In addition to the GitHub Action library, an additional [JavaScript library ](https://benchmarkjs.com/) would be required. \r\n\r\n#### Benefits: \r\n- ready-to-go solution with lots of custom options \r\n\r\n#### Disadvantages: \r\n- introduction of new 3rd party libraries \r\n- severe changes in our existing integration in order to be compatible with [BenchmarkJS](https://benchmarkjs.com/)\r\n\r\n"")]"
602,It is possible to cache an invalid Account entity,shimkiv,open,"When we call [addCachedAccount](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L364), which in turn calls [addCachedAccountInternal](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L379), we are not ""validating"" (In quotes because I doubt we have validation other than just trying to cast data to some types when we need it. Please correct me if I'm wrong) passed values as Account fields.
Which means that we can cache Account with `nonce` == `'test'`.
But then, should we try to retrieve cached data by calling [Mina.getAccount](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/mina.ts#L586) -> [Fetch. getCachedAccount](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L355), it will try to get the [UInt32 from stored Nonce](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L232) and will fail.

So we should validate data (at least maybe do `Fetch.parseFetchedAccount`) before caching it.",[]
601,Make `PrivateKey.fromBase58` throw human readable error,shimkiv,open,"- `PublicKey.fromBase58('test')`
  - Will result in error like this:

  ```shell
  Error decoding test
  Invalid base58 check length in Non zero curve point compressed
  <stacktrace>
  ``` 

- Where `PrivateKey.fromBase58('test')`
  - Will result in error like this:

  ```shell
  [
    0,
    [
      248,
      MlBytes {
        t: 0,
        c: 'Base58_check.Invalid_base58_check_length',
        l: 40
      },
      201
    ],
    MlBytes { t: 0, c: 'Private key', l: 11 }
  ]
  <stacktrace>
  ``` 
","[('mitschabaude', 'should be done when moving base58 to JS')]"
600,Check cached entity validity during the `Mina.getAccount` call,shimkiv,open,"We are not checking cached entity validity in [getCachedAccount](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L346). 
Do you think we should check it and act accordingly if cached entity expired (for example, remove it from cache and return `Could not find account for public key ...` error)?",[]
599,Make cache invalidation timeout to be configurable,shimkiv,closed,[This one](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L293).,[]
598,Add JSDoc for Token.Id.toBase58,shimkiv,open,"The [addCachedAccount](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L364)'s `tokenId` might serve as an example:
- In order for cached entity then be successfully retrieved the `tokenId` should be `Base58` encoded value: `tokenId: Token.Id.toBase58(Field)`.
  - But there is no JSDoc about it.",[]
597,Export Fetch.Account type,shimkiv,closed,An [Account type](https://github.com/o1-labs/snarkyjs/blob/7e3323ef638900cbf3c9f5ecc8e85597fefa5448/src/lib/fetch.ts#L149) might be useful for TS code-bases operating with the fetched data using SnarkyJS API.,"[('mitschabaude', 'we have an exported account type now')]"
595,Infinite loop in HTLC contract,mitschabaude,open,"found by @maht0rz

https://github.com/stove-labs/zk-htlc/blob/develop/src/HTLCPoseidonExperimentalToken.test.ts#L230

""if you run this test and uncomment the account update you should get a reproduction""",[]
593,Create API for abstracting delegate calls,mitschabaude,open,,[]
592,Consider changing TokenId to TokenManager,es92,open,"TokenIds refer to addresses on chain that are managing accounts, may be more clear / straightforward just to call this field ""tokenManager"" instead.",[]
591,Figure out default behaviour of approve(),mitschabaude,open,,[]
590,Fix DEX example,es92,open,"DEX example may have a bug in it, where the tokens are not constraining accountUpdates they approve to not themselves delegate permissions to their own children, and in those children doing things like minting new tokens

It seems it would be nice for a token manager to be able to assert that its approving an account update that is a delegate, but that the accountUpdate isn't delegating approval to any of its children (without constraining the layout on whether that accountUpdate has children or not)",[]
589,zk deploy cannot properly init(),mitschabaude,closed,,[]
584,Signature.create has an error on 0.7.1,garethtdavies,closed,"`Signature.create` code that runs fine on 0.6.1 has the following error on 0.7.1. 

```
RuntimeError: unreachable
    at __rust_start_panic (wasm://wasm/00ed389a:wasm-function[4204]:0x3430eb)
    at rust_panic (wasm://wasm/00ed389a:wasm-function[3928]:0x341c6d)
    at std::panicking::rust_panic_with_hook::hcd0f3006e112fe69 (wasm://wasm/00ed389a:wasm-function[2713]:0x31433a)
    at std::panicking::begin_panic_handler::{{closure}}::ha35255d71697b9ae (wasm://wasm/00ed389a:wasm-function[3237]:0x331950)
    at std::sys_common::backtrace::__rust_end_short_backtrace::h72f22853983ad44b (wasm://wasm/00ed389a:wasm-function[3853]:0x341035)
    at rust_begin_unwind (wasm://wasm/00ed389a:wasm-function[3604]:0x33cab9)
    at core::panicking::panic_fmt::h8a9336616e964b26 (wasm://wasm/00ed389a:wasm-function[3796]:0x3404ad)
    at std::thread::local::lazy::LazyKeyInner<T>::initialize::h4675b3180ce7bb87 (wasm://wasm/00ed389a:wasm-function[1656]:0x2b1e30)
    at std::thread::local::fast::Key<T>::try_initialize::hfaf76c330c917edb (wasm://wasm/00ed389a:wasm-function[3870]:0x34134e)
    at rand::rngs::thread::thread_rng::ha5093cd7f22a3619 (wasm://wasm/00ed389a:wasm-function[3466]:0x3393c1)
```

For example, from the Oracle tutorial https://github.com/jackryanservia/mina-credit-score-signer/blob/main/index.js#L37.

```
const id = Field(5);
const creditScore = Field(700);

const signature = Signature.create(privateKey, [id, creditScore]);
```

Simply downgrading to 0.6.1 will resolve the error.","[('mitschabaude', ""Hey @garethtdavies, can you provide a full example that doesn't work? I tested the following, which seems like exactly your example with the missing privateKey filled in, and it works for me:\r\n```ts\r\nimport { Field, isReady, PrivateKey, Signature } from 'snarkyjs';\r\n\r\nawait isReady;\r\n\r\nconst privateKey = PrivateKey.fromBase58(\r\n    'EKF65JKw9Q1XWLDZyZNGysBbYG21QbJf3a4xnEoZPZ28LKYGMw53'\r\n);\r\nconst id = Field(5);\r\nconst creditScore = Field(700);\r\nconst signature = Signature.create(privateKey, [id, creditScore]);\r\n\r\nconsole.log(signature.toJSON());\r\n```""), ('garethtdavies', 'In testing this, it seems I updated to 0.7.2, and the issues disappeared! I can still repro this if using 0.7.1 so adding the below for completeness.\r\n\r\n---\r\nWeird. I\'m running this as a lambda function, and it seems it\'s there where the error is coming from.\r\n\r\nWorks:\r\n\r\n```ts\r\nimport { Field, isReady, PrivateKey, Signature, shutdown } from \'snarkyjs\';\r\n\r\n(async function main() {\r\n  await isReady;\r\n\r\n  console.log(\'SnarkyJS loaded\');\r\n\r\n  await isReady;\r\n\r\n  const privateKey = PrivateKey.fromBase58(\r\n    \'EKF65JKw9Q1XWLDZyZNGysBbYG21QbJf3a4xnEoZPZ28LKYGMw53\'\r\n  );\r\n  const id = Field(5);\r\n  const creditScore = Field(700);\r\n  const signature = Signature.create(privateKey, [id, creditScore]);\r\n\r\n  console.log(signature.toJSON());\r\n\r\n  // ----------------------------------------------------\r\n\r\n  console.log(\'Shutting down\');\r\n\r\n  await shutdown();\r\n})();\r\n```\r\n\r\nErrors:\r\n\r\n```ts\r\nimport { Field, isReady, PrivateKey, Signature, shutdown } from \'snarkyjs\';\r\n\r\nexports.handler = async (event) => {\r\n\r\n  await isReady;\r\n\r\n  console.log(\'SnarkyJS loaded\');\r\n\r\n  await isReady;\r\n\r\n  const privateKey = PrivateKey.fromBase58(\r\n    \'EKF65JKw9Q1XWLDZyZNGysBbYG21QbJf3a4xnEoZPZ28LKYGMw53\'\r\n  );\r\n  const id = Field(5);\r\n  const creditScore = Field(700);\r\n  const signature = Signature.create(privateKey, [id, creditScore]);\r\n\r\n  console.log(signature.toJSON());\r\n\r\n  // ----------------------------------------------------\r\n\r\n  console.log(\'Shutting down\');\r\n\r\n  await shutdown();\r\n\r\n};\r\n```\r\n\r\n```\r\nRuntimeError: unreachable\r\n    at __rust_start_panic (wasm://wasm/00ed389a:wasm-function[4204]:0x3430eb)\r\n    at rust_panic (wasm://wasm/00ed389a:wasm-function[3928]:0x341c6d)\r\n    at std::panicking::rust_panic_with_hook::hcd0f3006e112fe69 (wasm://wasm/00ed389a:wasm-function[2713]:0x31433a)\r\n    at std::panicking::begin_panic_handler::{{closure}}::ha35255d71697b9ae (wasm://wasm/00ed389a:wasm-function[3237]:0x331950)\r\n    at std::sys_common::backtrace::__rust_end_short_backtrace::h72f22853983ad44b (wasm://wasm/00ed389a:wasm-function[3853]:0x341035)\r\n    at rust_begin_unwind (wasm://wasm/00ed389a:wasm-function[3604]:0x33cab9)\r\n    at core::panicking::panic_fmt::h8a9336616e964b26 (wasm://wasm/00ed389a:wasm-function[3796]:0x3404ad)\r\n    at std::thread::local::lazy::LazyKeyInner<T>::initialize::h4675b3180ce7bb87 (wasm://wasm/00ed389a:wasm-function[1656]:0x2b1e30)\r\n    at std::thread::local::fast::Key<T>::try_initialize::hfaf76c330c917edb (wasm://wasm/00ed389a:wasm-function[3870]:0x34134e)\r\n    at rand::rngs::thread::thread_rng::ha5093cd7f22a3619 (wasm://wasm/00ed389a:wasm-function[3466]:0x3393c1)\r\n```\r\n\r\nDowngrading to 0.6.1 there gives the following as expected. \r\n\r\n```\r\nSnarkyJS loaded\r\n{\r\n  r: \'9609558609758267729887803952687425996784317494843638088367426034244333889615\',\r\n  s: \'14689337198728423219719947452717875817203572181426613680192871699772225550127\'\r\n}\r\nShutting down\r\n```\r\n\r\nRunning this via adding to `package.json` and `npm run locally`.\r\n\r\n```\r\n""scripts"": {\r\n    ""build"": ""tsc -p tsconfig.json"",\r\n    ""locally"": ""node -e \\""console.log(require(\'./index\').handler());\\""""\r\n  }\r\n```\r\n'), ('mitschabaude', ""Thanks! Let's just be happy and close it then :D "")]"
583,Make main the release branch,mitschabaude,closed,,"[('bkase', ""Let's make this change in the short term since it will be more consistent with zkapp-cli -- longer term we'll think holistically about the whole releases of our products carefully"")]"
582,Automate main -> berkeley merge,mitschabaude,open,,"[('bkase', 'Ask velocity team to follow-up on this.\n\n(Pain quantification: ~30min per PR you have to do this for, and this is necessary most of the time you are making PRs)')]"
579,Add back timestamp precondition by wrapping global slot,mitschabaude,closed,"This PR: https://github.com/MinaProtocol/mina/pull/12234
removes the timestamp precondition. However, that precondition is a very user-friendly way to access the current time in a smart contract. We should bring it back on the `berkeley` branch by adding a wrapper around `globalSlotSinceGenesis`","[('jasongitmail', 'needs mini RFC')]"
577,Implement signatures for mina-signer,mitschabaude,closed,,[]
576,"When the custom Struct contains member methods, there will be a type mismatch when using Circuit.switch and Circuit.witness",Comdex,closed,"Example: 
```typescript
class TestStruct extends Struct({ x: Field, y: Field }) {
  add(): Field {
    return this.x.add(this.y);
  }
}

let newStruct1 = new TestStruct({x: Field(1), y: Field(2)});
let newStruct2 = new TestStruct({x: Field(3), y: Field(4)});
// type mismatch error
let b = Circuit.switch([Bool(true), Bool(false)], TestStruct, [newStruct1, newStruct2]);
let witness = Circuit.witness(TestStruct, () => {
  return new TestStruct({x: Field(1), y: Field(2)});
})
```","[('mitschabaude', ""Thanks! This is one of several problems with Struct that came up, and they all come down to the same issue:\r\n**A class `A extends Struct(...)` with custom member methods doesn't extend `Provable<A>`**\r\n\r\nI started tackling this [in a PR](https://github.com/o1-labs/snarkyjs/pull/567) already, but it needs more fixes still."")]"
575,"Make it possible to not have an init method, so the zkApp private key holder can't reset the state",es92,closed,"At the moment, all zkApps are given an init method, which the holder of the private key can call to reset state.

It should be possible to create a zkApp where the private key holder can't reset the state.

Would advocate for removing the init method, instead performing initialization inside deploy, to have fewer special functions for developers to learn how to use","[('mitschabaude', ""This is a misunderstanding - the init method doesn't change anything about the permissions, which solely determine whether the private key owner can reset the state. By default, the permissions for setting state are `proof`, which means that the zkApp owner can't call init. However, also by default, the zkApp owner has the option to change back permissions, and reset the state.\r\n\r\nIf there were no init method, then a transaction similar to the following would be sufficient to reset the state:\r\n```ts\r\nMina.transaction(() => {\r\n  // reset permissions\r\n  let update = AccountUpdate.create(zkappAddress);\r\n  update.account.permissions.set({ editState: Permissions.signature() });\r\n  update.requireSignature();\r\n\r\n  // reset state and change permission back\r\n  let update2 = AccountUpdate.create(zkappAddress);\r\n  update2.account.appState.map(state => state.set(Field(0)));\r\n  update2.account.permissions.set({ editState: Permissions.proof() });\r\n  update2.requireSignature();\r\n})\r\n```\r\n\r\nThe init method is nothing more than the line which wipes out the state. So, with an init method, the owner could do the same transaction with `init()` by slightly changing the code above (but they don't have to):\r\n```diff\r\n  // reset state and change permission back\r\n- let update2 = AccountUpdate.create(zkappAddress);\r\n- update2.account.appState.map(state => state.set(Field(0)));\r\n+ let zkapp = new MyContract(zkappAddress);\r\n+ zkapp.init();\r\n+ update2 = zkapp.self;\r\n  update2.account.permissions.set({ editState: Permissions.proof() });\r\n  update2.requireSignature();\r\n```""), ('bkase', 'Closing since this is a misunderstanding -- feel free to open more issues if you find other issues'), ('es92', ""I guess I was seeing the init method as a way that a zkApp creator could reset state, but it sounds like maybe not? (was reading original RFC; no because its not an @method right?)\r\n\r\nWant to confirm, if one wanted to make a zkApp where the creator couldn't reset the state, sounds like that is separate in that case? @mitschabaude ""), ('mitschabaude', ""> Want to confirm, if one wanted to make a zkApp where the creator couldn't reset the state, sounds like that is separate in that case? @mitschabaude\r\n\r\nTo make the creator unable to reset state for good, he needs to remove his ability to change the permissions -- there's a permission for that: `setPermissions: Permissions.impossible()`\r\n\r\nThat, plus `editState: Permissions.proof()`, and only the smart contract code can ever determine how state is set.""), ('es92', 'Thanks, super helpful. Could one then have `setPermissions: Permissions.proof()`? (and have a smart contract method that changes permissions?)'), ('mitschabaude', '> Thanks, super helpful. Could one then have `setPermissions: Permissions.proof()`? (and have a smart contract method that changes permissions?)\r\n\r\nYes, you can have that!')]"
574,Put MerkleWitness on MerkleTree so that height is baked in,bkase,open,"```
const tree = new Experimental.MerkleTree(height);
class MerkleWitness extends Experimental.MerkleWitness(height) {}
```

It's a bit awkward to have to extend a class for each different type of MerkleTree height -- also we only catch height mis-match errors at runtime.

Instead could we make `MerkleTree` and `MerkleWitness` have a compile-time generic argument for the height (which in all use-cases I can come up with in 30 seconds of thinking about it, we'll always know at compile time) for better safety and less awkward needs for eg making a `MerkleWitness20` and a `MerkleWitness32` etc ala https://github.com/o1-labs/docs2/pull/101/files","[('mitschabaude', ""The reason we extend classes in APIs like this is that a class is, to my knowledge, the only way to create a type which is simultaneously recognized as a _value_ by decorators.\r\n\r\nThe method decorator does some magic where you only specify the method arguments as _types_:\r\n```ts\r\n@method myMethod(arg: MerkleWitness20) {}\r\n```\r\n...and then we're able to get a corresponding JS value, which is the class `MerkleWitness20`. We need this so that in the circuit wrapper code, we can convert the method arguments to witnesses. So in principle our code will do this:\r\n```ts\r\nlet modifiedArg = Circuit.witness(MerkleWitness20, () => arg);\r\n```\r\nIn the code above, it's important that the number 20 is baked in because it determines the Merkle witnesses' size in field elements.\r\n\r\nSo the gist is: For each different representation as field elements, we need a different class.\r\n\r\nThere's no way to reuse one generic class for different types which differ in their representation as field elements, because the decorator doesn't give us metadata about the generic type argument.""), ('mitschabaude', ""In a non-class API without decorators, we wouldn't need to create a type with a special name, but we would still need to create a special value. So for example, the following syntax would work  for ZkProgram:\r\n\r\n```ts\r\n// ...\r\nmethods: {\r\n  myMethod: {\r\n    privateInputs: [MerkleWitness(20)] // no class extending, just call a function to create your value\r\n    \r\n    method(arg: MerkleWitness) { // type could be just one type or also have a generic argument\r\n    }\r\n  }\r\n}\r\n```""), ('bkase', 'Maybe consider embedding `MerkleWitness` under the `MerkleTree` -- `MerkleTree.MerkleWitness` so they share the same height?')]"
573,Implement Poseidon for mina-signer,mitschabaude,closed,,[]
571,"`Circuit.log();` on AccountUpdate fails with `Field is not constant, can't read its value`",Trivo25,closed,,"[('mitschabaude', 'argh it should try .. catch `Field.toConstant()` instead')]"
570,Question regarding safety of modifying the encrypt method,ckartik,open,"I notice here that we determinately produce the first block of the keystream [here](https://github.com/o1-labs/snarkyjs/blob/14355cf5bca87ae27b44c31cbd188f0b32775d5e/src/lib/encryption.ts#L18-L25): 

```typescript
  let sponge = new Poseidon.Sponge();
  sponge.absorb(sharedSecret.x); // don't think we need y, that's enough entropy

  // encryption
  let cipherText = [];
  for (let i = 0; i < message.length; i++) {
    let keyStream = sponge.squeeze();
    let encryptedChunk = message[i].add(keyStream);
```

If the *shared secret* is repeatedly re-used would the encryption method here be susceptible to an attack (I see you're creating a random one for every call, the scenario I'm referring to would be if we exclusively wanted to re-use the asymmetric key)?

My thought here is if one were to reuse the secret key, we would see the following:
Given {0, 1, ... i, i+1, ... n}, let `d_{i}` represents the first block of plaintext `m_[i}`, and i represents the ith message in a list of n messages. And K represents the first block-sized output of the keystream from Poseidon.

// Resulting encrypted payload if we reuse the sym key, for all n messages would be
      - C1 = d1 + k
      - C2 = d2 + k
      - C3 = d3 + k
      - Cn = dn + k
Could one subsequently re-derive k in this scenario? I know this would be straightforward if the combination mechanism for our one-time pad with the keystream was an XOR but since it's addition over a prime field, does the risk remain.

E.g if we do C1 + C2 = d1 + d2 + 2k, if the underlying d_{i} follows a non-uniform distribution, do we leak information about k on every encryption?
     ",[]
569,Debug unit tests failures in CI,mitschabaude,closed,,[]
564,Rationale for large address size,ckartik,closed,"Unlike Ethereum which takes the last 20 bytes of the hash of the public key, Mina uses a 55-byte address. Since a Field element is bounded to ~32 bytes of data, what was the rationale for using such a large address size? It makes computation with addresses hard, I'm curious what the tradeoffs were?","[('mitschabaude', 'This should probably be an issue on the [Mina repo](https://github.com/MinaProtocol/) where this decision was made long ago. What I can say is that our addresses have the beautiful property that they _are_ the public key, so they can be used directly for other things you do with public keys, like verifying signatures. In a sense it\'s simpler than to have two separate concepts of ""public key"" and ""address"" and to store both of them.\r\n\r\nMaybe @bkase can give actual insights into why our approach was chosen!\r\n'), ('ckartik', ""I appreciate the public key being the address. I guess it's possible a Field was 512 Bits in size. I recall reading that Mina reduced the Field Size for circuit performance. Thanks for the response! ""), ('mitschabaude', 'A Field actually has just 255 bits / 32 bytes, but the size blows up by base58 encoding I guess')]"
563,Use parallelization on Github Actions builds,jasongitmail,closed,"To reduce time. 

https://www.testmo.com/guides/github-actions-parallel-testing","[('mitschabaude', 'done')]"
562,Rename: `Experimental.Callback` -> `Experimental.TokenCallback`,MartinMinkov,closed,"## Description

Taken from [this](https://github.com/o1-labs/docs2/pull/104/files#r1019728713) comment on a PR regarding docs on custom tokens.

To quote:
""Callback is token specific right? If so, we might want to think of a different name like TokenCallback b/c otherwise we risk devs thinking it's a generic and trying to use it for other purposes. ...""


This brings up a good point about the naming of `Callback.` It's intended purpose is to be used to approve token transfers, however, it can be used in a general way for a zkApp to generate AccountUpdates from other methods. ","[('mitschabaude', '-1. Callback is not token-specific and it\'s fine to use it for other purposes. Callback is just a nicer way of calling a method, taking the account update that it produced and passing that account update as input to a different method (well, not sure it\'s actually ""nicer"" with the current API, but it could be)'), ('bkase', 'Closing because callback can be used in non-token contexts too')]"
559,Discussion: Refactor internal CircuitValues to use Struct instead,MartinMinkov,open,"## Description
We have several useful primitives exposed in SnarkyJS that are implemented with the deprecated `CircuitValue` class. An example of such a primitive is the Merkle Tree implementation.

Should we refactor such primitives to use `Struct` instead?","[('bkase', 'Will start with a subset -- and will identify the list of tasks'), ('MartinMinkov', ""Identified the following classes that extend `CircuitValue` that is used internally:\r\n\r\n**In src/lib**\r\n```sh\r\n$ find src/lib -type f -name '*.ts' | xargs grep -n '.* extends CircuitValue'\r\nsrc/lib/merkle_map.ts:116:export class MerkleMapWitness extends CircuitValue {\r\nsrc/lib/merkle_tree.ts:149:class BaseMerkleWitness extends CircuitValue {\r\nsrc/lib/signature.ts:11:class PrivateKey extends CircuitValue {\r\nsrc/lib/signature.ts:77:class PublicKey extends CircuitValue {\r\nsrc/lib/signature.ts:184:class Signature extends CircuitValue {\r\nsrc/lib/string.ts:9:class Character extends CircuitValue {\r\nsrc/lib/string.ts:37:class CircuitString extends CircuitValue {\r\nsrc/lib/int.ts:12:class UInt64 extends CircuitValue {\r\nsrc/lib/int.ts:248:class UInt32 extends CircuitValue {\r\nsrc/lib/int.ts:480:class Sign extends CircuitValue {\r\nsrc/lib/int.ts:525:class Int64 extends CircuitValue implements BalanceChange {\r\n```\r\n**In src/examples**\r\n```sh\r\n$ find src/examples/ -type f -name '*.ts' | xargs grep -n '.* extends CircuitValue'\r\nsrc/examples/sudoku/sudoku-zkapp.ts:15:class Sudoku extends CircuitValue {\r\nsrc/examples/schnorr_sign.ts:12:class Witness extends CircuitValue {\r\nsrc/examples/zkapps/merkle_tree/merkle_zkapp.ts:41:class Account extends CircuitValue {\r\nsrc/examples/zkapps/local_events_zkapp.ts:27:class Event extends CircuitValue {\r\nsrc/examples/zkapps/voting/member.ts:21:export class Member extends CircuitValue {\r\nsrc/examples/zkapps/voting/election_preconditions.ts:3:export default class ElectionPreconditions extends CircuitValue {\r\nsrc/examples/zkapps/voting/participant_preconditions.ts:3:export default class ParticipantPreconditions extends CircuitValue {\r\nsrc/examples/rollup/wip.ts:43:class RollupAccount extends CircuitValue {\r\nsrc/examples/rollup/wip.ts:49:class RollupTransaction extends CircuitValue {\r\nsrc/examples/rollup/wip.ts:56:class RollupDeposit extends CircuitValue {\r\nsrc/examples/rollup/wip.ts:61:class RollupState extends CircuitValue {\r\nsrc/examples/rollup/wip.ts:66:class RollupStateTransition extends CircuitValue {\r\nsrc/examples/rollup/merkle_proof.ts:24:  verify<T extends CircuitValue>(commitment: Field, x: T): Bool {\r\nsrc/examples/rollup/merkle_proof.ts:30:export function MerkleAccumulatorFactory<A extends CircuitValue>(\r\nsrc/examples/rollup/merkle_proof.ts:125:export abstract class IndexedAccumulator<A> extends CircuitValue {\r\nsrc/examples/rollup/merkle_proof.ts:134:  K extends CircuitValue,\r\nsrc/examples/rollup/merkle_proof.ts:135:  V extends CircuitValue\r\nsrc/examples/rollup/merkle_stack.ts:4:export class MerkleStack<A extends CircuitValue> {\r\nsrc/examples/rollup/merkle_stack.ts:11:  static pushCommitment<B extends CircuitValue>(x: B, comm: Field): Field {\r\n```\r\nI will start to tackle some of these in follow up PRs""), ('mitschabaude', ""Here's a challenge that I just remembered: Some of the old-style APIs like `Circuit.if` which rely on `Provable<T>` stuff like `toFields`, don't take the Provable as input, but instead rely on magically figuring out `toFields`, first by looking for instance methods `toFields`  / `fromFields` and then by other means. This won't currently work for Structs, unless they are manually given those instance methods.\n\nI would actually suggest requiring the Provable argument, as we do in most other APIs already:\n```ts\nCircuit.if(someBool, MyStruct, structA, structB)\n```\n(this is already one of the supported function signatures; I'd make it the only one)""), ('MartinMinkov', 'Yup! I ran into this while refactoring `PublicKey` :sweat: That sounds good!')]"
557,Change default `send` permission to `proof`,mitschabaude,closed,,[]
556,Error message for approve(this.self),mitschabaude,open,"you fundamentally can't call a different contract which approves your own account update -- there's a cycle of who is whose parent / who ends up in whose public input.

since this comes up in real implementations, there needs to be an error message for this case. Right, now, the pattern of approving this.self seems to rip this.self out of the transaction entirely and cause an empty tx!",[]
554,Potential security hole in this.approve() ,mitschabaude,open,"Atm, `this.approve()` adds a check that the approved update is a `Call` (not `Delegate_call`). This was meant to imply that this update's own children are not approved. However, I now think this property doesn't hold if the children are `Delegate_call` themselves. This should be investigated, and, if necessary, fixed such that by default, nothing else is approved besides the input account update","[('bkase', 'Will dig into the details of how we could fix this later this week'), ('mitschabaude', 'same as #554. this will cause a constraint change in some existing contracts')]"
547,Usage of If Conditional rather than Circuit.If,ckartik,closed,"I'm curious how snarky is able to use an if branch statement from javascript in the snarky.js code. I was under the assumption that since this compiles to a circuit, that wouldn't be possible. Code [here](https://github.com/o1-labs/snarkyjs/blob/0f17d725d004bda9ac1ca6a9b896713258a5d55e/src/lib/encryption.ts#L12-L63).
```typescript
    let keyStream = sponge.squeeze();
    let encryptedChunk = message[i].add(keyStream);
    cipherText.push(encryptedChunk);
    
    // Here you can see the use of if statments.
    if (i % 2 === 1) sponge.absorb(cipherText[i - 1]);
    if (i % 2 === 1 || i === message.length - 1) sponge.absorb(cipherText[i]);
  }
  ```","[('mitschabaude', ""The answer is that JS is not compiled. It is just executed to add constraints to a circuit. You can see the if conditions as a sort of metaprogramming, which determine what constraints to add to the circuit.\r\n\r\n@ckartik I'd be interested what part of our docs/material gave you the assumptions that JS compiles to a circuit, and that you can't use if statements like we use them here. I'd like to fix this since it's a misconception that I've seen very often.""), ('ckartik', ""I don't think I follow, so if I import the encrypt function from snarky, it doesn't actually import the branching logic the encrypt function consists of. I'm guessing this all compiles down to a circuit, so I don't quite understand why the imported logic wouldn't as well?\r\n\r\nTo reply to your second point I think having a mental model of the compilation process (like the one I currently have for traditional sequential programs or interpreted languages) is important. I noticed you've got extensive details in the O(1) Labs notebook, and I'll take a look at it. Having a mid-level description in the Mina docs would be helpful. I find the high-level description to be too high-level to yield value and the O(1) Labs notebook details to be too low-level for me to quickly iterate with the technology and learn along the way. Hope this helps! You guys are doing an amazing job! 😄 ""), ('mitschabaude', '> I\'m guessing this all compiles down to a circuit, so I don\'t quite understand why the imported logic wouldn\'t as well?\r\n\r\nNo - zkApp code (both user-written and the code in our lib) doesn\'t ""compile down to a circuit"", in the sense that JS is transformed into something else. Instead, the way snarkyjs works, is that the JS code (for example, the SmartContract method) is _executed_, and the different functions (like Field.add, Poseidon.hash,..) add constraints to a current circuit while they run.\r\n\r\nSo the code you write can be any Javascript, that, when executed, creates the constraints that you want. As such, there\'s no limitation on what JS language constructs you can use. '), ('mitschabaude', '> Having a mid-level description in the Mina docs would be helpful.\r\n\r\nThis is good feedback. We were discussing internally about adding a ""snarkyjs under the hood"" section that would explain stuff like this. ')]"
545,Use trick to get width 3 merkle trees,mitschabaude,open,"...at almost no additional cost compared to binary Merkle trees, but allowing much more leaves!

As far as I understand, the trick works as follows:

For every pair of tree nodes `x`, `y` that are hashed, we add a third element `z` _to the hash_ to get the parent of `x`, `y`, `z`.

$$\mathrm{parent} = \mathrm{hash}(x, y) + z$$","[('rpanic', ""Possible attack scenario:\r\nThe adversary wants to prove an arbitrary `y'`. They could just calculate `h2 = hash(x, y')` and set the witness `z' = hash(x, y) - h2 + z`. \r\nWith `x, y', z'` as the witness this would still compute the same root but with any chosen values for y. (This would also work for x, though not for z i think)""), ('mitschabaude', 'Oh thanks for pointing that out @rpanic!'), ('rpanic', ""I still think verkle trees are the way to go, though I still haven't found a commitment scheme which works well within snarkyjs"")]"
544,Enforce limits on account updates client-side,mitschabaude,closed,,"[('bkase', 'Limits in the SnarkyJS layer for:\n\n* no of account updates\n* no of sequence events / actions\n* no of events'), ('mitschabaude', 'dupe of #276')]"
541,CircuitString behaves inconsistently,jasongitmail,open,"From @es92 
> Sometimes structures still behave oddly when declared on both a library and code using the library - CircuitStrings for instance will say they don’t type match with each other

Could you share any more detail please?
","[('es92', 'When a CircuitValue is imported from an external npm library, it seems to initialize twice, and the version within the library and the imported are not compatible with each other. I observed this with CircuitStrings and MerkleWitnesses, but assume its a general CircuitValue thing')]"
540,Improve GraphQL error handling,jasongitmail,closed,"From @es92. More details weren't given; if can provide more detail, that could be helpful during team discussion. 

> Expose GraphQL prints / errors programmatically instead of just the console","[('es92', ""Currently GraphQL requests print to the console, but they aren't available to the program as an object. I'd propose they be returned as an object, for the developer's code to inspect, and optionally print (or not as desired)""), ('mitschabaude', 'This makes sense!'), ('mitschabaude', 'this is done')]"
539,Throw warning in SnarkyJS deploy method if verification key is not set,jasongitmail,closed,From @es92 ,"[('mitschabaude', ""It's fine to not set the verification key if the contract was compiled in the same JS context, because the vk will be stored on the smart contract and taken from there.\r\n\r\nHowever, right now, deploy remains silent if the vk is neither passed in nor stored on the SC. This has been useful for testing, but should probably print a warning depending on the `proofsEnabled` toggle (no warning if proofsEnabled = false)\r\n""), ('mitschabaude', 'fixed by https://github.com/o1-labs/snarkyjs/pull/908')]"
538,Nullifier RFC,jasongitmail,closed,@bkase and @mimoo are going to research and decide what design would be most useful for us to pursue.,"[('bkase', 'We decided not to prioritize digging into this too much for now, but I figured I\'d share my rough framework for evaluating choices if it helps: Namely, we should do whatever is the most standard, simplest, easiest to build even if it\'s not ideal by other means just so we have something in place, as a non-ideal implementation is better than nothing. Afterwards we can follow up with a ""better"" version should we choose to. I think @mitschabaude has more detailed choices that he can share here too.'), ('mitschabaude', ""I think we have a choice whether we use [Semaphore nullifiers](https://worldcoin.org/the-worldcoin-protocol) (which I [implemented in Bogota](https://github.com/mitschabaude/mina-world-id), without the storage part) or [Aayush Gupta's newer nullifier scheme](https://eprint.iacr.org/2022/1255.pdf) (which is better-suited, mainly because it doesn't require the private key as smart contract input)""), ('mitschabaude', ""Requirements for a solution:\r\n- Can prove inclusion / non-inclusion of nullifiers in a sparse Merkle tree, inside smart contract\r\n- In a way which allows for concurrent user transactions\r\n- and doesn't blow up the circuit size limit\r\n\r\nSome ideas for making that happen are:\r\n- use Matt's trick to get width-3 Merkle trees for the price of binary ones (add third element to the hash of the first two)\r\n- split Merkle tree hashing between the method which dispatches the action and the reducer method\r\n- ZkProgram to do the hashing off-chain""), ('bkase', ""I don't think we should include these special tricks in the initial deliverable on this (but could consider in follow-ups)""), ('mitschabaude', ""I also wouldn't include the tricks in the deliverable, but I would include practical usability in the deliverable -- i.e. the requirements I listed. If there's a grant then the result should be useful""), ('jasongitmail', 'Closing b/c we have a new RFC for a nullifier.')]"
535,Connect to testnet in CI to guard against incompatibility,mitschabaude,closed,,[]
533,Bad error messages,mitschabaude,open,"This issue is a collection of unhelpful error messages. The idea is that anyone can dump a bad error message here, and we'll have an engineer looking at them, reproducing the error and find a better way to catch the error and communicate what has gone wrong.
","[('mitschabaude', '* Pass an array to a circuit'), ('mitschabaude', '* Try to put a private key in on-chain state'), ('mitschabaude', '* `Circuit.assertEqual(x, y)` when `x` or `y` are undefined\n  * error thrown during `compile`'), ('mitschabaude', ""One of the worst so far: When you leave out `tx.prove()` but need a proof, you'll get \n```\nAssert_failure src/lib/transaction_logic/zkapp_command_logic.ml:1170:17\n```\nwithout a hint about the error cause. This should be easy to catch, in `send()` for example""), ('mitschabaude', 'just found this list @nicc, there are some bad errors here as well')]"
532,"Move MerkleTree, Reducer and token APIs off Experimental",mitschabaude,closed,,"[('bkase', 'All of these are good to remove from experimental! But maybe we want to publish the account-update docs before the tokens API')]"
531,"APIs for real-time observing on-chain state (push, not pull)",mitschabaude,open,,"[('bkase', 'Some questions to think about for whoever spends time digging into this:\r\n\r\nWhat’s the hotness with pushing these days? Websockets? What do web3js or other tools do for evented updates on txns? \r\n\r\nWe’re pushing the onus on wallets and eventually backend indexing providers (at least until browser node). So whatever we should at least involve MinaExplorer and others in the discussion.'), ('mitschabaude', ""@bkase maybe as a start, snarkyjs could do polling and just abstract it into a nice push API for developers.\r\n\r\nas for the longer-term question, vanilla websockets work insanely well in my experience, they're easy to set up, reliable and fast""), ('Comdex', 'Hey! Is the api that receives the events of the specified zkApp in real time also in the development plan? At the same time, a graphql subscription that can receive transactions under the specified receiving address in mempool in real time is also very useful.')]"
530,Error `to_affine_exn: Got identity` when using public key retrieved from on-chain state,garethtdavies,closed,"I am using an on-chain public key variable in a zkApp for use in signature verification.

The public key is stored onchain and retrieved via ```
let oraclePublicKey = this.oraclePublicKey.get(); ```

However, when using `oraclePublicKey` it errors with:

```
/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7565
         throw err;

Error: to_affine_exn: Got identity
    at failwith (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:75528:50)
    at to_affine_exn (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:160233:36)
    at caml_call1 (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7610:28)
    at scale$3 (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:337731:34)
    at /workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:420296:49
    at caml_call_gen (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at Object.scale (/workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3651:16)
    at Signature.verify (file:///workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/lib/signature.js:126:23)
    at DelegationOracle.verify (file:///workspace/zkAppPool/oracle/build/src/DelegationOracleVerifier.js:46:42)
    at file:///workspace/zkAppPool/oracle/node_modules/snarkyjs/dist/node/lib/zkapp.js:152:32
```

If I simply override the `oraclePublicKey` with the following, it works just fine:

```
oraclePublicKey = PublicKey.fromBase58(""B62qphyUJg3TjMKi74T2rF8Yer5rQjBr1UyEG7Wg9XEYAHjaSiSqFv1"");
```

Code example here, with the above hack:   https://github.com/garethtdavies/zkAppPool/blob/5176a050c469ebab978fcf9631c7ac6bfd590970/oracle/src/DelegationOracleVerifier.ts#L44","[('mitschabaude', ""Could it be that the public key is not initialized yet, so it's all zeroes? That's what the error message sounds like""), ('garethtdavies', 'Do you mean it\'s not on-chain yet? It is stored in this account: B62qmLWZfcbqrQPMky44w6K6Myj9aydbHKE5fG2N6wrXxFbkfEUWdRM\r\n\r\nYou can see there the fields are `13117991216867267972578094433946611068215850158296483053051446309883779846074` and `0` . Manually decoding that via https://github.com/garethtdavies/zkAppPool/blob/main/oracle/src/debug-events.ts gives `B62qphyUJg3TjMKi74T2rF8Yer5rQjBr1UyEG7Wg9XEYAHjaSiSqFv1` as expected. \r\n\r\nQuery to get on-chain state:\r\n\r\n```\r\n{\r\n  account(publicKey: ""B62qmLWZfcbqrQPMky44w6K6Myj9aydbHKE5fG2N6wrXxFbkfEUWdRM"") {\r\n    publicKey\r\n    zkappState\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n'), ('mitschabaude', ""I understand the error now - it's because of running stuff multiple times, the first one with fake values. We should address this soon ""), ('mitschabaude', ""So the goal would be to run it the first time in an environment where assertions don't throw""), ('mitschabaude', '@garethtdavies you could use the following workaround for now:\r\n\r\nYou can pass in the `oraclePublicKey` as an additional parameter to your method, to avoid `.get()` which gives you the wrong result. Then, to check that it matches the on-chain one, you can do `this.oraclePublicKey.assertEquals(oraclePublicKey);` as before.\r\n\r\nSo this would be the diff in pseudo code\r\n\r\n```diff\r\n+ // oraclePublicKey gets passed in as argument\r\n- let oraclePublicKey = this.oraclePublicKey.get();\r\nthis.oraclePublicKey.assertEquals(oraclePublicKey);\r\n```\r\n\r\n'), ('mitschabaude', 'Oh! An even simpler workaround would be to warm the cache before doing the transaction:\r\n\r\n```ts\r\nawait Mina.fetchAccount(zkAppAddress);\r\n\r\nlet tx = await Mina.transaction(...)\r\n```')]"
527,Identify all terms to review for consistent variable naming / spelling ,mitschabaude,open,,"[('MartinMinkov', 'Context: Protocol originally used `zkapp`. \r\nAlso, proposed -- Change `feePayer` to `deployer`?\r\n\r\n_This will be punted down to next week._\r\n\r\nAdditionally, make a list of proposed questionable terms that SnarkyJS exposed\r\n\r\n')]"
523,ZkProgram methods return their return values rather than require them as arguments,bkase,closed,"Specifically, we'd want methods like this recursive add rollup method:

To go from:

```typescript
method(
        publicInput: Field,
        left: SelfProof<Field>,
        right: SelfProof<Field>
      ) {
        left.verify();
        right.verify();
        // assert that the left and right equal this input
        left.publicInput.add(right.publicInput).assertEquals(publicInput);
      },
```

to

```typescript
method(
        left: SelfProof<Field>,
        right: SelfProof<Field>
      ): Field  {
        left.verify();
        right.verify();

        return left.publicInput.add(right.publicInput);
      },
```

This would make the API more ""snarky""","[('bkase', 'Requires some refactoring of the SnarkyJS/OCaml glue and some other info exposed from Pickles to do properly.'), ('es92', 'What do we think about the following API?\r\n\r\n```typescript\r\nconst AddOne = ZkProgram({\r\n    publicInput: Field,\r\n\r\n    methods: {\r\n      baseCase: {\r\n        privateInputs: [],\r\n\r\n        method() {\r\n          return Field(0);\r\n        },\r\n      },\r\n\r\n      step: {\r\n        privateInputs: [ SelfProof ],\r\n\r\n        method(earlierProof: SelfProof<Field>) {\r\n          earlierProof.verify();\r\n          return earlierProof.publicInput.add(1);\r\n        },\r\n      },\r\n    },\r\n  });\r\n  ```\r\nWhich moves state to returns (and computed inside)\r\n\r\nIgnore the typescript anys, but think we could accomplish it with something like the following wrapping the existing ZkProgram:\r\n\r\n```typescript\r\nconst ZkProgram = (config : any) => {\r\n\r\n  const methods = config.methods;\r\n  const zkProgramConfig = config;\r\n  zkProgramConfig.methods = {}\r\n\r\n  Object.keys(methods).forEach((key) => {\r\n    zkProgramConfig.methods[key] = {\r\n      privateInputs: methods[key].privateInputs,\r\n      method: (...args: any[]) => {\r\n        const result = methods[key].method.apply(null, args.slice(1));\r\n        result.assertEquals(args[0])\r\n      }\r\n    }\r\n  });\r\n\r\n  const originalZkProgram = Experimental.ZkProgram(zkProgramConfig);\r\n\r\n  const zkProgram: any = {};\r\n\r\n  Object.keys(methods).forEach((key) => {\r\n    zkProgram[key] = {\r\n      method: (...args: any[]) => {\r\n        const result = methods.apply(null, args);\r\n        args.unshift(result);\r\n        return (originalZkProgram[key] as any).apply(null, args);\r\n      }\r\n    }\r\n  });\r\n\r\n  return zkProgram;\r\n}\r\n```'), ('mitschabaude', 'Yes, that would do it! I\'d prefer using the ""public output"" thing that\'s already built into Pickles, not sure if that also involves re-running the logic first.'), ('bkase', 'This is good hack in the meantime though! Given that pickles changes are complex '), ('nicc', 'IRI: @mitschabaude / @Trivo25 ')]"
521,Make snarkyjs a monorepo by putting mina-signer inside it,mitschabaude,closed,,"[('bkase', ""Developer experience is much more sane in one repo, so we're pushing for it. Pending @jasongitmail giving feedback.""), ('mitschabaude', 'we aligned to move forward with this, initial work is covered by https://github.com/MinaProtocol/mina/issues/11855')]"
517,"Generate EC/FF constants from Rust, for JS backend",mitschabaude,open,"https://github.com/MinaProtocol/mina/pull/10654/files#r1000895582

this should be done when the broader architecture of ""pure JS mina-signer"" is clearer",[]
515,Callback arguments list is always undefined,MartinMinkov,closed,"# Description
When creating a callback, one can specify a list of argument values to be used in the callback method. These arguments are forwarded to the zkApps method to be called with later.

Currently, there is a bug in which these argument values are always undefined and causes a crash when we try to run the zkApp method.

# Reproduce:
```ts
class ZkAppB extends SmartContract {
  @method authorizeSend(amount: UInt64) {
    this.balance.subInPlace(amount);
  }
}
...
// This causes a crash since `amount` will be `undefined`.
let authorizeSendingCallback = Experimental.Callback.create(
    zkAppB,
    'authorizeSend',
    [UInt64.from(1000)]
  );
```",[]
513,Token Tests Requirements,MartinMinkov,closed,"Gathering all requirements in a single issue for easier tracking.

According to an internal testing document, we would like the following aspects of tokens to be tested:
- [x] Token Contract Creation/Deployment.
    - [x] - Check that the proper token owner exists
    - [x] - Check that an account creation fee is taken when applied to the ledger
    - [x] - Check that the token owner contract exists in the ledger
    - [x] - Check that submitting a successful token symbol is successful and applied to the ledger
    - [x] - Check that submitting an unsuccessful token symbol fails
    - [x] Authorization
        - [x] - Check that a child token account can be deployed under a token owner with proper authorization

- [x] Minting
    - [x] - Check that a token owner can mint (signature and proof) and balances are applied to the ledger
    - [x] - Check that minting in an overflow will fail
    - [x] - Check that minting a negative amount of tokens fails

- [x] Burning
    - [x] - Check that a token owner can burn (signature and proof) and balances are applied to the ledger
    - [x] - Check that burning in an overflow will fail
    - [x] - Check that burning a negative amount of tokens fails

- [x] Transfer
    - [x] - Check that a token owner can transfer it's own tokens to a token account that doesn't exist
    - [x] - Check that a token owner can transfer it's own tokens to a token account that does exist
    - [x] - Check that sending a number of tokens greater than the balance fails
    - [x] - Check that sending a negative amount of tokens fails
    - [x] Authorization
        - [x] - Check that a child token account can get authorization from a token owner account to transfer tokens
        - [x] - Check that a child token account cannot transfer without proper authorization from the token owner
        - [x] - Check that a token owner can inspect different types of layouts for authorization of child token accounts

Related issue: https://github.com/o1-labs/snarkyjs/issues/404",[]
512,Enable non-new on UInt constructors,bkase,open,,[]
511,Remove static members that are replaceable by constructor invocations,bkase,closed,"This means we should remove Field.zero and Field.one and Bool.true and Bool.false

","[('mitschabaude', ""There's also `Field.minusOne`, and `UInt.{one,zero}`, and `Int.{one,zero,minusOne}`""), ('bkase', ""I don't see UInt or Int constants in here and it looks like the bool ones were already removed""), ('mitschabaude', 'here!\r\n\r\nhttps://github.com/o1-labs/snarkyjs/blob/928bc47ec2e568bc159ab0d468cb282747d9a788/src/lib/int.ts#L13-L19\r\n\r\nhttps://github.com/o1-labs/snarkyjs/blob/928bc47ec2e568bc159ab0d468cb282747d9a788/src/lib/int.ts#L205-L211\r\n\r\nhttps://github.com/o1-labs/snarkyjs/blob/928bc47ec2e568bc159ab0d468cb282747d9a788/src/lib/int.ts#L13-L19\r\n\r\nhttps://github.com/o1-labs/snarkyjs/blob/928bc47ec2e568bc159ab0d468cb282747d9a788/src/lib/int.ts#L494-L502'), ('mitschabaude', '@bkase actually we should probably wait for the simplified `UInt32(number)` constructors before removing these constants'), ('bkase', ""ah okay, they're just not used by us yet I guess""), ('mitschabaude', 'We use them quite a bit!'), ('mitschabaude', '![image](https://user-images.githubusercontent.com/20989968/199316998-cd9de96f-7a55-4396-a8ec-519ac5bbf550.png)\r\n')]"
510,Deprecate Circuit class in favor of fast-path ZkProgram,bkase,open,"We currently have 3 different interfaces for building zk proofs:
1. SmartContract
2. ZkProgram
3. Circuit

We ideally should have 1, but at least let's take one step closer towards 1 by moving to 2

ZkProgram is built on top of pickles so there's a slowness there, so to do this properly we should fast-path ZkProgram in the case where you don't need recursion to keep the performance","[('bkase', ""There's an additional thing that is not the same:\n\nCircuit just has one entrypoint and ZkProgram has multiple entrypoints."")]"
509,Follow up JS crypto review,mitschabaude,closed,,[]
508,Dex: Application C - Upgradability Invalid Upgrades,Trivo25,closed,,[]
507,Dex: Application C - Upgradability Happy Path,Trivo25,closed,,[]
506,Dex: Application C - Atomic Actions Change ordering of transactions,Trivo25,closed,,"[('mitschabaude', 'done')]"
505,Dex: Application C - Atomic Actions Happy Path,Trivo25,closed,,[]
504,Dex: Application C - Upgradability test cases,Trivo25,closed,,[]
499,Unknown constraint failure; commented out line in Dex,bkase,closed,,[]
498,Proving bug in Dex,bkase,closed,"This happens when creating a proof for `Dex.redeemLiquidity()`

In the Pickles wrap prover, the `compute_witness` step (in `Plonk_constraint_system`) fails when it tries to access `external_vars` at out-of-bounds indices.

The fact that this is the wrap prover makes the issue more mysterious because we wouldn't expect the wrap circuit to be influenced by a badly written snarkyjs circuit (which, for example, created less witnesses than expected or similar)","[('Trivo25', 'Quick update: The bug seems to be caused by the method `TokenContract.approveUpdateAndSend(zkappUpdate: AccountUpdate, to: PublicKey, amount: UInt64)`, more specifically, the `AccountUpdate` as argument.'), ('Trivo25', 'The bug only appears when we try to prove an `AccountUpdate` (pass it as an argument to another zkApp method) where the authorization is either `None_given` or `Proof`, whereas signing the `AccountUpdate` (authorization: signature) works. \r\n\r\nThe bug appears when trying to prove the transaction (add the missing proofs to all `AccountUpdate`s via the `provers` array https://github.com/MinaProtocol/mina/blob/develop/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L2215) \r\n\r\n```\r\npanicked at \'called `Result::unwrap()` on an `Err` value: Error { kind: UnexpectedEof, message: ""failed to fill whole buffer"" }\', src/arkworks/pasta_fp.rs:59:21 \r\n```\r\n\r\nthis error can be traced back to `compute_witness` and https://github.com/MinaProtocol/mina/blob/develop/src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml#L464\r\n\r\nwhere it seems like `x` is not being computed correctly(?) https://github.com/MinaProtocol/mina/blob/develop/src/lib/crypto/kimchi_backend/common/plonk_constraint_system.ml#L444\r\n')]"
495,API to set the value of an existing variable,mitschabaude,open,"I often am in the situation where I want to add constraints to a variable, which stay associated with the variable even if I change the value of it later. That's impossible now, because right now, ""changing the value of a variable"" -- for example, of one of the fields in an account update -- means assigning it to a different variable","[('mimoo', ""can you give an example of this? I'm not sure I understand : o""), ('mitschabaude', ""@mimoo \r\nOk, so preliminary situation is this: snarkyjs smart contract circuits are not written from top to bottom, in one function. Instead, they are a complex combination of stuff the user writes, stuff that gets added implicitly because of something the user writes, and stuff that gets added on top of all that inside a function which is wrapping the user code. It's spread out over many files and functions, and it's a complex machinery; I think the way the library is designed right now, it has to be that way.\r\n\r\nInside this complex circuit, there are a bunch of variables which are created at the beginning. They describe the Mina transaction that the smart contract creates & authorizes. It has stuff in it like the balance change for this user. For the sake of simplicity, let's just say I have a single `globalVariable`, which represents a variable in the circuit. This `globalVariable` is created at the beginning, with some default witness value assigned to it.\r\n\r\nNow I'm in the following situation: In some places in my library, I want to change the witness value of `globalVariable`. In other places, I want to add constraints to `globalVariable`, i.e. do something like `globalVariable.assertEquals(somethingElse)`. I want to do these things inside functions the user calls, in some non-determined order; so, I don't know exactly which of these things is done at what point in the circuit.\r\n\r\nHowever, there is currently no API (in snarkyjs at least) which allows me to _change_ the witness value, without also _swapping out the variable itself_. Currently, I'm doing something like this when I want to change the witness value:\r\n```ts\r\nthis.globalVariable = Circuit.witness(() => myNewWitnessValue);\r\n```\r\nThe problem is that here, I'm replacing `globalVariable` with a new, completely unconstrained variable. I'm destroying any constraints I might have added before with something like `globalVariable.assertEquals(somethingElse)`.\r\n\r\n**What I want is an API like this:**\r\n```ts\r\nthis.globalVariable.setValue(() => myNewWitnessValue);\r\n```\r\n\r\nThis would swap out the witness value that is currently assigned to this globalVariable, but without destroying all the constraints that are already on it""), ('mrmr1993', ""It sounds like you might be better delaying the constraints (ie. accumulating the constraints you want to add), then allocating/instantiating the variable when you're ready, and iterating over the delayed constraints to add them.\r\n\r\nI tried a version of this 'delayed variables' in OCaml previously, but it made writing circuits far more error prone, because reading any variable in an `as_prover` block could potentially fail or give a garbage value if you weren't careful. We decided to scrap the idea.""), ('mitschabaude', 'Interesting, thx for the feedback @mrmr1993!\r\n\r\n> reading any variable in an as_prover block could potentially fail or give a garbage value if you weren\'t careful\r\n\r\nI _would_ have a default witness value for the variable though. In that sense, I\'m not sure the asProver result would be ""garbage""; it would just reflect the value before some other action was done which changed the value. Or maybe I\'m missing some context about when asProver blocks are executed? If they\'re executed linearly as part of the circuit code, then it seems fine to me, on first glance.'), ('mitschabaude', 'Btw, I do already have some patterns of ""delaying constraints"", but they all seem kind of ad-hoc and custom to me, where I define some custom enum to tell some other custom part of the code what constraints to add etc; a uniform API like setValue would solve the problem neatly'), ('mrmr1993', ""> If they're executed linearly as part of the circuit code, then it seems fine to me, on first glance.\r\n\r\nIt's a pretty dangerous path to go down: all existing functions expect that the values are static, so if you do `let z = x.mul(y); x.setValue(() => blah)` then your witness will never be valid.\r\n\r\nI started on an experiment with a separate 'delayed variable' kind, where it doesn't become a true variable until it gets filled, but I never finished it. If you're happy to have this kind of separation, we can probably make that work, although it'll take quite a lot of refactoring in the backend.\r\n\r\nPresumably you could do the same entirely in SnarkyJS -- adding a variant of the field type with a 'delay' promise, and only adding the constraints after the promises for all variables in a constraint resolve -- since I imagine this is just for range checks on the preconditions?""), ('mitschabaude', ""> It's a pretty dangerous path to go down: all existing functions expect that the values are static, so if you do let z = x.mul(y); x.setValue(() => blah) then your witness will never be valid.\r\n\r\nOk I see what you mean. It's not how snarky is designed right now -- `z`  won't get a different value if we change the `x` value after the fact. It won't work then I guess :)\r\n\r\n> Presumably you could do the same entirely in SnarkyJS -- adding a variant of the field type with a 'delay' promise, and only adding the constraints after the promises for all variables in a constraint resolve -- since I imagine this is just for range checks on the preconditions?\r\n\r\nThis in interesting, I might explore that. I don't need it for range checks currently, What I most need it for right now is for the caller field, which is computed from an `isDelegateCall` Bool in the circuit, the value of which is changed in different places depending on if the zkApp has children / uses token APIs, and the value of which is constrained if a zkApp wants to assert that its child doesn't delegate authority"")]"
494,Improve developer experience around init(),jasongitmail,closed,"1. Move `init()` into `deploy()`
2. Check if verification key exists and if not, run `init()`. Or allow `init()` to be run so long as no users have interacted with it previously, so a dev can init the on-chain state slightly differently if they decide, when first developing their smart contract.","[('MartinMinkov', 'Proposed solution: The developer should be able to call init but no one else, and it creates proof.\r\n\r\nNeed a following writeup for pros/cons\r\n'), ('jasongitmail', '* @mitschabaude is drafting a proposed design this week')]"
492,Discuss error handling for failed assertions & other exceptions during contract execution,jasongitmail,closed,"We need to document a recommended best practices to capture specific assertion failures so that a dev can expose helpful feedback to their end users in their UI.
","[('MartinMinkov', '[This](https://github.com/o1-labs/snarkyjs/issues/286) will be helpful for devs that want a way to expose custom error messages with assertion methods! \r\n\r\nI have a few PRs in flight that will allow this.\r\nhttps://github.com/o1-labs/snarkyjs/pull/470\r\nhttps://github.com/MinaProtocol/mina/pull/11964'), ('mitschabaude', 'We discussed this and came up with a recommendation that was put on the docs: https://docs.minaprotocol.com/zkapps/how-to-write-a-zkapp-ui#displaying-assertion-exceptions-in-your-ui')]"
491,Run using only one thread on M1 processors,jasongitmail,closed,To fix the CPU issue that @jackryanservia identified.,"[('Trivo25', 'do we have any logs for that? @jackryanservia '), ('mitschabaude', '@Trivo25 slack thread is here: https://o1-labs.slack.com/archives/C028Q27R8UC/p1664245499393539')]"
490,"Refactor web workers to be spawned from the main thread, for Safari support",mitschabaude,closed,"Safari has a bug where web workers can't be spawned from other web workers. This is what we currently do in snarkyjs though, which makes snarkyjs not work in Safari.

https://stackoverflow.com/questions/64045547/javascript-referenceerror-cant-find-variable-worker-in-safari-when-creating/65099653#65099653

TODO: refactor the code in `src/chrome_bindings` (entry point: `plonk_init.js`) to start all workers directly from the main thread.

Right now, the main thread spawns one ""main worker"", which spawns the other workers. This extra level was introduced so that we can use `Atomics.wait`, which is used in compiled Rust code for concurrency, and which is not allowed on the main thread in browsers. As an alternative solution, I propose to keep the architecture as is, but have the ""main worker"" tell the main thread to spawn sub-workers.","[('mitschabaude', 'Turns out this is already fixed in Safari Technology Preview. https://github.com/WebKit/WebKit/commit/48880e342359f100878b1b87373e706db7dfe540\r\n\r\nIt seems to me that we should probably just wait for that fix to land in mainstream Safari, instead of refactoring our Worker code. '), ('shimkiv', 'macOS Ventura 13.0.1 (22A400), Safari Version 16.1 (18614.2.9.1.12)\r\n- Still same issue as [before](https://github.com/o1-labs/snarkyjs/pull/419#issuecomment-1250215126), will periodically check for updates.')]"
489,Make debugging / logging variables in a circuit less error-prone,mitschabaude,closed,"feedback by @gretzke 

```
- vielleicht sollte man toString/toJSON ganz entfernen (oder zumindest dem Entwickler nicht zugängig machen) damit man gar nicht in Versuchung kommt etwas zu loggen
- Eine dedicated log funktion anbieten (e.g., snarky.log()) die 
Circuit.asProver(() => {
  console.log(field.toString())
});
```

Paraphrasing:
* remove functions like `field.toString()` / `.toJSON()` because they aren't allowed inside circuits
* instead, expose a simple `debug` / `log` function which abstracts this away
  - example: `field.debug(x => console.log(x))`, where `x` is a string
  - or maybe: `debug(log => { log(field); log(bool) })` which logs variables in a nice format","[('gretzke', 'I think such a wrapper would also work well: \r\n```js\r\nfunction log(...args: any[]) {\r\n  Circuit.asProver(() => {\r\n    console.log(...args.map((x) => x.toString()));\r\n  });\r\n}\r\n```\r\ncalling it like this:\r\n```js\r\nsnarky.log(\'field\', Field.zero, \'bool\', Bool(true), \'uint\', new UInt64(2));\r\n```\r\nshould result in\r\n```\r\n> field 0 bool true uint 2\r\n```\r\nIt would allow developers to log values intuitively with the same syntax they are used from `console.log` without breaking the compilation. `toString()` methods should be protected so that the functions cannot be called by the dev directly, because the first intuition of every dev would be logging like this `console.log(myField.toString());`\r\n\r\nAnother option would be exposing a dedicated log function on the `Field`, and `CircuitValue` classes that also take an optional string for logging, e.g.,:\r\n\r\n```js\r\nconst myField = Field(5);\r\nmyField.log(""the value of my field is:"");\r\n> the value of my field is: 5\r\n```'), ('mitschabaude', 'I like the simplicity of your `snarky.log`, and similarity with `console.log` :D\r\n\r\nI wonder whether the innermost function should not be `x => x.toString()`, but `x => JSON.stringify(x)` or `x => JSON.parse(JSON.stringify(x))`, because that will work on all circuit values, and print something nice for plain JS arrays / objects / primitive types as well'), ('gretzke', 'The json representation makes sense, I know people also like logging values like this:\n```js\nconsole.log({a,b})\n> { a: 1, b: 2 }\n```\nI feel like this would work great with the json parsing '), ('mitschabaude', ""I'm adding `Circuit.log` now. Leaving this open for discussion on whether to remove toString etc""), ('bkase', '`unsafeToStringOutsideCircuit()`'), ('bkase', 'Todo: Propose something with reasoning'), ('gretzke', 'Is there any other reason to convert a provable value to a string except for logging?'), ('mitschabaude', ""@gretzke yes, serializing for IO, & in general process it as a normal JS value outside the circuit. It's used all the time, it's just not supposed to be used in circuits""), ('mitschabaude', '@bkase I propose to not change this for now, but instead change the error message to something that explains the matter very well, and to revisit this when we work on separating constants and variables.\r\n\r\nThe reasoning is that the constant-variable separation could mean we can keep a nice API, so it feels premature to introduce that ugly / dangerous-sounding API in the meantime ')]"
488,"Create check command(s) which run method in same environment as compile/prove, but no proofs",mitschabaude,open,"this is feedback by @gretzke 

- no proofs to speed up development
- make environment as realistic as possible. compared to `runAndCheck` now, this could mean
  - creating & passing variables to methods, not constants, bc variable creation is a frequent source of errors
  - checking that the same constraint system is created in the prover as in during compile
  - checking account update consistency (`checkPublicInput`) between tx construction & prover logic

Would be nice to expose this as a simple `zk check` command, although the question there is how to declare method inputs that make sense

Related QoL improvement would  be a one-command way to run a prover, to avoid the local deployment + transaction boilerplate for testing. The local deployment should just be done once and stored in a cache so we now it's not necessary anymore the second time",[]
487,Make Field.assertLt & friends work outside the circuit,mitschabaude,closed,"Currently, calling those functions at the top level throws:

![image.png](https://images.zenhubusercontent.com/6221c39815ade7e04617f387/453f5e7f-74a0-4132-9e8f-978fc333d9cc)","[('mitschabaude', 'Fixed!')]"
486,Remove `Field.fromNumber(x)` to reduce API surface area,jasongitmail,closed,Given `Field(x)` works equally well.,"[('mitschabaude', ""we have three similar methods, which all duplicate part of the `Field()` constructor\r\n\r\n```ts\r\n  static fromString(x: string): Field;\r\n  static fromNumber(x: number): Field;\r\n  static fromBigInt(x: bigint): Field;\r\n  ```\r\n  \r\nthe only things they add is to narrow down the types that are allowed as input. I'm not sure if that adds any value though, and haven't seen any of those three used in any actual code""), ('bkase', 'Remove them on UInt* as well'), ('bkase', ""Search the docs to make sure that these aren't referenced anywhere and fix them"")]"
485,Set `provedState` precondition by default,mitschabaude,open,"This needs two things:
* ~~work on the ocaml side to make `isProved` available via grapjql~~ done
* tweak the default account update created by a zkApp so it has the isProved precondition set from the start. Note: this only applies for the account update which is created by a zkApp for itself. Maybe it's enough to modify `selfAccountUpdate()`","[('es92', 'Would propose this should be on any function besides an ""init"" one - that way devs avoid accidentally ""blessing"" a false state - eg a ""powersOfTwo"" contract with an `init` function that sets the state to `1`, but with a `double` method that doesn\'t check `isProved`, and so could take a non `isProved` state `3` to an `isProved` state `6`')]"
482,StackOverflow error caused by cloning `lazyAuthorization`,MartinMinkov,closed,"# Description
When calling `this.experimental.authorize(accountUpdate)` inside a smart contract method, a stack overflow error occurs. This happens because inside `toAuxiliary`, the function will call `cloneCircuitValue` on `a.lazyAuthorization` and recursively call `cloneCircuitValue` until it blows up the stack.

See this line here: https://github.com/o1-labs/snarkyjs/blob/ecffd00ecb39f6aa24f2ead47e51eda570ab8071/src/lib/account_update.ts#L1095

This was confirmed by commenting out the `cloneCircuitValue` call and ensuring that no stack overflow error occurs.","[('MartinMinkov', 'Additionally happens here: https://github.com/o1-labs/snarkyjs/blob/ecffd00ecb39f6aa24f2ead47e51eda570ab8071/src/lib/account_update.ts#L681'), ('mitschabaude', ""I think the solution might just be to not clone the lazyAuthorization. I can't think of a reason we'd have to clone it.\n\nI didn't investigate the error, but my guess would be that it's something like this: a lazy proof contains everything needed to recreate that proof, including the method arguments. these method arguments can now be account updates themselves. these account updates again contain lazy proofs _and_ children, which both can contain further account updates. Maybe there's some infinite loop of references to account updates occurring there, at least it sounds possible"")]"
480,Resolver error while running `npm test`,omrikiei,closed,"Getting the following error while running `npm test` on a snarkyjs project
```
FAIL src/SSO.test.ts
  ● Test suite failed to run

    Cannot find module 'string:./snarky_js_chrome.bc.js' from 'node_modules/snarkyjs/dist/web/chrome_bindings/plonk_init.js'

      at Resolver.resolveModule (node_modules/jest-resolve/build/resolver.js:[32](https://github.com/omrikiei/zksso/actions/runs/3229143107/jobs/5286096466#step:4:33)4:11)
          at async Promise.all (index 0)
          at async Promise.all (index 0)
          at async Promise.all (index 0)
          at async Promise.all (index 2)
          at async Promise.all (index 1)
          at async Promise.all (index 0)
      at TestScheduler.scheduleTests (node_modules/@jest/core/build/TestScheduler.js:[33](https://github.com/omrikiei/zksso/actions/runs/3229143107/jobs/5286096466#step:4:34)3:13)
      at runJest (node_modules/@jest/core/build/runJest.js:[40](https://github.com/omrikiei/zksso/actions/runs/3229143107/jobs/5286096466#step:4:41)4:19)
      at _run10000 (node_modules/@jest/core/build/cli/index.js:320:7)
      at runCLI (node_modules/@jest/core/build/cli/index.js:173:3)
```

Full code reference can be found [here](https://github.com/omrikiei/zksso)","[('omrikiei', 'Additional info by self troubleshooting - I printed the request and basedir for each import of something from snarkyjs that goes through the resolver - seems that this is related to the binding and usage of merkle_tree - where it is being referenced in web instead of in node by plonk_wasm.cjs:\r\n![image](https://user-images.githubusercontent.com/6465556/195442407-3bf9366d-816c-48de-b842-0b2939a41d70.png)\r\n'), ('omrikiei', 'OK found that the root cause are explicit imports in code and tests to web/lib instead of snarkyJS, feel free to close issue'), ('mitschabaude', 'Thanks for debugging this, this could be very helpful troubleshooting info for others!')]"
478,Better error handling of values pulled out from variables within the circuits,shimkiv,closed,"Having circuits (SC methods with `@method` decorators) with inappropriate usage of values pulled out from variables like:
- `Field.toString()`:

  ```typescript
  @method updateZkAppUri(uri: Field) {
    AccountUpdate.setValue(this.self.update.zkappUri, {
      data: uri.toString(),
      hash: Poseidon.hash([Field(this._zkAppUri)]),
    });
  }
  ```

- Or an undefined variables:

  ```typescript
  @method updateZkAppUri() {
    AccountUpdate.setValue(this.self.update.zkappUri, {
      data: thisIsAnUndefinedVar,
      hash: Poseidon.hash([Field(this._zkAppUri)]),
    });
  }
  ```

Results in error like the following:

```
[
  0,
  [ 248, MlBytes { t: 0, c: 'Jsoo_runtime.Error.Exn', l: 22 }, 233 ],
  Error: Can't evaluate prover code outside an as_prover block
      at failwith (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:75548:50)
      at eval_as_prover (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:143681:36)
      at read_var (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:143684:36)
      at caml_call1 (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7610:28)
      at to_string$54 (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419472:36)
      at src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419519:52
      at caml_call_gen (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
      at Object.toString (src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3651:16)
      at E2eZkApp.updateZkAppUri (file:///src/E2eZkApp.js:37:23)
      at file:///src/lib/snarky_js_bindings/snarkyjs/src/lib/zkapp.ts:197:32
]
```

In which case actual cause with message is hidden within the output array.","[('mitschabaude', 'same as #489')]"
474,Failure to verify proofs in the browser,mitschabaude,closed,"![image.png](https://images.zenhubusercontent.com/6221c39815ade7e04617f387/5e0b807e-e604-412e-a3b5-33d0df694f96)

it seems the wasm js bindings need to be updated, and this should be added as a test to the browser e2e test","[('shimkiv', '@mitschabaude \r\nAre you talking about the following to be added into the tests?\r\n\r\n```typescript\r\n    const {verificationKey} = await E2eZkApp.compile()\r\n    const proof = await transaction.prove()\r\n    verify(proof[0]!, verificationKey.data)\r\n```\r\n\r\n')]"
473,Custom Circuit Value type issue with _fields / matrix prop initialization,45930,closed,"## Description of Issue

I have a CircuitValue with a matrixProp.  When I try to use that circuit value in a smart contract I get this error:

```
TypeError: Cannot read properties of undefined (reading 'reduce')
```

The relevant sections of snarkyjs code are:
```
// zkapp.ts

function computeCallData(
  methodIntf: MethodInterface,
  argumentValues: any[],
  returnValue: any,
  blindingValue: Field
) {
  let { returnType, methodName } = methodIntf;
  let args = methodArgumentTypesAndValues(methodIntf, argumentValues);
  let argSizesAndFields: Field[][] = args.map(({ type, value }) => [
----->    Field(type.sizeInFields()),
    ...type.toFields(value),
  ]);
  ```

```
// circuit_value.ts

  static sizeInFields(): number {
----->    const fields: [string, any][] = (this as any).prototype._fields; // this evaluates to undefined
    return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
  }
  ```

As for my class, it looks like this:

```
class Cell extends CircuitValue {
  owner: PublicKey;
  value: Bool;

  constructor(owner: PublicKey, value: Bool) {
    super();
    this.value = value;
    this.owner = owner;
  }
}

export class CanvasData extends CircuitValue {
  @matrixProp(Cell, 32, 32)
  value: Cell[][];

  constructor(value: Cell[][]) {
    super();
    this.value = value;
  }
}
```

I've also tried the alternative way of initializing the matrix prop:

```
class Cell extends CircuitValue {
  owner: PublicKey;
  value: Bool;

  constructor(owner: PublicKey, value: Bool) {
    super();
    this.value = value;
    this.owner = owner;
  }
}

export class CanvasData extends CircuitValue {
  value: Cell[][];

  constructor(value: Cell[][]) {
    super();
    this.value = value;
  }
}

matrixProp(Cell, 32, 32)(CanvasData, 'value')
```

## Expected Behavior
`@matrixProp` should push the cell values to `CanvasData._fields`, which should not be undefined.

## Observed Behavior


## Repro Steps
- Clone my repo `git clone git@github.com:qcomps/canvas-zk-app.git`
- Checkout this branch: `git checkout 6324a409044a2bc17a2ed80dab57c4c4e812bdd2`
- Run test: `npm i && npm test`

This should produce the output:

```
TypeError: Cannot read properties of undefined (reading 'reduce')
```

","[('mitschabaude', ""Looks like your 'Cell' is missing @ prop decorators?""), ('mitschabaude', 'Error messages for these kinds of things are really not good yet. The new Struct is less error prone though'), ('45930', ""> Looks like your 'Cell' is missing @ prop decorators?\r\n\r\nLol fixed.."")]"
471,Failed NPM install in `zk project` still gives a success message,mrmr1993,closed,"```
$ zk project test_snarkyjs_project
✔ Fetch project template
✔ Initialize Git repo
✖ NPM install
✔ Set project name
✔ Git init commit

Success!

Next steps:
  cd test_snarkyjs_project
  git remote add origin <your-repo-url>
  git push -u origin main
```","[('mitschabaude', 'moved to zkapp-cli repo')]"
469,`Field.assertBoolean` does not throw with invalid input,MartinMinkov,closed,"# Description
The comments of `Field.assertBoolean` are as follows:

`Assert that this [[`Field`]] is either 0 or 1`

However, it seems as though calling `assertBoolean` on Field elements that are not 0 or 1 does not cause an assertion failure.

# Reproduce
## Code
```ts
import { Field, isReady, shutdown } from 'snarkyjs';
await isReady;
Circuit.runAndCheck(() => {
  Field(512).assertBoolean(); // Nothing is thrown.
});
shutdown();
```",[]
465,Add a check to `TokenSymbol` to match the same assertion as OCaml,MartinMinkov,closed,"# Description
In OCaml, we have an assertion to [check the length of a token symbol](https://github.com/MinaProtocol/mina/blob/04b85f369ee4013ca6278d41842381cafbeb26c1/src/lib/mina_base/account.ml#L99) to be a max length of `6`. We should additionally do this check-in SnarkyJS as well, to save the user time before sending it off to the network.

Presumably, SnarkyJS is already doing this check but the length seems to be off. If we pass in a very long token symbol, we get the following stack trace:

```
Error: prefix too long
    at prefixToField (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/hash.js:56:15)
    at Object.from (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/hash.js:141:21)
    at Object.set (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/account_update.js:379:86)
    at TokenContract.init (file:///workspace/deploy2berkeley/build/src/token-minaexplorer-repro.js:27:26)
    at file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/zkapp.js:89:113
    at runWith (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/global-context.js:55:18)
    at Function.runWith (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/global-context.js:14:37)
    at file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/zkapp.js:89:61
    at runWith (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/global-context.js:55:18)
    at Function.runWith (file:///workspace/deploy2berkeley/node_modules/snarkyjs/dist/node/lib/global-context.js:14:37)
```

We should just do the initial check of length `6` when setting the token symbol.","[('garethtdavies', ""Error is thrown here https://github.com/o1-labs/snarkyjs/blob/bcf3e8c2f8e90abfbf38a4848d1bf41cf173691f/src/lib/hash.ts#L84\r\n\r\nMaybe something as simple as:\r\n\r\n```ts\r\nfrom(symbol: string): TokenSymbol {\r\n    if (symbol.length > 6) throw Error('token symbol too long');\r\n    let field = prefixToField(symbol);\r\n    return { symbol, field };\r\n  }\r\n```""), ('mitschabaude', ""The existing error is unrelated, it's if the string is too long to fit in one field element.\r\nYeah a simple error message like that would do it, preferably it should also mention the limit of 6"")]"
463,`AccountUpdate.createSigned` throws an error in a transaction block,MartinMinkov,closed,"# Description
In the current `main` branch of SnarkyJS, a possible regression was reintroduced. When using `AccountUpdate.createSigned` inside a transaction block, an error is thrown.

# Reproduce
```ts
import { isReady, Mina, AccountUpdate, shutdown } from 'snarkyjs';

await isReady;

let Local = Mina.LocalBlockchain();
Mina.setActiveInstance(Local);

let [{ privateKey: feePayerKey }] = Local.testAccounts;
let tx;

tx = await Mina.transaction({ feePayerKey }, () => {
  let feePayerUpdate = AccountUpdate.createSigned(feePayerKey);
});

shutdown();
```

## Stack Trace
```sh
/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7565
         throw err;
         ^

Error: Type ""undefined"" cannot be converted to a field element
    at raise_error (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419858:44)
    at value$6 (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419924:43)
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at /home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3643:18
    at new eval (eval at caml_js_eval_string (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3630:44), <anonymous>:4:26)
    at to_field_obj (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419940:35)
    at /home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:420232:44
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at Function.<anonymous> (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3643:18)
    at Function.Class.<computed> [as toFields] (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/snarky/proxy.js:21:62)
```","[('MartinMinkov', 'Error seems to be happening here:\r\nhttps://github.com/MinaProtocol/mina/blob/714b03153e321d43b9c568c93a71268d2cd94754/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L1458'), ('MartinMinkov', 'This is actually fixed in the latest commit on `main`'), ('mitschabaude', 'nice :D')]"
460,"When the Action contains a Group value, the reducer execution will fail",Comdex,open,"When an Action type contains data of the Group type, the reducer will throw the following error when executed.(Mode for generating proof)

![debug2](https://user-images.githubusercontent.com/3725514/192994241-e578e21b-dfa3-4509-bcc9-885ad4575d81.PNG)

Can't we use Group in an Action type？

snarkyjs version: 0.6.0
sample code to reproduce the problem:

```typescript
const doProofs = true;
const initialCounter = Field.zero;

const TEST_TYPE1 = Field(1);
const TEST_TYPE2 = Field(2);
class Action extends CircuitValue {
  @prop type: Field;
  @prop data: Group;

  constructor(type: Field, data: Group) {
    super();
    this.type = type;
    this.data = data;
  }

  isType1(): Bool {
    return this.type.equals(TEST_TYPE1);
  }

  isType2(): Bool {
    return this.type.equals(TEST_TYPE2);
  }

  isDummyData(): Bool {
    return this.type.equals(Field.zero);
  }

  static type1(data: Group): Action {
    return new Action(TEST_TYPE1, data);
  }

  static type2(data: Group) {
    return new Action(TEST_TYPE2, data);
  }
}

class TestZkapp extends SmartContract {
  reducer = Experimental.Reducer({ actionType: Action });

  @state(Field) counter = State<Field>();
  @state(Field) actionsHash = State<Field>();

  @method testAction1(data: Group) {
    this.reducer.dispatch(Action.type1(data));
  }
  @method testAction2(data: Group) {
    this.reducer.dispatch(Action.type2(data));
  }

  @method rollup() {
    let counter = this.counter.get();
    this.counter.assertEquals(counter);
    let actionsHash = this.actionsHash.get();
    this.actionsHash.assertEquals(actionsHash);

    let pendingActions = this.reducer.getActions({
      fromActionHash: actionsHash,
    });

    let { state: newCounter, actionsHash: newActionsHash } =
      this.reducer.reduce(
        pendingActions,
        Field,
        (state: Field, action: Action) => {
          let newState = Circuit.if(action.isType1(), state.add(1), state);
          return newState;
        },
        { state: counter, actionsHash }
      );

    this.counter.set(newCounter);
    this.actionsHash.set(newActionsHash);
  }
}

let Local = Mina.LocalBlockchain();
Mina.setActiveInstance(Local);

let feePayer = Local.testAccounts[0].privateKey;

let zkappKey = PrivateKey.random();
let zkappAddress = zkappKey.toPublicKey();
let zkapp = new TestZkapp(zkappAddress);
if (doProofs) {
  console.log('compile');
  await TestZkapp.compile();
}

console.log('deploy');
let tx = await Mina.transaction(feePayer, () => {
  AccountUpdate.fundNewAccount(feePayer);
  zkapp.deploy({ zkappKey });
  if (!doProofs) {
    zkapp.setPermissions({
      ...Permissions.default(),
      editState: Permissions.proofOrSignature(),
      editSequenceState: Permissions.proofOrSignature(),
    });
  }
  zkapp.counter.set(initialCounter);
  zkapp.actionsHash.set(Experimental.Reducer.initialActionsHash);
});
tx.send();

console.log('applying actions..');

console.log('action 1');

tx = await Mina.transaction(feePayer, () => {
  zkapp.testAction1(PrivateKey.random().toPublicKey().toGroup());
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('action 2');
tx = await Mina.transaction(feePayer, () => {
  zkapp.testAction1(PrivateKey.random().toPublicKey().toGroup());
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('action 3');
tx = await Mina.transaction(feePayer, () => {
  zkapp.testAction1(PrivateKey.random().toPublicKey().toGroup());
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('rolling up pending actions..');

console.log('state before: ' + zkapp.counter.get());

tx = await Mina.transaction(feePayer, () => {
  zkapp.rollup();
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('state after rollup: ' + zkapp.counter.get());

console.log('applying more actions');

console.log('action 4');
tx = await Mina.transaction(feePayer, () => {
  zkapp.testAction2(PrivateKey.random().toPublicKey().toGroup());
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('action 5');
tx = await Mina.transaction(feePayer, () => {
  zkapp.testAction1(PrivateKey.random().toPublicKey().toGroup());
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('rolling up pending actions..');

console.log('state before: ' + zkapp.counter.get());

tx = await Mina.transaction(feePayer, () => {
  zkapp.rollup();
  if (!doProofs) zkapp.sign(zkappKey);
});
if (doProofs) await tx.prove();
tx.send();

console.log('state after rollup: ' + zkapp.counter.get());
shutdown();
```",[]
457,Dex: Application C - Liquidity Redemption - Test Failures,MartinMinkov,closed,"# Description
Test the failure methods during attempts to redeem liquidity when:
- [x] There are not enough IqXY tokens available for a users account
- [x] Resulting operation will overflow users receiving tokens by type or any other applicable means
- [ ] There are not enough X and/or Y tokens available on the SC side in order to complete the requested redemption.
",[]
456,Dex: Application C - Liquidity Redemption - Happy Path (Vesting period),MartinMinkov,closed,"# Description
Test the happy path methods during attempts to redeem liquidity with vesting applied.

## Actions
Same case as https://github.com/o1-labs/snarkyjs/issues/455, but instead this happy case is processed with a vesting period applied to IqXY tokens.

## Expected Results
Check that it's impossible to redeem IqXY tokens without respecting the timing 
Check that it's possible to redeem IqXY tokens when timing conditions are met",[]
455,Dex: Application C - Liquidity Redemption - Happy Path (No vesting),MartinMinkov,closed,"# Description
Test the happy path methods during attempts to redeem liquidity with no vesting applied.

## Action
User calls the ""Liquidity Redemption"" SC method providing the amount of IqXY tokens one is willing to redeem

## Expected Results
Asked amount of IqXY tokens is burned off the user's account
- Check the balance before and after

Calculated amounts of X and Y tokens are transferred to the user's token accounts
- Check the balances on sender and receiver sides


",[]
454,Dex: Application C - Supply Liquidity - Test Failures,MartinMinkov,closed,"# Description
Test the failure methods during attempts to supply liquidity when:
- [x] There is no token X or Y (or both) created for the user's account
- [x] There are not enough tokens available for users' tokens accounts, one is willing to supply.
- [ ] ~~The user is trying to supply tokens that are not supported by the current liquidity pool.~~
- This case seems to be handled directly by the DEX zkApp. The DEX zkApp will instantiate the expected tokens it wants to receive so it doesn't seem possible to call `supplyLiquidity` with the wrong token.
- [x] Resulting operation will overflow the SmartContract's receiving token by type or by any other applicable means.
- [x] Value transfer is restricted",[]
453,Dex: Application C VM logic tests - token transfers,ymekuria,closed,"Add additional test token transfer test cases

- Transfer negative amounts.
- Transfer more tokens than available to sender
- Transfer to account that doesn't support the specific token",[]
451,Dex - Ensure `TokenContract behaves` correctly,MartinMinkov,closed,"# Description
The [TokenContract](https://github.com/o1-labs/snarkyjs/blob/200be0ca0f575e08af2a62e1a3a001e7f53fd787/src/examples/zkapps/dex/dex.ts#L298) contract should run all its methods without causing any sorts of crashes under proper usage. Edits to some of these methods should be done as more is understood about SnarkyJS patterns related to creating a dex.

The following methods need to be checked:
[] - deployZkapp
[] - authorize
[] - transfer",[]
450,Dex - Ensure `DexTokenHolder` contract behaves as expected,MartinMinkov,closed,"# Description
The [DexTokenHolder](https://github.com/o1-labs/snarkyjs/blob/200be0ca0f575e08af2a62e1a3a001e7f53fd787/src/examples/zkapps/dex/dex.ts#L179) contract should run all it's methods without causing any sorts of crashes under proper usage. Edits to some of these methods should be done as more is understood about SnarkyJS patterns related to creating a dex.

The following methods need to be checked:
[] -  redeemLiquidityPartial
[] - redeemLiquidity
[] - swap",[]
449,Dex: AccountUpdate.create causes error when using a different token id,MartinMinkov,closed,"# Description
When calling `Account.create` with a different token id, the generated AccountUpdate structure fails. 

See this line here:
https://github.com/o1-labs/snarkyjs/blob/200be0ca0f575e08af2a62e1a3a001e7f53fd787/src/examples/zkapps/dex/dex.ts#L51

The following error is thrown:

```
Assert_failure,-11,0,src/lib/transaction_logic/zkapp_command_logic.ml,908,8
    at raise (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:89182:29)
    at ok_exn (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:89221:14)
    at apply_json_transaction (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:422183:34)
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at Object.applyJsonTransaction (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3651:16)
    at Object.sendTransaction (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:179:24)
    at sendTransaction (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:482:27)
    at Object.send (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:115:20)
    at file:///home/martin/Code/o1/tools/dex/build/src/index.js:105:4
```

In the following generated structure, the 3rd account update seems to be the incorrect one.

```
-------------------------------------------------
FEE PAYER B62qk8LrxcgNw7cGxgrNT2zdRdXfiDrP977QixsFYAjsWExVfxSoqJV
TOKEN X ADDRESS B62qr9yya9KmQujHNTwdhE3tKeQXnxrVLkXqxU1ZusqiHCLok6cSDoa
TOKEN Y ADDRESS B62qmjsfVoMTgiKhG9VnVXT7Aj68iwULdy3GmpVpmbd9NZBnyFmwk9f
DEX ADDRESS B62qpRKsCw1ajngMUgPGi5baVkbCxpA8e6JTpRw5wiXf86CFs12GD2z
USER ADDRESS B62qjGfYeKAuuAnHR1AZZcZczFCff4g9WfgKF2cJcNS6tVS4JBUrsDr
-------------------------------------------------

```

```json
{
  ""feePayer"": {
    ""body"": {
      ""publicKey"": ""B62qk8LrxcgNw7cGxgrNT2zdRdXfiDrP977QixsFYAjsWExVfxSoqJV"",
      ""fee"": ""1000000000"",
      ""validUntil"": null,
      ""nonce"": ""8""
    },
    ""authorization"": ""2YFyASSiawWhHP16pdW2cvjST7951LdiYEBrz8hpomqJuSsoiQQMeU3oegkfM2MoHnur1MJJ4DiG8aRWFAqHdyPt7hxUe9K""
  },
  ""accountUpdates"": [
    {
      ""body"": {
        ""publicKey"": ""B62qk8LrxcgNw7cGxgrNT2zdRdXfiDrP977QixsFYAjsWExVfxSoqJV"",
        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",
        ""balanceChange"": { ""magnitude"": ""1000000000"", ""sgn"": ""Negative"" },
        ""incrementNonce"": true,
        ""events"": [],
        ""sequenceEvents"": [],
        ""callData"": ""0"",
        ""callDepth"": 0,
        ""useFullCommitment"": false,
        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""
      }
    },
    {
      ""body"": {
        ""publicKey"": ""B62qpRKsCw1ajngMUgPGi5baVkbCxpA8e6JTpRw5wiXf86CFs12GD2z"",
        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",
        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },
        ""incrementNonce"": false,
        ""events"": [],
        ""sequenceEvents"": [],
        ""callData"": ""27721005166194926617194650269806343668247885010559527474619238547652399684788"",
        ""callDepth"": 0,
        ""useFullCommitment"": false,
        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""
      }
    },
    {
      ""body"": {
        ""publicKey"": ""B62qpRKsCw1ajngMUgPGi5baVkbCxpA8e6JTpRw5wiXf86CFs12GD2z"",
        ""tokenId"": ""x9MUjE7mQiDX1Ajo8wNehCDP2A2V8QauMRtYCyvy7jJ38vckff"",
        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },
        ""incrementNonce"": false,
        ""events"": [],
        ""sequenceEvents"": [],
        ""callData"": ""0"",
        ""callDepth"": 1,
        ""useFullCommitment"": false,
        ""caller"": ""x9MUjE7mQiDX1Ajo8wNehCDP2A2V8QauMRtYCyvy7jJ38vckff""
      }
    },
    {
      ""body"": {
        ""publicKey"": ""B62qr9yya9KmQujHNTwdhE3tKeQXnxrVLkXqxU1ZusqiHCLok6cSDoa"",
        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",
        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },
        ""incrementNonce"": false,
        ""events"": [],
        ""sequenceEvents"": [],
        ""callData"": ""0"",
        ""callDepth"": 0,
        ""useFullCommitment"": false,
        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""
      }
    }
  ],
  ""memo"": ""E4YM2vTHhWEg66xpj52JErHUBU4pZ1yageL4TVDDpTTSsv8mK6YaH""
}

```","[('mitschabaude', ""~~Is this the caller issue? #431~~\r\nEDIT: The `supplyLiquidity` code is wrong: It creates custom token account updates which aren't authorized by a token owner. The simplest solution is to create a `getBalance` method on the token contract"")]"
447, Dex: Application C VM logic token tests - burning tokens,ymekuria,closed,Tests for burning tokens for Dex token contracts.,[]
446,Dex: Application C VM logic token tests - preconditions/assertions on token contracts,ymekuria,closed,Putting Preconditions/Assertions on the Dex token contracts.,[]
445,DEX Example - redeemLiquidity method should run correctly,MartinMinkov,closed,"# Description

The current [redeemLiquidity](https://github.com/o1-labs/snarkyjs/blob/200be0ca0f575e08af2a62e1a3a001e7f53fd787/src/examples/zkapps/dex/dex.ts#L107) method on the DEX example throws an error from OCaml. 

Further, inspection is needed to understand why the error is being thrown and how to fix it.",[]
444,Run a mock GraphQL server for unit tests,bkase,open,"This would be great for things like:

* A regression test that ensures `this.x.get()` in a smart contract for some `State<Field> x` keeps working",[]
442,The results of multiple executions of the decryption function are inconsistent,Comdex,closed,"The correct private key and ciphertext were used for decryption in snarkyjs, and the results of repeated execution were inconsistent. Sometimes the decryption was successful, and sometimes an error was thrown, as shown in the screenshot below:

![error](https://user-images.githubusercontent.com/3725514/192476659-c2b39189-938b-4bfa-9c06-112a262f7109.PNG)

snarkyjs version: 0.6.0
sample code to reproduce the problem(execute the same code multiple times): 
```typescript
import { isReady, PrivateKey, Encoding, Encryption, PublicKey } from 'snarkyjs';

await isReady;

let privateKey = PrivateKey.random();
let publicKey = privateKey.toPublicKey();
console.log('publicKey: ', publicKey.toBase58());

let messageFields = publicKey.toFields();
let cipherText = Encryption.encrypt(messageFields, publicKey);
console.log('ciphertext fs length: ', cipherText.cipherText.length);

let fs = Encryption.decrypt(cipherText, privateKey);
console.log('fs length: ', fs.length);

let pub = PublicKey.ofFields(fs);
console.log('origin publickey: ', pub.toBase58());
```
","[('Trivo25', ""@Comdex I am trying to reproduce this issue, but I can't seem to successfully do so - does the problem still exist - even with the newer SnarkyJS version 0.7.x? Let me know if thats the case, otherwise I will assume its no longer the case""), ('Comdex', '@Trivo25  Running the above sample code under ubuntu and win10 will still occasionally report errors.\r\n\r\nsnarkyjs version: 0.7.3\r\nnode version: v16.13.0\r\n\r\n![err](https://user-images.githubusercontent.com/3725514/211456079-ca2bcf4a-f949-407e-a6fb-d671da5c0da3.PNG)\r\n'), ('Trivo25', 'Thanks! I will look into it again'), ('nicc', 'Write regression test when fixing'), ('Trivo25', 'The bug seems to be caused if `message` includes at least one `Field(0)` at any position. The example seemingly randomly fails because we try to encrypt the serialized public key, which group points can sometimes be odd `Field(0)` or even `Field(1)`. If the `message` includes a `Field(0)`,[ it fails to calculate the correct `authenticationTag`](https://github.com/o1-labs/snarkyjs/blob/main/src/lib/encryption.ts#L66) when decrypting the cipher text. '), ('coldstar1993', 'hi there, how about this issue?? This is key for our current project -- Anomix,  expecting further updates. Appreciate.'), ('joseandro', 'Further investigation from the Crypto team is planned for this sprint. '), ('fabrizio-m', ""It was an error in the snarky sponge implementation. I already merged a fix there https://github.com/o1-labs/snarky/pull/825, it was an internal change, just updating the dependency should be enough here.\r\n\r\nThe problem is with `Poseidon`, for example:\r\n```javascript\r\nawait isReady;\r\n\r\nlet sponge = new Poseidon.Sponge();\r\nlet f = Field.random();\r\nlet x = sponge.squeeze()\r\nconsole.log(x.toString());\r\nsponge.absorb(f);\r\nconsole.log(x.toString());\r\n```\r\nWill print two different values even when we didn't do anything to `x`, the problem was that calls to `squeeze` returned a reference to the sponge state instead of a copy or it, later calls to `absorbe` could mutate the state and thus your element.\r\nIn this case it resulted in the ciphertext being altered before being returned by `encrypt` in cases where the message contained `0`s and then the `decrypt` function properly rejecting the altered ciphertext.\r\nKeep it in mind for any cases that use `Poseidon` in some way, or at least calls `absorbe` after `squeeze`, even if there are no `0`s involved.""), ('Isaac-DeFrain', ""Should this fix be reflected in this repo now? I was attempting to add a small regression test on top of commit `63521d6fbdcda2771ee94f5c3f2a801d5e3b5d9b`, e.g.\r\n\r\n```typescript\r\n// src/lib/encrypt-decrypt.unit-test.ts\r\n\r\nimport { isReady, Encryption, PrivateKey, PublicKey, shutdown } from 'snarkyjs';\r\n\r\nawait isReady;\r\n\r\nfor (let n = 0; n < 100; n++) {\r\n    let sk = PrivateKey.random();\r\n    let pk = sk.toPublicKey();\r\n    let ct = Encryption.encrypt(pk.toFields(), pk);\r\n    let fs = Encryption.decrypt(ct, sk);\r\n    let pub = PublicKey.fromFields(fs);\r\n    pk.assertEquals(pub);\r\n}\r\n\r\nshutdown();\r\n```\r\n\r\nbut this is still throwing an error.""), ('mitschabaude', ""thanks for bringing that up @Isaac-DeFrain! it's not reflected in snarkyjs yet (the fix is in `snarky/master`). Our usual slow processes (`snarky` getting updated in `Mina/develop`, `Mina/develop` getting merged into `Mina/rampup` which is the Mina branch that snarkyjs uses) would ensure that the fix eventually ends up in snarkyjs, but we could also make that happen in a more proactive way, wdyt @Trivo25?""), ('Trivo25', 'If it helps, we could provide a branch that includes the fix until we can release a new version')]"
441,Rename `SmartContract.sign()` to `requireSignature()` (?),mitschabaude,closed,context: https://github.com/o1-labs/snarkyjs/issues/440#issuecomment-1259029378,[]
440,tx.toGraphqlQuery() invalid signature when broadcasting,garethtdavies,closed,"I am logging the GraphQL transaction generated by `Mina.transaction` i.e.

```
let tx = await Mina.transaction(
...
)
```

I would expect to be able to broadcast the resulting `tx.toGraphqlQuery()`, but doing so results in an invalid signature error.

```
""message"": ""Couldn't send zkApp command: (Verification_failed\n \""Invalid_signature: [B62qqPo32ULMxYW745CFdF1z8KAtxbT6Du7jnxVy2XWrBxryQeX72HH]\"")"",
```

The transaction sends via `await tx.send()` but not when I manually send the GraphQL mutation. Is there an extra step of signing this GraphQL request required?","[('mitschabaude', ""Yes, the thing is that `tx.send()` implicitly adds signatures to the transaction.\r\n\r\nThe `sign` commands that work within a `Mina.transaction` block, e.g. `zkapp.sign()`, don't really create signatures, They just mark the account update as one that has to be signed. This is because for the signature to be valid, the account update must not change after signing it, and this would be hard to guarantee if it was created as part of the transaction block.\r\n\r\nOn a finished `tx`, there is a method for actually creating all the lazy signatures: `tx.sign()`. This is implicitly called by `tx.send()`.\r\n\r\nIf you want to see the graphql request with the full signatures, just explicitly call `tx.sign()` before:\r\n\r\n```ts\r\nlet tx = await Mina.transaction(\r\n...\r\n);\r\ntx.sign();\r\nconsole.log(tx.toGraphqlQuery());\r\n```\r\n\r\nI'll document this as part of a planned docs section about the `transaction` API!""), ('mitschabaude', ""Now that I wrote the above, I'm thinking that this should change: `Mina.transaction` could already create signatures right at the end, at least those signatures where the private keys were passed in already.\r\n\r\nThe idea for having `tx.sign()` as a separate method was that we shouldn't assume that private keys are available in the same environment where the tx was constructed. The tx construction / proof creation usually happens on a website, while the private keys would sit in some wallet. We made it so that you can leave out the private key in steps like `zkapp.sign()` and instead provide all the missing private keys at the end to `tx.sign()`:\r\n\r\n```ts\r\n// on website\r\nlet tx = await Mina.transaction(() => {\r\n   // ...\r\n   zkapp.sign();\r\n});\r\n\r\n// in the wallet\r\ntx.sign([privatekey1, privateKey2, ...]);\r\nawait tx.send();\r\n```""), ('shimkiv', ""@mitschabaude \r\n- please also don't forget to rename `zkapp.sign()` to\xa0`zkapp.requireSignature()`""), ('garethtdavies', 'Thank you for the detailed explanation. Can confirm that the `tx.sign()` step does indeed work and I can broadcast the resulting output 👍 ')]"
439,Issue sending batch payouts,garethtdavies,closed,"The behavior of the code to send multiple account updates in a single transaction has varied between all recent releases, but on the [current network](https://github.com/MinaProtocol/mina/discussions/11872) this code no longer works when making more than one balance update. https://gist.github.com/garethtdavies/576e86683ca8b7cd1722108d7efe9504

When making a single transfer, the code  works e.g. https://berkeley.minaexplorer.com/transaction/CkpaDtG9L5LqYguqTya6qYp6k8wvb1xZ1Pc25pEgd8votCS9sunPG 

When making two (or more) transactions, it fails with `Update not permitted balance` e.g. https://berkeley.minaexplorer.com/transaction/CkpYxz2WGF1HLng3D4DfyNwtAjbY7nY8bjfiUgJCcqrPEjaJjjAvx

How can a zkApp make multiple balance updates in a single transaction?","[('mitschabaude', ""can you try to move `zkapp.sign()` inside the loop? I think I recently tightened the logic of creating account updates with method calls, so that different method calls don't all write to the same account update (this would break proofs)\r\n\r\nis it OK if multiple account updates for the sender are created here? if you want just one you might need to use a different API\r\n\r\nalso, is it intended that the example authorizes the transaction with signatures instead of proofs? if yes, then you don't need to `compile` (and don't even need a smart contract, though some of the APIs it gives you might be helpful)""), ('garethtdavies', ""> is it OK if multiple account updates for the sender are created here? if you want just one you might need to use a different API\r\n\r\nThat's not desired/intended, and this behavior also changed. Is there another existing API that I can use for this, or this would need to be created?\r\n\r\nI was playing around with this with signatures and proofs just for testing. In this instance, signatures will be best so I will simplify this - I am simply trying to batch payments that would be signed offline and broadcast. It seems from testing that proving time would make this infeasible, and transaction size with proofs seems to be an issue for multiple accounts.""), ('mitschabaude', ""if you want low-level control over account updates, and don't need proofs for now, then I recommend directly creating an `AccountUpdate` and sending Mina from it:\r\n\r\n```ts\r\nlet payer = AccountUpdate.create(publicKey);\r\nfor (...) {\r\n  payer.send(...);\r\n}\r\npayer.sign();\r\n```\r\nin this way, you always refer to this one particular account update.\r\n\r\nfor creating proofs, what you'd want to do is create s _single_ proof which contains sending MINA to many accounts. To do this, you need to move the entire for loop inside a `@method` -- because only what happens inside a method goes into a proof, and each method call corresponds to one proof""), ('mitschabaude', ""when calling a method, an `AccountUpdate` is implicitly created for that method call, and can be explicitly referred to at `this.self` within a method. that's how you'd do the same in a method -- you just leave out `AccountUpdate.create` and use `this.self` instead""), ('garethtdavies', ""> can you try to move `zkapp.sign()` inside the loop? I think I recently tightened the logic of creating account updates with method calls, so that different method calls don't all write to the same account update (this would break proofs)\r\n\r\nThis worked 👍  https://berkeley.minaexplorer.com/transaction/CkpYvPYQ2yFxp7zXNwwoHPx6Ar6Ntt3wnNtd4KsrvUv1tAJscpS7E Albeit I won't be using that now following the other advice.\r\n\r\n> if you want low-level control over account updates, and don't need proofs for now, then I recommend directly creating an `AccountUpdate` and sending Mina from it:\r\n\r\nThanks, this is exactly what I am after. I tried this but probably missing something obvious here. Here's my code https://gist.github.com/garethtdavies/45329cb7ab45abb2402f1420a3bb2221 but it creates empty accountUpdates, which incidentally appears to be stuck as pending and not being included https://berkeley.minaexplorer.com/transaction/CkpaBbFBhg4uNsnKZCmpT3R83s8cKzBjBhqirnGzWJKqSv1p3PShr\r\n\r\n> for creating proofs, what you'd want to do is create s _single_ proof which contains sending MINA to many accounts. To do this, you need to move the entire for loop inside a `@method` -- because only what happens inside a method goes into a proof, and each method call corresponds to one proof\r\n\r\nThanks, just had my 💡 moment!""), ('garethtdavies', 'nvm this seems to do the trick https://gist.github.com/garethtdavies/45329cb7ab45abb2402f1420a3bb2221 but I do think that other tx is very stuck'), ('garethtdavies', 'Closing as https://gist.github.com/garethtdavies/6dbd312d2c735b59cb30a8ce2bc499d9 works to sign and send batch payouts')]"
437,Feature: Allow offline signing of zkApp transactions,garethtdavies,closed,"For those looking to send multiple transactions before the first is included or signing offline and sending at a later date, it would be useful to be able to manually specify a nonce for the zkApp transaction.

Perhaps this could be included in the `FeePayerSpec` as an optional value?

```
FeePayerSpec = PrivateKey | {
    feePayerKey: PrivateKey;
    fee?: string | number | UInt64 | undefined;
    memo?: string | undefined;
    nonce?: number | UInt32 | undefined;
}
```","[('garethtdavies', 'Updated the title to better reflect what I am trying to achieve, and while specifying the nonce is required, there might be additional requirements to allow for this? ')]"
433,Move verificationKey over to base64,Trivo25,closed,"Instead of using base58 encoding, make SnarkyJS support base64 vk's (see Slack discussion)
https://github.com/MinaProtocol/mina/pull/11851
e,g,
 - `verify` function
 ",[]
432,Field(value) is parsed into 0 for big enough `value`,shimkiv,closed,"```
Field(BigInt('115792089237316195423570985008687907853269984665640564039457584007913129639936'))
```
will be parsed into `0`.
Discussion is [here](https://o1-labs.slack.com/archives/C028Q27R8UC/p1663689466160489)",[]
431,Set `caller` fields correctly,MartinMinkov,closed,"# Description
Given a zkApp `A` and a zkApp `B`, where `A` is calling a method on `B` and `B`'s method calls the `experimental.token` API, the callDepths of the returned AccountUpdates is wrong and fails on `apply_json_transaction` in OCaml.

# Example

## zkApp A
```ts
class Dex extends SmartContract {
  tokenX = ...; // Predefined static address

  @method supplyTokenX(user: PublicKey, dx: UInt64) {
    let tokenX = new TokenContract(this.tokenX);
    tokenX.transfer(user, this.address, dx);
  }
```

## zkAppB
```ts
class TokenContract extends SmartContract {
  @method transfer(from: PublicKey, to: PublicKey, value: UInt64) {
    this.experimental.token.send({ from, to, amount: value });
  }
```

```ts
tx = await Mina.transaction({ feePayerKey, fee: accountFee.mul(1) }, () => {
  dex.supplyTokenX(
    addresses.user, // Predefined static address
    UInt64.from(100_000),
  );
});
```

## Error
```
/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7565
         throw err;
         ^

Error: Unknown error thrown by raise
    at raise (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:89119:29)
    at ok_exn (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:89158:14)
    at apply_json_transaction (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:422097:34)
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at Object.applyJsonTransaction (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3651:16)
    at Object.sendTransaction (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:179:24)
    at sendTransaction (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:482:27)
    at Object.send (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/lib/mina.js:115:20)
    at file:///home/martin/Code/o1/tools/dex/build/src/index.js:109:4
```

To fix this error, we can decrement the returned AccountUpdate structure such that each AccountUpdate's callDepth is decreased by `-1` and this passes the transaction logic in OCaml.","[('MartinMinkov', 'The returned AccountUpdate structure information looks like this:\r\n```sh\r\n-------------------------------------------------\r\nFEE PAYER B62qocNf46Ha3uHaGL9dqts7RymUkp6NAdaeEJD1uREnQPktCEnBLzE\r\nTOKEN X ADDRESS B62qiWSeSKfrQtNDK1NS8kWQx47XRU5vZpEiLsfLD7UCDLH129W2MLi\r\nTOKEN Y ADDRESS B62qjhc4mVfJ7pivZBsXvazZF25NZdjdsyZXnGV7ky6BYQYhkgEXGUD\r\nDEX ADDRESS B62qnC4nm3QGbACvTuMUeoL71Z3tJYHuJwjeFPaV9Gy8g7MHpEVSbsf\r\nUSER ADDRESS B62qn6zy1v1oXiKRmRcxVsq1g1d5K43XmbBAa6VEuhwiYxfY5zbuE1Q\r\n-------------------------------------------------\r\n```\r\n```json\r\n{\r\n  ""feePayer"": {\r\n    ""body"": {\r\n      ""publicKey"": ""B62qocNf46Ha3uHaGL9dqts7RymUkp6NAdaeEJD1uREnQPktCEnBLzE"",\r\n      ""fee"": ""1000000000"",\r\n      ""validUntil"": null,\r\n      ""nonce"": ""8""\r\n    },\r\n    ""authorization"": ""2Y9zLiaJWSGSjWaXRSPdRZJNgbZfZ8DMEtpD7FokBqhVfjDm1Vr891dsRBTVskN1R6mYH9UJ4jrPwzoRethJ6conKiZw4c2""\r\n  },\r\n  ""accountUpdates"": [\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qnC4nm3QGbACvTuMUeoL71Z3tJYHuJwjeFPaV9Gy8g7MHpEVSbsf"",\r\n        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",\r\n        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""27844747632040987822835044034241057360065235687377880862175908066088598750842"",\r\n        ""callDepth"": 0,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""\r\n      },\r\n      ""authorization"": { ""proof"": null, ""signature"": null }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qiWSeSKfrQtNDK1NS8kWQx47XRU5vZpEiLsfLD7UCDLH129W2MLi"",\r\n        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",\r\n        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""26326833007358166804286463660768160329913206018574041538454780538661343953593"",\r\n        ""callDepth"": 1,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""\r\n      },\r\n      ""authorization"": { ""proof"": null, ""signature"": null }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qn6zy1v1oXiKRmRcxVsq1g1d5K43XmbBAa6VEuhwiYxfY5zbuE1Q"",\r\n        ""tokenId"": ""xyjpbF6zLnmgGXyNSRmvs3V3RapqJUswVajoH3azqYJtHZ24Pz"",\r\n        ""balanceChange"": { ""magnitude"": ""100000"", ""sgn"": ""Negative"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""0"",\r\n        ""callDepth"": 2,\r\n        ""useFullCommitment"": true,\r\n        ""caller"": ""xyjpbF6zLnmgGXyNSRmvs3V3RapqJUswVajoH3azqYJtHZ24Pz""\r\n      },\r\n      ""authorization"": {\r\n        ""proof"": null,\r\n        ""signature"": ""2XycBckTPigeJWFxvDkQZr3SxpKUybx1eqzvds4RWg8qxdfhxdEdBVoHmkX3akvig2R6PHT1PcXHSraFoFReC3TGJ94kaeN""\r\n      }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qnC4nm3QGbACvTuMUeoL71Z3tJYHuJwjeFPaV9Gy8g7MHpEVSbsf"",\r\n        ""tokenId"": ""xyjpbF6zLnmgGXyNSRmvs3V3RapqJUswVajoH3azqYJtHZ24Pz"",\r\n        ""balanceChange"": { ""magnitude"": ""100000"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""0"",\r\n        ""callDepth"": 2,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""xyjpbF6zLnmgGXyNSRmvs3V3RapqJUswVajoH3azqYJtHZ24Pz""\r\n      },\r\n      ""authorization"": { ""proof"": null, ""signature"": null }\r\n    }\r\n  ],\r\n  ""memo"": ""E4YM2vTHhWEg66xpj52JErHUBU4pZ1yageL4TVDDpTTSsv8mK6YaH""\r\n}\r\n```\r\n\r\nIf we mutate the above JSON by decrementing each of the `callDepths` except the first AccountUpdate, the transaction passes.\r\n\r\n```ts\r\ntx.transaction.accountUpdates[1].body.callDepth -= 1;\r\ntx.transaction.accountUpdates[2].body.callDepth -= 1;\r\ntx.transaction.accountUpdates[3].body.callDepth -= 1;\r\n```'), ('MartinMinkov', 'With more debugging, it seems like only the second AccountUpdate needs to have its callDepth decremented. The second AccountUpdate is the one authorizing the third and fourth AccountUpdate to transfer with the token ID `xyjpbF6zLnmgGXyNSRmvs3V3RapqJUswVajoH3azqYJtHZ24Pz`\r\n\r\nThe other AccountUpdates can stay with a callDepth of `2` but the second one cannot be `1` it seems and needs to be `0`. Perhaps when we are checking token owner permissions, the callDepth must be `0`?\r\n\r\nThe following structure passes:\r\n```json\r\n{\r\n  ""feePayer"": {\r\n    ""body"": {\r\n      ""publicKey"": ""B62qqWg5kvqfS3bTSMmpQf3Tmmv3vQxNFEGzaptJRUsrPc43qosACeB"",\r\n      ""fee"": ""1000000000"",\r\n      ""validUntil"": null,\r\n      ""nonce"": ""8""\r\n    },\r\n    ""authorization"": ""2YBsLgWC2YAQ67rAtyX9sV1zd1SSnbtc7sKZ2kmrSYJXveGm7BsiNKZogqfdcudKKdYGhHazJ2ESE4YcVAucs6vx5dYegHM""\r\n  },\r\n  ""accountUpdates"": [\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qjXdWUeyBdVmQbS76cAu2qh9CtqugENS8KNd61y26gqeP4puNmzS"",\r\n        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",\r\n        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""28869995081278789409771545739953174210826547621079449161541559758395950353542"",\r\n        ""callDepth"": 0,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""\r\n      }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qiwFgEvv1d9NcY4Ami4ppDh9xXJBxFNoajYR2PQvSGgj826qF9pP"",\r\n        ""tokenId"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf"",\r\n        ""balanceChange"": { ""magnitude"": ""0"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""19867955630180358289712396963517118037333099034522140433473590371695877781027"",\r\n        ""callDepth"": 0,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""wSHV2S4qX9jFsLjQo8r1BsMLH2ZRKsZx6EJd1sbozGPieEC4Jf""\r\n      }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qjRN8LUMwYwnVSSST9LTTvUti13VTcNqvpyedztajq5k2uinG1oA"",\r\n        ""tokenId"": ""wdnkTq6xh6bzMjWc8p4WGanKem1wguYbS2L68QgULCGppR84rw"",\r\n        ""balanceChange"": { ""magnitude"": ""100000"", ""sgn"": ""Negative"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""0"",\r\n        ""callDepth"": 2,\r\n        ""useFullCommitment"": true,\r\n        ""caller"": ""wdnkTq6xh6bzMjWc8p4WGanKem1wguYbS2L68QgULCGppR84rw""\r\n      }\r\n    },\r\n    {\r\n      ""body"": {\r\n        ""publicKey"": ""B62qjXdWUeyBdVmQbS76cAu2qh9CtqugENS8KNd61y26gqeP4puNmzS"",\r\n        ""tokenId"": ""wdnkTq6xh6bzMjWc8p4WGanKem1wguYbS2L68QgULCGppR84rw"",\r\n        ""balanceChange"": { ""magnitude"": ""100000"", ""sgn"": ""Positive"" },\r\n        ""incrementNonce"": false,\r\n        ""events"": [],\r\n        ""sequenceEvents"": [],\r\n        ""callData"": ""0"",\r\n        ""callDepth"": 2,\r\n        ""useFullCommitment"": false,\r\n        ""caller"": ""wdnkTq6xh6bzMjWc8p4WGanKem1wguYbS2L68QgULCGppR84rw""\r\n      }\r\n    }\r\n  ],\r\n  ""memo"": ""E4YM2vTHhWEg66xpj52JErHUBU4pZ1yageL4TVDDpTTSsv8mK6YaH""\r\n}\r\n```'), ('MartinMinkov', 'The error raised seems to be happening on this line: https://github.com/MinaProtocol/mina/blob/e4a75d6037b2fcf82fc3a873cd7baeedbb0adaae/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L2969'), ('MartinMinkov', 'More specifically, this assertion fails because `is_normal_call` is false\r\n\r\nhttps://github.com/MinaProtocol/mina/blob/e4a75d6037b2fcf82fc3a873cd7baeedbb0adaae/src/lib/transaction_logic/zkapp_command_logic.ml#L894'), ('MartinMinkov', 'This bug occurs because the `caller` field of the token contract is incorrect. By the `caller` field to the token id of its parent (which is the Dex), it will pass transaction logic.'), ('mitschabaude', ""So it seems best to set the `caller` field in terms of  `Call` / `Delegate_call` as done by the protocol.\r\n\r\nProposed action plan:\r\n\r\n* [x] Implement the translation from `Call` / `Delegate_call` in JS, following https://github.com/MinaProtocol/mina/blob/d75a421ff620f704c78b23e45ee561250a705f5e/src/lib/mina_base/zkapp_command.ml#L614\r\n* [x] Make normal zkApp calls be `Delegate_call`\r\n* [x] Make the `experimental.token` functions be `Call`\r\n* [x] Enable some low-level way to make something a `Call`, to be used for now for the WIP token with proofs.\r\n* [ ] Maybe later: Automatically figure out when a `Call` is needed (= when an account update has a custom token id) and eagerly modify the first suitable ancestor to be `Call` (or throw an error if such ancestors don't exist). The question is, when should we do this figuring out? When creating the account update (probably not)? After all account updates are in place, just before the transaction is finished (probably works)?"")]"
430,Fix `fetchMissingData` with remote blockchain,mitschabaude,closed,,"[('mitschabaude', ""doesn't seem to do the right thing anymore\ncausing stuff like\n```\nError: x.get() failed, because the zkapp account was not found in the cache. Try calling `await fetchAccount(zkappAddress)` first.\n```""), ('shimkiv', 'https://github.com/o1-labs/e2e-tests/issues/34'), ('shimkiv', 'Issue still persists.\r\n- Deploy [zkApp](https://github.com/o1-labs/e2e-zkapp/blob/develop/e2e-zkapp-sc/src/E2eZkApp.ts) with some initial account state (say, `appState[0] = 2`);\r\n- In SnarkyJS Web version reload the page after SC deployment to make sure the state won\'t be available and zkApp SC instance will be re-instantiated if needed;\r\n- Invoke zkApp\'s method with some constraints (for example the `update` one passing same value `2` as was used with deployment) by calling it in Web version, similarly to [updateOnChainZkAppStateWeb()](https://github.com/o1-labs/e2e-zkapp/blob/develop/e2e-zkapp-ui/public/javascript/helpers.js#L403) method.\r\n\r\nSC method invocation will result in the error like this `""Error: assert_equal: 0 != 2""`, where `0` means that the current state of the account is unknown.\r\nBut should you manually fetch the account\'s state after this, like calling the `await fetchAccount(...)`, and invoke `update` method again - you will receive the correct (for this SC) error `""Error: assert_equal: 4 != 2""`, where `4` means that now account\'s state reflects the truth.')]"
429,[BUG] - Cannot call a @method that returns a value directly from a transaction.,MartinMinkov,closed,"# Description
If we define a method that returns a value (like in the [composability example](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/zkapps/composability.ts)), we cannot call such method directly from a `transaction()` call.

This is currently happening on SnarkyJS `0.6.0`

# Reproduce
Given the following method:

```ts
@method callAddAndEmit(_x: Field, _y: Field): Field {
   ...
   return Field.one;
}
```

An error will occur when we attempt to directly call it in a `transaction` block
```ts
tx = await Mina.transaction(feePayer, () => {
  zkapp.callAddAndEmit(Field(5), Field(6));
});
```

The following stack trace is reported:

```
/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:7565
         throw err;
         ^

Error: Type ""undefined"" cannot be converted to a field element
    at raise_error (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419334:44)
    at value$6 (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419400:43)
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at /home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3643:18
    at new eval (eval at caml_js_eval_string (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3630:44), <anonymous>:4:26)
    at to_field_obj (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419416:35)
    at /home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:419708:44
    at caml_call_gen (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:2081:17)
    at Function.<anonymous> (/home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/_node_bindings/snarky_js_node.bc.cjs:3643:18)
    at Function.Class.<computed> [as toFields] (file:///home/martin/Code/o1/mina/src/lib/snarky_js_bindings/snarkyjs/dist/node/snarky/proxy.js:21:62)
```",[]
427,"Unable to verify proof, without running compile on any contract first",maht0rz,open,"When attempting to prove a JsonProof using a pre-generated verification key, there is an `unreachable` error coming from snarkyjs.
<img width=""1006"" alt=""image"" src=""https://user-images.githubusercontent.com/6826282/191209773-fea25ec9-0297-44b8-91ff-c61e9adca4df.png"">

This error goes away, once any contract is compiled before attempting to verify the predefined proof/verification key. (on the same snarkyjs instance / test run)

**Test:**
```javscript
import { isReady, Proof, verify, ZkappPublicInput } from 'snarkyjs';

await isReady;

class TestProof extends Proof {}
TestProof.publicInputType = ZkappPublicInput;

const provable = {
  ""proof"": {
    ""publicInput"": [
      ""12382964772465717553707802216515042376795600974038280693475344666344015420841"",
      ""0""
    ],
    ""maxProofsVerified"": 0,
    ""proof"": ""KChzdGF0ZW1lbnQoKHByb29mX3N0YXRlKChkZWZlcnJlZF92YWx1ZXMoKHBsb25rKChhbHBoYSgoaW5uZXIoMDlkNTQ3NTVmM2Y1OGI0OSA1Mzg5ODgxMTQ4M2Y0MDIxKSkpKShiZXRhKGY3NjY3YzZjNDVhMjliNWYgODE2NDA1YWI3NzU4ZTIyNSkpKGdhbW1hKGM0ZjM4MDg1ZmVhYmI1N2IgNWFlYzdmN2I5ZjUyZWQ2MSkpKHpldGEoKGlubmVyKDYzYWY4NWM2NTgzYTExMTAgNDhiNTY0Njc1MjllZWM4ZSkpKSkoam9pbnRfY29tYmluZXIoKSkpKShjb21iaW5lZF9pbm5lcl9wcm9kdWN0KFNoaWZ0ZWRfdmFsdWUgMHgwODRCOUQxNEUyODU2Njk2MTQyNThGMDlGRTc3MkU4RjQxQTc4MDk1RDU2MUJBNTQ0MUVDNzY2MzlCNDZCMDg3KSkoYihTaGlmdGVkX3ZhbHVlIDB4MzNDMEZFMTg1RjBDNTA0MjU4ODg4RjdFQ0Y1OEQ2MTQzRjkzOEI1MkNFRDk3MjBFQkMxQjEzNTBGNzgwRUJCRSkpKHhpKChpbm5lcig2NGNkZThlOWM3Y2QwOGUyIDFhZDRkMWY2YmJkOWM1ZWEpKSkpKGJ1bGxldHByb29mX2NoYWxsZW5nZXMoKChwcmVjaGFsbGVuZ2UoKGlubmVyKDk4YTNkMzVjYzI3YTlmMTAgNjFhOTZkOGFmOTg2MTNlZCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDcyMDg0ZjZhYmI3YmY5NjYgYjA2NjdjZTBkZDI0ZjhmZikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDRlZTZjMzZhMjI0YmJhNGUgMjQzYzQ5ZTQ3MGYxOTFmYykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGVjYjE3MjQ3ZDYzMmQ1Y2MgOTcxMmNkN2QzZTQ1NGZiYSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDEzZmNjNGQzOWFlOGVmMWIgNThlOGViNDE1MGJmZDE1YikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDFlMGJmMWRiMjliMWJjNWYgYzA3NDBhNmNiZDMxNmZlNSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDA4MGIzMWMzMWE5NDg1MTMgOWEzZTQyMTZlMGQ3Y2M4MikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGNmMjE0ZGVjMTVlZDQ1ZDIgZGNlMmQwYWJlYWMyNjkzYSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDMyNWY2MDdmOTNlZTNlNzYgZWM4ZGNhYmQyNjQ0Y2QxZikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDFlYzAyZmM1OWNkNzkzMDggZDFmOGNkY2I4N2E2NTY5MSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDEwY2M2MzcyZDA1YzdjZjggNGFiMWUwNDA1YjZjZjY4NikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGRjZGIxODY5MTczODAzODAgMDQ4ZGI2ODUzYmViNjU2OCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDIyM2NjMTFkZGFjY2U3MzMgNmI2OWY3ODg5OTg4ODAzMikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDQ0YTFiZThkOGUyN2E3YzkgZDQ5NDJjMjY3MjdkNTk0NSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDRhMjI3MTQ2YzNmYzlmNzIgNzYyYjYxYmQxYWMyMTk2YikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGVkYTE5YmFlM2Q4NTAzNTAgM2Y0MDBiY2RjYmQyOWNlMykpKSkpKSkoYnJhbmNoX2RhdGEoKHByb29mc192ZXJpZmllZCBOMCkoZG9tYWluX2xvZzIiXG4iKSkpKSkoc3BvbmdlX2RpZ2VzdF9iZWZvcmVfZXZhbHVhdGlvbnMoY2ZjYWU0Nzk2MTU1ZGEzZSBlNWM5NWQ0ZDNmODg4NDk5IDkwOTc4Y2JkMzAwY2JjOWEgMTEyOWJkOWQ1MTJjZGM2OCkpKG1lc3NhZ2VzX2Zvcl9uZXh0X3dyYXBfcHJvb2YoKGNoYWxsZW5nZV9wb2x5bm9taWFsX2NvbW1pdG1lbnQoMHgwNkQxREEwMjdBMTNBQTAyOUQyRUM4RjAyQ0NCRjVCQTlCNUFCM0ExQTk3MTFDQTUzQTRCRkE1MzI5MUZDQzEzIDB4M0NCMjMwQjYwNjExNDZDRjMxMEMzQ0JFQThFQUVGNDRFOTMwNEU5MUVGMjlDNTJFRTg3NjUzRDA1Qjg2MzU4RSkpKG9sZF9idWxsZXRwcm9vZl9jaGFsbGVuZ2VzKCkpKSkpKShtZXNzYWdlc19mb3JfbmV4dF9zdGVwX3Byb29mKChhcHBfc3RhdGUoKSkoY2hhbGxlbmdlX3BvbHlub21pYWxfY29tbWl0bWVudHMoKSkob2xkX2J1bGxldHByb29mX2NoYWxsZW5nZXMoKSkpKSkpKHByZXZfZXZhbHMoKGV2YWxzKChwdWJsaWNfaW5wdXQoMHgyQUExRTc3MUFGQjdDODFDOTIxMTA4RDQxRjA0NjBDNzBBRUNFRDFDMUU4Q0I3M0Q0QkNFMzAzOEEyQkZBNEY1IDB4MkNCRjExQjJDNTg1NTVBMjg5NUVEQzlGQTZDMzdBMEEwMEU4MERBM0FDREI4RUQzREJDQUM2MkUwNEU1MjMzQykpKGV2YWxzKCh3KCgoMHgwQTMxM0E5MENGOEVFQ0U0QzJENkM5NzM1MDIxNTFCQzdBNTBFQTZDOUFCNjEwNDFDMjVGMjE0NzA2N0JEQzMwKSgweDE4Rjg4REYzRTQzNUVGMDg0MDM3RUFBRUY1MzRFM0VBMjM4ODI4QTBFRURGMTdCMTkzNDU1MDAwN0E0QkNFQjApKSgoMHgyMzlBOUQ1NjhGQjc5MUE1ODMzMUExQjMxNkU4ODlEQzhEQTNBMTExNEE2MzY0NTJBRTVDNDgwNTU2RjRFMDE0KSgweDM0MTZGQTM1NDY2MDE0MjlGQUFFMTlGOEMxRENFRkM3MUNDQUY0MjU3RkY0MzFFM0RGMDIyRTg2RThBODQ3ODkpKSgoMHgzQjg0OTcxNUMxRUFBMDMyRURDMTQwQUExMzYwOUY5QkI1NTM1OTdBQTEwMTE4MUVGNkQwMUQyMzMxOTMzQUNBKSgweDIwRDI5RkNENzY5ODc5NTA3REIxNTQ2NzlDMEU1ODJBRDE1NzA0NjQ2MzczMjZDQjNDOTY4OEZGODc5MzEwRkMpKSgoMHgwRjBBNTM2REUyRDVDRjc5REQ3NjZERjY1OUE2NzJGNEQxRThDQ0EyMjc5RDhEQTUxOERGQkI4RDI3MzYwMDIxKSgweDEzQzQwNjgyMzU1RUZGNjc4OTAyOTQxOTJDQzM0MEM3NTk4QzE3M0QxNDk2MjRCQjk5RjYwNzk5MzZEQjFERTApKSgoMHgwOEI2RUI2M0RCMTMyOUE5NUI3MkZBM0ZFREE0MUQwMzBENTgyRjA5NzBFNjVEMUM3QTdFNzFDMDk4MjBGOEYwKSgweDBDRTkzRUJDRDUyQzM1Mjk2NDJFNTJGNjhDMDkzNDQ1QTZBNjNFQTZEMEI2NEUxMjQ0OTY3OTNGRkYzNDk0Q0QpKSgoMHgxMjA3OEM1NTVCNjMzRjkxQUE0NUZCMTA5MUNFMDU1Q0E2ODY5NUJFRDg1QzIzM0MxMkNGMENBQzREM0JBQkFCKSgweDBBNDAxOEZCRDY2RDE0NzVDNEQyNTgwMzA4RjQ3NjIxMTAxOUZDQjhCQjQyN0E3OTc0NkFDQUJFQTQ1QzdEMjIpKSgoMHgwMzE4NjNCQzhDOUMyMUExODZGQjYyODdGNzMxMUVDNUE0QTRDMjRBNDIwMDEwNkI5QTgyREMxNjBGQzBDQjJFKSgweDAzNjdFREE4QkYyOTU5NDkwQkU3QjRDMzQyNjQ3NDAxMzUxQTlFQkI5MkIzMzJFMkEwQzVCQUZFRDJDQjkwMjgpKSgoMHgwRjA2OUE4MzQ1MkFEM0M0MTJFNzA5RkI3RjM1MjZDRjU5NkY2N0JGNkFFRTY5QzNEQTlCN0M3QzZCOUI2QUQ2KSgweDFBRUMwMUU4MjgwNkEyQkM1NzA3RTI2RjE5MjUzNzMzMTdEMTQ2MDY2MTQ5QjRFMDU2RDRCQkIyQTUzRUQ3QjEpKSgoMHgyNTU5QzlENTJCNEY0Q0IzRjlENkU2RTVDNjMwOEVBNDFFQTBDRjY5RjlENjFCRjQ4M0IyNzYzM0FENkJBNzg2KSgweDM0NjNEM0IyQkNDNEZBOUQ2QzcxOEVBNEM2RjdERTJFRkNGMjIzQTcyMEMxNTJBMUYyM0Q0QUYxNDU5NzZCN0MpKSgoMHgwRjZCRjNBQ0NFM0IwNzM2QUUyNjM3Q0IyMjYyMkI4ODI0QzA5QTgxQ0RGQjFCMjk1QzA5MTZCQTEzNjRDMDc0KSgweDE4NjgzM0M4NkQzNDMwQjIwNjdDNTY0QkExQjg3NjQ1RTExQTFGNjI1MTI5OUVCMThFODZGNkIyRkVDNzQ2M0IpKSgoMHgxMkVENEMzQzBERUJDRUExQTAxNkM1RUQ5NENCQzc0Mjg5ODlDQzVDQzM3QUJDNkYzNERBQTFCQkVFRDE1OTFBKSgweDE1Nzg1MzZBMjQwNzlFNEI4RDRFQTQ4QjA1NkFGMDAzMDQyMjM3REQ5OEQ3MEYxRDc1Mzg4NEU0NjZBQUFFNDkpKSgoMHgzREJBODVGQUY4NzVBMjBGMjcyQkE5RDc2NzU3M0YzOTEyQUE2N0FDRjhCQ0Y3RDVCQUFGNDA2OTI4NzFEQTkzKSgweDFDMzVFRDgwMUIyQjJFMEEyOTBGNzUyMkNFMTk5MDc2MkIzODFBQjZBQzI0NTg3NEE3NjlBRkY1QUU3NTg3MEQpKSgoMHgyMEM4QzFCM0UzMzlGRTZENUZDMTVEMDVGQkUzQTNGMjJCQzE1NjdDMDAwNzlGNzU3MkYxRTE5Qzc5NENDQkIyKSgweDM2MjgwRThGODc3RTg5RkNBRTlEMDhCNzc4MEU3RkRDNjdGMDc3M0YzOTQ3QjIyNEU4OEQyRTNCNkE1OUNENDgpKSgoMHgxODZEQzEzREVCMjQxQTREMjYyNEU0Qzg4MEE0N0NBNDA0MzZBN0NBNUQ3N0ZDRUFFRDA4QkVDRjkyN0JGNUM1KSgweDIzMDc0RDA1M0MzMDg5MDU1NzMxRkRCNjRERjQwRDRENzlEOTY5RUIyQzgzRTc1MEJDMDQ3Njc5QjdBNkU1MzEpKSgoMHgxMjk2NzQzMjNCNEFEOUI4NjYyRUVEOTdEQUJDMjY4OTNDOTZBNEU4QTA4RDQ3N0QwMUExQkI5OTk4N0M5NjJGKSgweDIxOTVDNEJGRjcwMDM0NjMzRjVBOTExNTkxNDVGREE1OUE5NDNDQTAyRUEzMkJGRDczOTVERjkwQzg4NTJEMDQpKSkpKHooKDB4M0EzOUNDNjk2MjBEODczQkZCNjY1NjMxOTQyQUExQ0NBMDRBNUI3QzU4QjUwQzlEQjVCNkE1RUI4MTE4MDYyOCkoMHgzNkZDOTNEM0FCQ0FFNUZDOEQzM0JGQjAxRTI0REI2MjUwOEY1NDMwRkNFOUNFRkMxNzczMDYxODVDQTQ1NDM4KSkpKHMoKCgweDAzMkU4OERCNDRGRERDQUU1N0FGOTYwMjVDODkxMzZEOEQyMENGNkM2QUI3MkMwNjgwMDU0QkI0ODlBMzBFNDEpKDB4MjA0NEE3RTU0QzQ4Q0Q1REY1M0RDREE1NjQzNEU0NTU0MjBGODdENjg4RENCRTRFQzAwRTBDQTg0MUQ4RTZDOCkpKCgweDFBRUNDRDA0Nzk3REQ2ODcwOEIxNUZBODJFRTAyREQyNUU2MjMyMTYyMkNCQjA1MEJFNzhENzMzNUQwODcwQkIpKDB4MTc2NDQ4MTI5RURBMTFGQkY0ODQ3MEVGOEUxNzVGM0E0QTVCNjYxQ0Q5RDhCMDc4MzQyNDk4MjcwREI3QzgwOSkpKCgweDNCNkJBRTkxOUU3OEQ1MzdEMzc4MDI5ODI1M0ExMzYwOEEzMzQxOUNGMEY0M0U0M0FDMTQ1MzdGMzRBQjQ0NjEpKDB4MEUwNkYwRUY0NDA2QzMwNzdDM0FCODM0NUFEMTVFRUI2NzM0RkFFNjkyRTY1RkNBQkFCMjY5Njk1NDdEQzgwMCkpKCgweDJEMTc5MzE5QTZDODRFNDg1MzhDQTdGNzlFNzFBREU1REVBNzMxQkE2M0NFQ0Y3RDRGMjk0OUU1MUFBQUI1QzIpKDB4MDFFMTI1QjJDNjFGODFFQjg4RjlFNEM4RTYzQkMyMUEzMEM4QTA4RDM4NUU3RjI0MDg0MUIzQkJBRDNEMzE3MCkpKCgweDAxN0M1QTE0MzlFOUJFODZFNjYzMTk4OEVERUY4MkJFM0Q1RkZGNTk3RkQ5RDQyM0Y1NDFGNzNBRDBBMTU1NUQpKDB4MENBQzEyMTlDQTAwRjgyMDkzM0YwN0I1MzUxQTg0RTRGQzdGRjZBRDgzOTMzMDhERDRCRjFDNkU5MTUxQTVEMSkpKCgweDIzQjZBMDU3Qjk3MEIzRjhCQUVBQzQxRkJBMzdGRjEyRTAyMUY4QTEwMDc1QzFCQzJFRUM3Nzc0NzFDMjI5OUMpKDB4M0QyMjNFQzVBQ0RFQ0NCRjBEOTlBQzlFQTk1MUE2M0Y1MUVDQTY0MkYzNDgzQzg5QzYzMEE5QzY5REIzRjVDQykpKSkoZ2VuZXJpY19zZWxlY3RvcigoMHgzREVGOTJFNjQ2NzEzM0UxNjU0MjMzMTY0MDMyRUUwRTBDOEYwNzQ4MTAyNDQ1MEZCRjZBODhDMkQ4ODQ5RURDKSgweDIwOTk1QUFFRkUxRDQzOEIwNTc4REVGREM2NDhFNkU1RUUyQTcyMTk5QTZDMzNGN0E3M0Q2REUyQUZDRTYyNjEpKSkocG9zZWlkb25fc2VsZWN0b3IoKDB4MTIxNEY0RkU0MDNBMzQzMUM3OEUzNzk2NDA1Q0U5MjE3NDE1MDU1RjNCRjIxQjhCM0ExQkVDMDdBODM5NDE4RSkoMHgyMjU5NEIxODU0OUY0Nzc3OURBN0EyRDMyRUM2RkFGMjZDMTYxMTQwQzFCRTQwMzg2M0Y5QzQzQjA0NkM5RDVBKSkpKGxvb2t1cCgpKSkpKSkoZnRfZXZhbDEgMHgxQTE2OTg3NjYzNjU3RTkxMkVGQTMwODRGOEI1RUIzOTlEMjA4MTIyRUFCNkNBMkMwRTEwQzlEMUM2QUYxMDM2KSkpKHByb29mKChtZXNzYWdlcygod19jb21tKCgoMHgzRkVGQzM1OTQwODI1MUMzRDY5OUNBMjk0NjFBMTVFNEY3M0Q5M0JDM0VCNkIzOUE3NkExMTM4NUQ2QzgxNzRDIDB4MTE2MjdFMUE2N0RBMDBBRkFGQUM1NzcyRjlDNTA5NzJDMjhFNDg0OTkxQzVCREE5ODU2MjIyQjRDMDk4N0JFNCkpKCgweDMyM0NDMzk3RTRBMDhDOTk2RTM3NDYxN0Y1NkU1MTIzN0RDNDAxMkY1Mjk3NjU3QUMxNUZCMEY2QjU1NDA3MkQgMHgxNUEwQUJBRjkwOEZBQUU0QUMyQjU4OUMwNzU4RTkwMEFCRkYwQzBBQUI0MTEzMjJFMDEyRTgyRUY2MDU4QzBFKSkoKDB4MDY4NzRGOENBNDlDNzZEODJENEJDOTREQjlEQkM5RTUyMUEzRTJBODk1RUQzMzU1MjZFNEQ0MDE2QjJBRDUwQyAweDI2OTI3RkI4QTI3RDQzRjUyRTc1MDczOTVBOTZCQkVGRjMzMUJDQjZGOENCRUZCOTRCMDJENjMzRUFGMjYyNEMpKSgoMHgxMUJCQTc1QkI5QzUxRDIzN0Y3MTlBRkQwODg0QkIwRThGRjVFNTBFM0YxQkFFOENDOUMwNjM3RUJCNjU0ODg0IDB4MUU2Rjc1QjZBOTAzNzMzQUJDMjU5OTc5MDFGMjAxMEQyQUExQzMzMzA4NEVCMkIwODREQTFCMEFBM0E5MEExQykpKCgweDNGNTQxQzEyMDQ3MjA2NUI1RjE2REMwMUMzMzVCNTVFRTg1ODg5MTRDM0IxQkFBMUE2QzhFNTA1REZGNDlBRTYgMHgwQjNERjJGRDc1MjkwMjg0MDVFRUU1NDk0OTU0N0JDQjlFQUJFNUU3NEE5MTAyNzAxMUY3NUZCQTUxQjc2RDhCKSkoKDB4MDREMTE3NTc2ODQxRTZDMzZEMjc0N0Q3NzYyNzJFMUMwRUU5M0Y5MDVEMTk4MjUzQzAxQ0JCOTRFRDUxNjlBOCAweDM1OENDMjQ4Q0IzOEJFQkEwMjJENjNFN0M2MzU4MTBFODQxNURDRDQwNzE5MkY4RTY4NEY0RTA5RTcwNTZENkEpKSgoMHgyM0UxRUI1RUMyNENGNEU4RjFEODNENEY0OTk4OTA0Q0FDNEI0QTMyNkQ2MEE4NzFGOEE2ODM3OTNCMjlBQzEyIDB4MjNENkJGOTQ3RTUyNDYwQzFBQjAwQUZGMEVCRTczMTAyMDEzQ0QxMUE1QzI0NkUzQjhFMUQ2NkU5NTZENjM4RCkpKCgweDI0NTQyMTRFQkM3MTEyQjdGMDVGRTVBRUU4Mzg1NERERjAwMkM3NTIyMUVFODczNjcwREQwMzI0MjY2NEUwMjYgMHgyOEUxMjZBNkVCMTNGRTU0NjdBREE0NzU4NzI2NjgxQzVFMjUzMUVDMEMyRUI3RTMzRjk2MTRGQjcxQjA1NDBCKSkoKDB4MTdFODY3N0RGRjY2RDk5MEZEMDFDNEIwQzIxQ0U4MTY2RjgyRDhENTExMThCQ0M2QzU0QjEzOUM2MTE0MUY4MCAweDBCNTJCNUU1QTQzNzcxRTRDQjA4NkU0Qzg0RTFDQzUwNkZGQTE1RDU0RTAwNURBQjU2NTlBQjQzNEI3OTM3MjkpKSgoMHgzNTIxNjBFOUIyRjkzODkxODYzNTkyQzY0OEI0QTdGNEEzNEM1NzlBMEE0NEUxNjc3QjcxRUY0QzI3NjkyMkVFIDB4MjBEM0JDQTI0REU0OUU1QkU1NDNDRDU3OUUwRTJFNjc1QThDQzc1RkNERENGOEI4NTgyMjM0REU0QUZFNzI1NykpKCgweDJDRkREOTA5MDg0RTlCNzU4RThCQ0RFMTA4NUY2QTQ3QzA5OEVDQ0QxMUE1RThBQkFEOEZGRjIzNTQ1REJCNzggMHgzRjk5ODlCQ0FEODU4RURDOTMwMDE4MkExNzVCRDBDNThFRjM5OEVCMzg0M0VFRUUyQzBDMjI0RUJERUIxNjlFKSkoKDB4MzM2OEIyNEExRTE0NDE1NTZEMDM3RUJBMjI5OUVFODZGM0RDQTAwNzdBRDhBNEMwQTBFREQ2ODM4NjYwNUMxQiAweDJENDJBMEY3RDNDQzI0NEEyRTI3RjYxNDc2MDA4QUUzRTAwMDYxMTdDRkFCQjBCQjEzMUY1NzlGRjdFMTVGQTQpKSgoMHgzNUQ3MjI5REMyOTBDQjNCOUEzNzYwQjg3MzFCNTFGRTY3NkI4MkIyRTVCMEY5NzQ2N0I1QjI1MjU5MThDMjBGIDB4MEZFN0JDNTEzM0JDRkNBREQ4QTdFQURGQzNDOEY1OTE0NEM0MjUwMkEwNkMzMDcyRDVDNjBGODIzRUQ5OEZGNCkpKCgweDA2MzU4RkY4MjE0OUIyM0EwMjBGNzk4QjQwRDI4M0QzOTJFMkYxQUY0QTU1RjBFODNCNjE1QUM5MThFREM3QkEgMHgxQkZEOUM2Qzg1NzQyMzNGRDU5RjcwMkEwODBFNTg5MkNCMTc4OTk0NThENkQwNDRDMDRENTQzQzA0RkQwNEQ0KSkoKDB4MzMwOUNFNkJGNkNCRTVFRjI2NDVDRDAwMDFDQkQ5REY0NzhCQ0M3MUU4RjgxM0FCNTBFNjMxNjQ0MDMzNzFBRCAweDA1NDFERjhEMEZEMEU3NUFFODQ1MTIzMzNCQzdBODk1ODQ5MkM3RTk0MTBCQThENjQ0M0YyM0FEN0NDRkNBNDUpKSkpKHpfY29tbSgoMHgwMzFEQ0U3ODgwNEVDQ0ZFNjlCNEYzNTJBOTdFQkJFMUU5MEMxQTMzQzlEQTc1MTI0RTU2QUM3QUEwQzgyQTExIDB4MjZFRTdEQTQ2MDBGRDczMURGNEM0MzY3MTQ2RjE3NjMyRUQ1N0RDRDJEOEU5QTc0OEUyRUY2NDAwMTgwOUMxRCkpKSh0X2NvbW0oKDB4MEEyOTczQjEzQzQxQTJFRjI0QTk3ODBCREQ2MEMyNTgwNEZDQzVFRDU2ODJEQzIzODQ1NzU0MzM4NTUwQjA1MSAweDAwMTE4RTk3ODRGOUY3OTM2Q0I2OTdDNzJEODNBQUQ1N0ZFODgwQTJBNjEwNjM3MEE4NDAzQTRDMDFCRjJDQjkpKDB4MDA3Rjc3OUI0MTIyMjM3QjQyNDc3MDIzRTEyNzQyNTBDMzJCQzcyMTQwQTE5RUNCNzdEOUJFRjEyRDBBRkM4MyAweDNCQTlFNUVCNTE3MjZBNzU5ODJGMUU5MjAyQUJEM0U3MEFFRkU0ODRBMjkyQkQwMkFCOUZGRjJDRjJFQzNGQTYpKDB4MjlCQjRBMkFFMTY4MzE0ODFGODFGQ0JGODRCRUE2M0RDQzE3MTFCNTY3MUJBMEUzMjgxMUFDQ0JFODBDRjI1MyAweDBBOEEyQTc5MTQwRjgxNUExNDFCQzI2NTMzNTExQUY5M0VGMzdEQUVGODlENUFGQzdDRjc0OEUxN0I5MjBENEEpKDB4MjE5MDZDOEMxRTk5ODI0RkVEQzdBNTE4RDI4RDlBMTAzOUM3OTZFN0IyQTMzMThFRUExMzE3RTgyQjcxRUI1RSAweDE4MjAxNDQ3MkJFRjE3N0E4MENDQkM5N0ZBMTBFQTI1OEYyQzA0Q0I4RTM3Mzk4QkU0ODVGOTI2QzUzQTQ3QUYpKDB4MTM1MDI0QkM4RTgzNzgyQzAwOTIxMTAxNTM2QTMzNDFBNDJENUYxMjkxNTcxNTE0QzEyRjhENjNFN0YwMTBFNCAweDM3ODY2NTYyNTlDMjZCRkY2M0VCMjAzNjE5QzkwMDI5MkI1QUJBOTcyRTI3NzU4QUY3NEYxODA2MjIwMEMxRkIpKDB4MUIyNTg4RUI4NTk4NUM3NjFBMjc3QzJDRDRFRUJEMTFCMkVDMDcwQzJCMkNENUQxQUZCQ0Q5QTA1RDU1NjExNiAweDJCMDgyOEUwOTVBMEExRTJBMkQ4NEQ5N0Q2OUQzODc2NzVDRTI3OTIyRTg0NEQyMzM2RjgxNDdERDQwRDk5NkYpKDB4MjI0MkQ5QTU2QjY0OTYxNTNGMkYyOEEwMUQyMUM3NkYyOEMwODI0ODNGNDkzRkQ0MkJFQTZDMzA3OUQ3MzU2OCAweDE3OUM2RURDMkY1MTIzMzlGOTk2QTVGOTU3QTQ2Q0U3RjNGRTdCMzk0NDI3QjE0QTAyQ0JCRTAyNjA5MTQ0MkUpKSkobG9va3VwKCkpKSkob3BlbmluZ3MoKHByb29mKChscigoKDB4MURERDNBMTRFNjkwRTgzMzA0RDIzQkJDOTBGRUEwMUVCMEU3MUQyNkE4OThBMTcyMjY4OTcwMDhEN0JERjBGQiAweDMwN0I2REMxREU4RENGRDQxMjE4RjRCNUZBNzlCRjM2NzVDODNBQjhDQzc5NjQyRTRCQUVGNEY4NTYzODg0OTgpKDB4MEI0OUE1NURFQjIxQzM5RjFGOUE4NUQ0MTIzNDNBODVFOEQ5RTdFNTIyMTE0MjQ3RTIzODFFMzRFOTFEQzBBOSAweDA1RDlCNzkxMDdDRTJCOTBDRkZCREVFOEY4NURBQzQzN0VFOTY4MjJFMTY3NkI1Nzk4QTUzQURBODA5RERBQTcpKSgoMHgyRjA2M0Y3QzlDMUQ2NUQ5QjlCRkE2RDNGQzMwMzMwMjNCMkU3NTdBRUNFQzVEMEE0NTYzOEExOEI5NkFCMEU0IDB4MkNEREUwMTEzOEZCQjAyOEI1RjMzNTlENkNBQTU3MTUyMTAxMkI1QzdBMTA3RjA1REQ3QjkzMzMzMEQ2QzVBOSkoMHgyQkJFODNDREU1OEI0MDJFOTAyNDI4MjBBMzRBOEY2Mzk0Qjg1M0VCMDNEN0UxMzEyRjVFRDU1NEFGQjlBRjRCIDB4MjJGMjgyMzhBMzU0QzZFNkQ3MzA5NjhBQTUzN0E5QTM3MTNEMDA2RUFDODlFOTkwMzJGOEU5MTc5REQ1Q0M4OCkpKCgweDM5RjIyOTczODkyQTAwMDk4QUJFM0RFRUJEMzA3MUQ3OTZFRUQ3ODg1M0ZDMEU0NzY0Q0E3MzQwNDA5QUMwNEYgMHgyQzE0NUJFN0FBODU2NkQ3NDc5RkREODAxMzAwQzdCRTM0MUUzMzNCNkFBQTYzRUEwM0YyRDg2MzMzQjlBRTc0KSgweDM1ODA0MTI2NDIwQzIxREIxQjlGRUU4QjBFREIwRTA1NDBCMzQyMEVCQzYzRjE1RUJCN0JCMDhEQzY0RDZGQzggMHgwM0E2RkQ5MjRDQTJEODYyMTdDMUE0ODU2QkU1NkU2NDRCMzAxRDkxRDdFNjUwOTM4NkE4NTNDOTNDQjc0QzE3KSkoKDB4M0VGN0E1QjY0OTE1REJDMjE0M0YzQ0VDNzkxMjEyMjdCMTcyQTdBRUYxMUY1NERFMUQ3QTYwRkJDQkIxQTM2NiAweDExODEzMzYxMjMzOUNFNzc1NTA3OEM0MEFERUM2QzZBRjI5NjI3QTg3NTNEMDk5Rjk0OUY4N0RCQUUxRTMyMTQpKDB4MkJFN0U0RTBENTA0MzQ3RTI0NjgzNTEyQkI0MTE4OUEyNDg0QkU4NkYzNDdFRkUxREQwRjQ2OUFGQUZCQTFBMCAweDAzNzMzN0M1ODU4NDhBMUQ3MTVGRkMzOEU4REY1NTA1Q0IxQTNCNzY5N0U2ODhBNkI2RDQ0NDg5RUY0RkEzMkMpKSgoMHgzQzFGNTcyNjk0QkUzMjQ0QTQxQzkwODkzOEU1MDZGRTVBMzkyQ0E5QzhCRTQ4OEVFRjAyMEYyMDhEMzY0RTYyIDB4MEVCMUM2MzM4OEJDMzgwMzdBN0FFNEMzOTNBNzIwMTczQzdGNTk2QjU0N0JEQUU0M0JENDY1OEJBOUFCMDM2NCkoMHgxNUEyODk1RUZFRTJDNjVENjI4RDFCNTNCQjExOTY4QzAwNkI2OTBGNDdGQUVFOTczM0VDNzBCODJDMTE5RTdCIDB4MjE5NjY2QTYyMUY4RTc2QTc2MTIwRjQ4RTM5NjQ2RTVBNDVENTQwNzdFNzAyRjZBRkU0NjI3NEM1REVDQUUwRSkpKCgweDMzMjc2MjQ2QUYyOTdBM0MxMDcwQkMzQ0IzOUMwMjRCRjU0MDE4RkVGNzgzRTMyMDdCNDJDNTBCREJEQkMyMzAgMHgzRUZFNTY5MjIzNTBDRUJBMEQzRENDQjZDRjA0MzNFQUNGOEU4OTU2RjczM0ZBNjNGODk4Mzc0N0Q3QzI3RTk1KSgweDJFOUIxN0VGMjVBQ0RBRkFDQUEzODI3QzVDQkMxQ0U5NUYxRDg4QjBBRDM2MDU4RjBFMzdBODVFMUQwNTg2NjkgMHgxRjUwMzc3NDJBQjIwN0ZGODY4OTFGQzk0MURBNEU3QzZFMDczREU2M0JCOTkyNTEyNzdEMkU3NTRENTk3NURGKSkoKDB4M0U2N0IzOTk3MkNBMEFBNDQ0QzlGRkQ1RkMzNTc4MTNGMjAwOTZFNzM1NkQ1MkMzRjMwMUYxNkNDOUVEQkY4RCAweDFDNTA0QUNENzdEQzA2QjA0OUZEQURDMjgwRjM4MDMwREE0OTJDN0IzRjg0OERDNTQyNDhFMTcxRDk1N0FEMDYpKDB4MzkwNzI3RUQ1Qzk4QzFENDQ3MjVEMjhDRUM3MTcxRjJFRUUyNTYzMUQ1QTU1RTEyMjhBOUNDREJFRDFDQ0M3OCAweDA1QUU1OUQzNDM2MzdDNDA1ODI1NDcwNTYyQUJGRjhCOTc5ODdDRThCNkIwQzk5OTBEQUI5MEJGMjk0QzE5OEUpKSgoMHgwNTMyOTQyNjQyMzlGMkUxQzFGOUFBODMxRTMwMEJBREE1NUNFQTUyRTQ4QzIyQzg4NkM1QzVDN0U5NUY3MkQyIDB4MTc5QzYxRDBENTUxRTU4Mjc2NEVDQzA5QzQ1NTcyMDA1MTI2MUYxODU1REMyNjgzQjc4MERCRjE0M0JCNDdFRikoMHgyMzFGQjEyRkMxQkI2NEUyNDdFMThGRDFGRUVENTA2NDE1ODJFRDI3MkY5Nzg4NUJCRTAzMkZFRjVENTk0NjU0IDB4M0E3QjQ0OTEwQUQ1OERDQjVBQzQyQkFGNzU4NjgwRTBFMzAwMzM0RTU5MDk2NzM5QzRERDgyMTNCRDVDN0I1NCkpKCgweDE4MTYzOTExOTg3OTYwQzZEQ0RCQ0M0RERERDZEQjI0Q0QxRTEwMDI1MjE3RTRFNkQwMzQxRTI5NUQ4NkIyQzEgMHgzNzlDMEU3RjgzMjFDNjJGMDc4RkEzRDZFMTJGRkVBOUYwRjk3NDM3NDVEOUU2MzA5QjQ3RTVGRDYyQzIxNUIyKSgweDBDQUJFM0IzOTVDRjA4OUY3NzAzMkJBM0UyMjYxRkE0N0Y4NTRDQ0M5NjI4MUQ4QTM3NjZGNDY3NUNDNTExNDkgMHgyNkQwRjdGNkMwMDI0QkQ5NzFDMzBDRjAxMTA4OTAxMUQ3RjAzMUU2MjcyNzkyRDg1NDUyOUZERERGNjQ3NzE0KSkoKDB4MjY1MjRCRTYwREYxRTAxQ0MzMjkzRkU3NDFENTRGOEUwM0Q5ODRENEU4RDU2MkM5MzQ1QkExMUJBOEQ3QUQ4RSAweDNDQUUyNjBGREYzQ0U4MjZGRDVGOEIzNDNBNjAyOTNFQThFNzc2MUY2REE4NDhDNTI0NDYxNjdEMzdEREUzQkIpKDB4MTI3NTI0RTMwMzIyNEZEMDEzREI1NUMzREYxRDk1NThFMjM3ODA4NTkzRUE1QTBGMEQ4OEJBMTY5MjM0MzFGNSAweDA0NjVCQTlBM0QyRTQ2QjJFN0UyRjEzQzFEOTlEMjQzMzhDQkE4NDI4RUJENTlDOTk3RTFCMjVFMDE3RTZBMDQpKSgoMHgwODI0QkI2Qjc0NTRBOEE5M0M2MTg2ODJEQTQ5RDdFQkI1RTQ5RkYzMjM1OTEzNTg2OUFFNTZCM0RDQUUyRTAzIDB4MUNFRDcxRTMxQ0NENzgwRkY4MUE2MTY3MjkxQ0VEQUExRENBMEQ1RkFFQjVFQTYzMDM5REI5QjMwN0Y4ODk4MSkoMHgzODMyQ0I4RjIxMTA3RUY5NkFDRjJGQTQwQUU1RUY2QUZCMTBDQzRFNjU0MjUwQTZGMDlDMjEwOUMzRkEyMUIyIDB4MTY5RUJBRjQ5QkE3MzYzMTlFMTVDNkJDQTU0MzBENDJCM0VDOUI0RjhEMTdDNEM1QjA4OTc4RDNGQUQ2ODE1OSkpKCgweDAyMUY1QkQwRDgyRjlEOEEwNzE0QzcwQTk3QzRENDdCMkM5ODlEODkzOTcxNjhFNDA2RkYyMzQxNUY0NkNDMjkgMHgwNzNEQjhGM0ZCODMyQUM2MUEzRjREODk1Mzg5MTdDREZDMEY0RjEwNTNBQjY2NEJCRTZBM0U0MkQyQTNFNUM1KSgweDI5QUNFRjgxMjJCRTZBN0E5MTcyNEIyMTU5Q0Y4RDAxMTg4MEExQzVFNDhBNkU4NDAzRkI0RTVCMzBDNEFEODggMHgxN0ZFMjM1OTRFODJFN0I4QTJEMzUzRUE2MkMzMzlFN0QzMzNGRTRGMUZFOEUwQjMzQzhDMzhBRUU4RTg4RDQ3KSkoKDB4MEVDRUEwNjAzQTdDREUwMjAwOTY0ODBBNjVBMjU1NEJFQ0FGQTI0MUQzMEE4QzEzRTg0QTc0MDJBRUY3MDZFQSAweDMzRTU1QjYzNjk4MTBGRTQyMjYzNEE2OTFDMDlERkIwNzE4NTg5M0E1MzVENTVCMUREQUFFMDVENzZBNTg0RDcpKDB4MDVGMzk3QUMyOEM1NDJCMUVERTJDREQ5RjU4QTE1NDAyQUJFQjhENzIxN0E0QzJDODNGQzBFQzQwQjRBNzNFQSAweDIyRTRDOTRFRTA3MzM0MUU4MUVEMDhGOTQ3NkU5QTE0RjFGM0M0RkY0QjI0NDc2Mjg2OEJERUFBREREQjg4NzYpKSgoMHgzMTJCQ0E3Q0NDNkE3Rjc1OTEzRkE1NUExRTIzRDE0RTVDODE3MTQ2MTU3MEFBQjBDRUQyNTFGNzYyMzBDRTgwIDB4MEFFRDI1OTQ1ODI0ODk3MDdBNEUwRDczMzY2ODgzNDZDNEUxOUEyMzIxODI5NjU3MTdENkJCMjdDNDU2RDZDOCkoMHgzRjkzMkU1MTE5MEIyRjI3Q0NBOEZFMzEwQTcyODMxRjE1RTI4OEU4RUMzMTQxMTU5Mzc5MUJCNTcwQUJEMzMwIDB4MUNGRTA3MjlEQ0QzNzc0MjRFNzQ2NDg2NDdBMkVCM0JGOTVBQzlGMEUwNzFBRDcwOEVFQkQ2QkU0M0E0RUUxMykpKCgweDNFRjc1OEMyOTFCNEIwODI4NkIxNDhDNzVDNTA3MDM2NzRBMEIwQ0Q2RTczNDEwMjdFMjY5MUNBNjJBQzRGNDcgMHgwMzQ2NEVBNUM0MzhCQzg5MTc4Q0FCRUU1M0U4OURCOUREMTlDQTgyMUExNzJFRERDNjk2RTk2RENFMDM3NjdGKSgweDM4RkY4MkM0NkYzM0U5N0RBOTBGMDk1OTNGRDg0ODdFN0I3OTA4QjZBRDRERkIyNzZCMTNBRjRFRUE1RUM1QkEgMHgzNTVEMEVBQzVDNzA3MjExOTY4NjQ5REEzODMxMzE0MzE4NUU1MUYwMTgzMDM5QkZFMjE3NUEwRDY0NEQzQ0RCKSkpKSh6XzEgMHgwN0NBMzRFQzYyOTU1ODczNUNDNTEzM0UxOENEMkEyRDE2OEEzNzM0MjA0NTZCN0E2RURGQzMyRkUyMDYxOTJFKSh6XzIgMHgzRkU5QjM5NDY4MEI5QkQ4REY1OTgyMzNCNzVDNkQ1OEY3NzgyQTYwREFCQURCM0NGMzVEM0JEMkI4MkJGNDI4KShkZWx0YSgweDEzRkVGNEExMkUzMUE4NzA2MDEwQ0JDNTY1NkM4MURDNDA0MzhBNTFGNEM3OUM2QzIyREQwMzVGRkQ2RkI2NkIgMHgzMkNEMEQ0MkU1RDE5MDU2RkI5QjFDNzRCRDQxMENFMEVGMjA3OUMxRjMyQjIxOEJGRjE5MDFDRTM4QjhGQTdBKSkoY2hhbGxlbmdlX3BvbHlub21pYWxfY29tbWl0bWVudCgweDFBMTMzRkI5N0IxM0FDODdDMjA2NjFEOUExOUQzRDYzM0ZFMDREMDI5REFCMzE0QjNFRjE4MUY4RTMwRUZEM0UgMHgzNEMyQjI0QjY3OTdFODQwQkI5Nzg1MTdDMzFFMzU1QkFCNDU2RkQ2MEUzRkRENjhBMTFCN0IxMUUzNzhCRjU3KSkpKShldmFscygodygoKDB4MzBBNUU5MTc4NzA2RjVBNzIxMDA2RjkxMUQyNkQ4MDdFNTkyNEE5MDQzRjFFODU3MTcwMTA3MzVEMTdCM0ZBMykoMHgxNTQ3QjU5NkVEMTFGRDIxM0VCRDEyNEM4RDNCNTAxRUZFQkRGQUQ1M0NFNDcyREMxQzMwRUU2QjIyNzNGMzZCKSkoKDB4MjEwRTJGOEM1MzNCQzVENUYwMUFGQjA0MDIyNEU4MTM2RUY0Nzg2RjVEM0Q2RjhDNUE3MTdCMEY1MzQ1QzU3NikoMHgyQUVBNUY4MUE4MTVEN0JDRjZGRkE1ODhBQzkwNjE5NjI5OERFMUUwQkI5RjQ5NkVGNEQwN0E2RThDNjlENTFBKSkoKDB4MEIzNUJCNEMzQkI1OTgwRTQwRDQ2NEZGNjAyMERCMzE1MDdERjBCRkVBMDgxRDg4MjhGREIyRjVBMjhBOEJDMSkoMHgzODlBQUNFRDYzQkUyQjA3REU0ODU0RjI1MDk4QjE2MjkyRkZCQkZDMzMwNkQ4MzkyRjNGMTdEMjM3QTgwNzI2KSkoKDB4M0Y5OTc5QTBCQkJBNkU3QzMxMjY2OTJBNjZERUY2ODg1QjlEN0U2NjY1MUEzQzA2MThDNDRFRkVBNDg4MzI3RCkoMHgxN0VDMDA1NDNFQjg5REY0NjRFNENFOTBBMkUwM0ZFRDI4QUI2QkMxQzFBQkE3QzRDRUY2QzJEMEQ1NEMxRDcyKSkoKDB4MEJGMzkxRDlFNURBQ0Y5RjBGNDlGMUNFNzdCRDE3OTMzMTI5NDcxNkRBNDU5MzU3Q0ZFMDAyNDgyRkYzQjMzRSkoMHgzNkE2NUFENjRGMTIzMzlBOEUxRjU4MTAxNTM5NDFENjBGRjI1NDA5NDM2RDI1M0UzNjE2MTkyMkMzM0MxNDNGKSkoKDB4MkMxMEM4MkYxNzg5RjQ3QkM3NzIwNUUxQUUzMDZCRTM0RDAwQzQ1OUJFMjI4MUM0NjdCRDIxRUM5MTZDNTY2NCkoMHgwMjQ1MTI5NThENjk5MDVFQkVEODEyNTI0Mzg5NDZGQjVGOTA0NDZGMTBCMzRCMTc3MjFDRkY0N0JGRDYxMDMwKSkoKDB4MTJGMTNBQTFFMDIwNEMwRkVBMzFDOEZBQzJEQUZEREM3Qjc3RDI0M0MzMDdFMDc4REMwMzk2MzhEMUMyNDY4RCkoMHgwMUJBMDk5Rjc4QTU2OUQ2OUQ1NjYxNEUzOEFFRThGNzJBNTM4NUQwQ0U3RDk5QjYwOEM2Q0UwNENENjE5Mjg5KSkoKDB4MzQwRUVCRkUxMDJGRDZCNDg2QjdFQUU2MjMzQTUyMTc5NjcwNDQ3N0FDMjdEQjMyNTU3RkVBNDU2OEEwMDNGNykoMHgxMEEwRUQzNkExNEU1NEUxQkM0RjI3RjgxNkI0RUJCNEJEMkIxQzI3OTg3RjMzN0NDMzAyREZDQTM0QUZEQzNFKSkoKDB4MjU0RjQzQjUxOEY5N0U1RUM5NjRBRUI0QUZFRjBCQTNEQ0UzNDEyNTE0QTJDOTRCODFGOURFMzc1OTIzN0ZBMCkoMHgwMDQ3RDFERTY5MUM1QkI1MUQ5MTZCRURBNUFDODcwNDQzRDMwNTk2MzZBNUU5NENCOERDOTMyNTQyRTMyOTUzKSkoKDB4MzIyQjUzMjQ2RDY5RkM2QkYyQ0I4Q0EzOTYwNDE0MjNEOTIwNEU0NERERjlGQ0ZFODFCRUZBRUQyMjVFNjQ1RikoMHgwNkJGOUNBNDZERTA3OUQ2RUIxQTZDQjFDQzUxRDUxQUFFOUQ1QTBBRDI3NzUyQ0U1NzY1OUVDQ0IyMUZGMDMxKSkoKDB4MzgzM0ExRDI5NUU0NjY5NkMwNjIxOUVENjI5MkVFMzE1RjAyOTBCQkE1RjVGQzE2OTkyMEY5OUI4NDE3MzhCRCkoMHgzRDFENzJDMDgwOTFGMEQ5Q0Y4MTAwNDNDRUEyRjNBRjQyQ0VEOEQ0ODNGM0E1NDU0RDE4Q0NGNDMxMTI2RjhFKSkoKDB4MDQ4MTU0RUU0OUNFMUU4RkQ5QkI2RDZCQTEzM0U1N0EyOEExNkQzMkNCMkU3NUZBOTg2MkIxOTkxOENEOUE0MCkoMHgwQUYwNDI3MEFDNjU3MUY3RDhEMDVEQzhEMUVCNDEzOEQ1Mzk3NDBDREFDOUM3M0Y4Q0ZFRDA1NkNCQ0MyRkVEKSkoKDB4MTdDNDIyNjg1NUREMEY0NEIxRjY4ODI0QTE4NzhEMEIxMDAxODZCRTZFMTREMUYwN0YwOEMxOEU0QzkyMDU4MykoMHgyOTkzOUJCQ0I5RjFGMUE2OTgwQUZFQjkyNjk3ODU5MEIxNUZDNTdGRkEyRUI1RTM2NDgwQUVBQjRFMUIwN0M4KSkoKDB4MzQxREZGMjE5QTMyREZFRjNGRDgwQjY4MzM2QkU5RTlCMEJBQ0ZBMTA1NTlGOEY1MzI0NEMyOTZCM0Q5RkI1NSkoMHgwQUFCRjQ3NzAzNjc4OEU1QzZEODk2NEU3NDhCREU3MTZGMTdFNzFDQkE3Nzc4NkQ0REU3NURFM0Y3OUNCNDQwKSkoKDB4MTIzNDUxQzE0RUFEMDI1Rjg0NTQ3MjI0RUM0RDYwN0E0RkI2NURGOEUzRUNFNEVEMEI2RDNGNzI0NzU0RjhGOCkoMHgwNTZFRTIxM0UwMUU5MTVEMjUxQjZBQzcxQ0U5ODVBMDQwNzBGRDQ3M0ZERUY4OTVCOTc2RTdFMjU1ODgyNDFCKSkpKSh6KCgweDIxRjRCNEREQ0Q2MDU0RjdGNzZCNERDODdENTY4OUJCODg2OTJBNkM5N0YzNjMzQzgwNTA5QUU2M0YxOTZFQkEpKDB4M0JENjA2RUM4Rjk5RkUwN0EwQzYzNEExQzZBM0U3RjQ5REI5QUU4NjE0NEUxNDUyMEE0NzgwRTREMkY5OTdFQSkpKShzKCgoMHgxMDU1RjY0QTRENkY5ODg1RDk4MTQ3QzBGNTc1MjJCNERFQjZCMjMyNEIzNTExMTU3RkFEQkMyMDZDREJBOTgyKSgweDIxOEIyNkUyOEM3MTM1RkJCMTIwRTQxOEVDQkY3QzFEMzYwODZBN0I5OEE1ODAwREJGNEVFRjVDQTBCODJDNEYpKSgoMHgxMDY2RjdBQ0M1QzI4QzE0NEUyNzgyNDU3RjJGM0E1OEZERjI0MzA4NkJFQkYyRjE1RkRDQjUyNkJFNkVCMEEyKSgweDJBNTU4Q0FFNjJENTkxMjQzNjg4QzI1Mjk1RDVFMzhCOTBFNjcyRkQxNUEzMDAwRUMzRjUzNjNBNTYyOUExOTEpKSgoMHgyMzhEQ0U5OTIwQUIyMjNCRTJBQjI2QkRBQTNGMzRFRTZGQkY3MzYwOTc5NjExNTIyNTkwMDEwQjIxMzM1NEFBKSgweDM0Qjk1NzRDQkVEMkNENzNFMjM1MDM2OTVBOTgyRTNFMzZCNTA4QTlEOUYwNEMwMjRENTkyMTgyNDBDN0REQUUpKSgoMHgxQkI4NzVENEEzOEIxRTlEOUFFNjM3RjlBRThGRkY4Q0FFQzdBQkNFNTVFMTkwRkFEMEIxQTZGNTcyMjAwRDlBKSgweDM5RjY2RjEyMzJFOUEzMUQ4RjIyOUYwMDY4NjAwMThFMTlBM0U3Q0VDMjYwRENGODlBQjE3MTZFN0Y0MzMyNEEpKSgoMHgwQjk1OTg5NDdDOThCQzEyQjUxODRFRDc3OTVENTk3QTQ1OUQwMzk5NTNFMEVBQjZFRTJDMEQ1NTNFOEFCN0ExKSgweDAwODRBQzE5MEVFQzgxQjRFQTZDNDg5RUQ4ODQzMTZDRjJFOTMzMkU3QzhGQTMxM0JCMUVDQjZEMEZGMjUxRTYpKSgoMHgxMDIzNTZCQUE0NjRGODBDMzg4MkVCNTQxMDZBOEFGRDdFNzA4RjU0REEzRjFGMUE0Q0NERTBEQTE3QTMyNEYwKSgweDBDNzc3NEJFRkMwMUJGOUE1Q0Y0MTg4MTlERTBGRkE2MDREQUJENTM4QjFFRjg2ODBGNEM1RUUyMEVFNjYyQzApKSkpKGdlbmVyaWNfc2VsZWN0b3IoKDB4M0FFQjdDNTU1MzVFQjdFNDk0NjlEMjZEMEY5QkQ1OUI5RjIxNjg4RDhFQUUyQTlFMjFGNjUyNzc5RjRCOTM0NCkoMHgwMTIzQjZBQTdFMTE2RkEzNUUzNTUyMTY2RjU4Mjk2RTRENUVCMjY4QTgwOTRGOUUyMkJDRjMwQkQ1N0M4ODExKSkpKHBvc2VpZG9uX3NlbGVjdG9yKCgweDA2ODI2NzI1MzExRERGQkJCNDE3Qjg1MENFRTc3RUVDMDZCRUNDNTQ2NERFQUY2Q0RCMjJEMjVGRDE3MDFCNEUpKDB4MzQ3MkQ0NkUwRjBFODZCOEFFMzE3ODQyNUE5NUIzREM4Q0NFQkNGRjNBN0Q1MzY5RTU1OTRGRDFEMTdEQUY4MCkpKShsb29rdXAoKSkpKShmdF9ldmFsMSAweDEwRkU1NTlCMUI0N0I3OEMwOUVBMjhDMUZCNkY4Q0RBN0ZENENCRkZCMDU4RTlEQzk0NjhFMjMxRjU0QkJEODIpKSkpKSk=""
  },
  ""verificationKey"": ""DxZi5KRnuL5Go38oJxnvY82vu5ThyQ9Tsnxc5xSc7Hu8E8mt27UVZJZagSCsPn4PyeR8wVQLBmyvSKkzH7hJXsirttRRkRZvu5seDDjRU78qtUNwzsQNTog8MqCc8SzYodzWbQbQuatsmfA8ZdApCdvWsbuayyv8ppYJf6c7fpPid4ca4tGLQgvxaTHy7cqzgk2RKFkhw9qskpygZcC5dQzE6JU74pCqgjP3hS1XMsQcCwQU5LixpGRM5fvXi4TCxnXRgTFbkQyafmJcKFFbQyJeafvykQk78JrZQyJP1ooB5bSE7bL2ZyCCPbnDTC1c2nsg2K8ijSt5xHEY1dLfdEyshsP6a1JWHiuXXvw91dXgEVUtqV3sWnNXuizRqGTbReP6Mw5PWjDCCUejGqJhtypB6ZtVaaoKw2DZG6Y2UP6NTkwoErddWaGzz6QqyqBZ7TfqJZ2BMkVsTmy2euBfXaSeiAFTvtKDcshsycq1CdBUYrMbbTAjZwoGi1CuXYNGH7EfC3XmXmVqzEkPWbtJRwxdTzApwTMFpyAa77wZNUdPmBTYUZnRWGRL22WZpmqP3ebTENWSDA3bXNqFAaY3GuHk7HCm81GU9dQEaAtVdhNZLEjiKV8jDrFMASeGzcrSeSW98ZPef44nCJYusYzs1P8W55aJXUzjN3uG9NJbLrH32CL3SGc7RgeLmLBuzW4tYuccMUKDLkWpn3dwvdqf51sBWkh8MmJabHV2zswwb6aXFSYzUUHziDwk9LVJwsukCk6ZxoFJKbjNRXsTDzAVWUsDSq5GX8ogJSw7631TrkuLLxFfQM3WB9ft63AWaSf6jBHHQaD4jaVzNzJGh1ddN7P4Z722nSJR6BRmQVMZuv7A7xj8Yqy1Xny4oMtcsN1wPxUEPwmAqNrKWmVPtwy8nfrYVBJLAmVGJVxcM1bF82AAFjbYK7tHFQ4vDckWUU2PUWAt4gDArxuKfDqYUHdCdkbj4U3usustFaAUX8yDenzQp6sPLvXqBYVdNUcAdvM3cTyppsLhCMi4BbH2R9f3JmCyMkUeVBj17P59MGqajoaWgkvC54HqXskuZnjjwBbQ2dXkxYNtgWmt9ZPqQbXMrb1KLMxghKdYuJQAeYTxyEqiar2G9CJmp4or1wss46JCmoGAHd6GshptRHMNNCWV9KVvt9KrVpnbxpDhmasd67yi11mtsZRnMjsucYvPJW4pDj6e9mmJUbXgrVaxSYy2cuTFRkZQCPwe9t4ucnd57Fw5WuycRbzeAvzkxnb8nC1CvZkBMZkidLH1QH7Y2UsVkvrURDBF6LBaoHpxytYpCDgeGVCfMB3t7ZFghR457PvTcMTj1gxZfPJrzy5AdZhbRtW5zqifoJ7rL3FKw2zzWqAhMQ4aJ5TB6wxKXvkc4UANkeEaiLgUWPJrVzrqzZfU1PXkWLNyR7mbCPnMpxuiwKyqth5MgWDzdgTA26PoZajR6vrrr4sMKCGocygnuMGBVdVvGvT1KpxPokR4pgiYWhzW61V76CiZ8Hi7GbunjdfmFdr7o7WGzxT4qjLF35WuTixs5XwHKAB1M7CeaQkJGNSYN5B3NHCnWdiinF9ks64tuJoCdzXjxe4YR9BenprSxAvz66owk9z9r1qUs7QRJwn1rkwSMeGUCyeGEC8jn3SrVCPKUJnohJ9sMR7AUjDVjuta7AM51pGFG7xG7RgPt2E6xWwzxkkvHt4cY2vBrNL6XeVyFdx7fa2w5iobNm3TAupYQcMyo8tqMQmzcT9RgTu4wJ2kjmsUu8GTLV15CZCwsB96joE1MfvVBfn6vQS7nWhqzmcJW37cHsKwUvpBmpXBWE2DPJ5vCkh16xvcjjpZ9CwodTfyt4x9DfJgzifMxvVb3GUyimuRZACARwtJ5VHqK9esQ8SVwnJihWqUkmRvHeJyrjDE1SXmdwWwDpFMMD7fjbY68kmY8eyzBejx1fUWxUU63eZfTrTNPBU5PEi9GYTb2v53UPrgjwdsCsK1uKb4mNdjxj67sYc1tJZtZQUc3RmcsrHJXZAXCT4ePjpGufoufN7R1bDEz1Xg6f3vXBbscrxKGWnQKZ86CSbkc2C6p7fyghha8wp4XGJVoqtngQmUuo7vKDMBJ1LWjKyg1BWYkarX2PfQoVHr18s7P4wXLUFjAnqeihh1Mk9cc1oWQEiXJHnRENjXPWXm6U93A8jWMuW7xyFnLdyj83gFp7X7anexc2FECAMvQFA4L9bybfu6wLJ3ZveNVnqCfyPwW8ZXRF21J4f8Q2CPrN5XPSrBwZkBZNBkJsewoZjf1UJi1SCdKw2nhwq7cEbgKtXu94WvQroHQ7WBG9svzWjRHRXd6DKjKu4LaEuo5jxUmsSnvD3GbqbxPDg7bRy52ve5Dh4j8PPhBc6TraGWTtH7FFviMbZgxRFwNsXS8Qm4CwMsnhPFQgF1x2y9jfuMSHf99V858F""
}


const proof = TestProof.fromJSON(provable.proof);

// throws 'unreachable'
const isValid = await verify(proof, provable.verificationKey);
console.log('isValid', isValid);
```
",[]
425,"""Cannot start new transaction within another transaction"" after an attempt to produce txn using unknown to the network account",shimkiv,open,"#### Test Preconditions:
- `Account1` is known to the network (exists and pre-funded);
- `Account2` is not known by the network (no such account was created/imported).

#### Steps and Results:
- Deploy simple zkApp;
  - I've used this [one](https://github.com/o1-labs/e2e-state-zkapp/blob/develop/e2e-state-zkapp-sc/src/SquaredZkApp.ts)
- Then try to invoke `zkApp` method using `Account1` data as `owner's` or `feePayer's` PrivateKey, [example](https://github.com/o1-labs/e2e-state-zkapp/blob/develop/e2e-state-zkapp-ui/utils/ZkAppUtils.ts#L89)
  - All is good, txn created, proved, signed and sent.
-  Now try to invoke `zkApp` method using `Account2` data as `owner's` or `feePayer's` PrivateKey
    - You will get expected error like this:
      ```sh
      getAccount: Could not find account for public key B62qpH...
      ```
- After this point you will receive the following error message on any `zkApp` interaction attempt which involves txn creation:
  ```sh
  Error: Cannot start new transaction within another transaction
  ```","[('mitschabaude', ""thanks for creating this!! I'm sure it's missing a cleanup"")]"
424,prevent conflicting permission/updates in the same AccountUpdate,Trivo25,closed,"Currently, the protocol only allows us to attach one authorization kind (either proof, or sig) to the tx, but AccountUpdates could include multiple updates that are conflicting depending on their permissions.

For example, a zkApp account could try to update the appState (which requires a proof) and set the delegation (which requires a signature) within the same AccountUpdate - but signing an AccountUpdate will not allow an additional proof","[('mitschabaude', 'I think this is resolved right, with your permission checking PR landed?')]"
422,Expose VerificationKey structure/class to SnarkyJS for better typing,Trivo25,closed,"to discuss: currently the verificationKey returned by the ledger is of type `unknown`, in order to better work with it we should potentially consider adding a custom class and typing around it https://github.com/o1-labs/snarkyjs/blob/main/src/snarky.d.ts#L746

","[('Trivo25', 'export base58 string instead of structure ')]"
420, investigate invalid signatures for composed contracts,Trivo25,closed,"when signing the transaction of a callee contract, signature doesnt seem to be accepted","[('mitschabaude', 'Did we resolve this?'), ('Trivo25', ""No, I haven't had the time to investigate further ""), ('mitschabaude', ""Is this also the case if the signature is done inside the callee method? I'm not sure we're even trying to support doing it after the method call right now"")]"
415,Replace Safari-breaking RegExp with function,mitschabaude,closed,"It's in `removeJsonQuotes`: https://github.com/o1-labs/snarkyjs/blob/235dc35450132090414592225c0522874fe266d0/src/lib/fetch.ts#L577-L583

The task is to get rid of the ReqExp in there, or replace it with one that works in Safari.

Requirements:
Should remove the quotes from the keys of an arbitrary JSON object (but not quotes in string values)
Should handle any escaped quotes in string values. Can assume keys don't have escaped quotes.","[('shimkiv', '<img width=""2048"" alt=""image"" src=""https://user-images.githubusercontent.com/4096154/190239590-f51f1387-2c7b-4ba1-91c4-a9ead12a71b0.png"">\r\n')]"
414,Add WebKit support (once available) for E2E testing,shimkiv,closed,,"[('shimkiv', 'https://github.com/o1-labs/snarkyjs/issues/415'), ('shimkiv', 'Issue in another repo has been created.')]"
413,Fetch Account's `verificationKey`,shimkiv,closed,To let people do some logic around the fact if zkApp was already deployed.,[]
409,Add README-dev,mitschabaude,closed,,"[('barriebyron', 'this work is completed https://github.com/o1-labs/snarkyjs/blob/main/README-dev.md ')]"
408,Docusaurus initial design,jasongitmail,closed,,[]
407,Add initial E2E tests for SnarkyJS Web version,shimkiv,closed,"- Scaffolding;
- Exercise API in Web-Browser;
- CI support;
- Reporting.",[]
404,Dex: Token tests,bkase,closed,"Tests for Creating, Minting, Burning, Transferring, and Putting Preconditions/Assertions on Tokens","[('mitschabaude', 'Seems we can close this now!')]"
403,Dex: Happy path flow,bkase,closed,,[]
402,Dex: Internals continued,bkase,closed,"Dependencies tracked in other issues
* [x] #136 for reusing a smart contract for two different accounts
* [x] #363 for passing in a verification key to a method; and maybe for passing an account update without introducing another special case for method arguments
* [ ] #431 -- account update structure not working as expected
* [x] #429 -- return values to transaction block

This issue
* [x] properly prove that we're executing a callback with certain arguments, in the zkApp A (see definitions below). this should be doable by directly using composability for A calling C, getting the party of C and wiring it up to be a child of B. 
```
A - creates callback, passes it to B
B - gets callback, witnesses a superset of parties, does generic check on them
C - is called by the callback
```
",[]
401,Voting App: Add test for changing permissions mid-transaction,bkase,closed,,"[('Trivo25', 'implemented, see https://github.com/o1-labs/snarkyjs/pull/361/commits/7f9ea40a66c598dae2337a8e7b2803bf4bf97133\r\n\r\nI just noticed: when I finish implementing verifying local tx, this test might change slightly due to how tx will be verified in JS vs how they just go through now')]"
400,Voting app: Add verification key upgrading mid-transaction test,bkase,closed,,[]
397,Can multiple types of reducers be declared in the same zkApp?,Comdex,closed,"Or another way to ask is it possible to define multiple different types of sequence events in the same zkApp? (This should require a zkApp to have multiple sequence states?)

It should look like this:
```typescript
reducer = Experimental.Reducer({ actionType: Note });
reducer2 = Experimental.Reducer({ actionType: Field});
```

I know that we can use a composite CircuitValue to combine these types as a sequence event, but since snarkyjs does not support plain if statements, what I understand is that this can only handle relatively simple single data or relatively simple logic. For a sequence event with different types of data, you also need to use dummy data (Not all processing can use dummy data, and calculations that do not conform to the Circuit.if judgment also need to be side-effect-free). For example, it would be difficult for a zkApp that holds two or more different merkle roots to use the same sequence event to perform the update calculation of these roots.
","[('mitschabaude', ""no, not possible. as you said, to implement multiple types of actions, you can create an `actionType` that represents one of many actions at the same time. for example:\r\n\r\n```ts\r\nclass MyCompositeAction extends CircuitValue {\r\n  @prop note: Note;\r\n  @prop fields: Field;\r\n  @prop isNote: Bool\r\n}\r\n\r\nclass MyContract extends SmartContract {\r\n  reducer = Experimental.Reducer({ actionType: MyCompositeAction });\r\n}\r\n```\r\n\r\nyou then could have one `reduce` operation which ignores actions that have `isNote = true` and one which ignores ones with `isNote = false`\r\n\r\nyes, it can be tricky sometimes, but there's simply no other way""), ('Comdex', ""Ok, I get it, it's just that sometimes it's really tricky to implement ignore 🤦🏻""), ('mitschabaude', 'maybe this helps:\r\n```ts\r\n(state, action) => {\r\n  let { note, field, isNote } = action;\r\n  let stateForNewNote = reduceNote(state, note);\r\n  let stateForNewField = reduceField(state, field);\r\n  return Circuit.if(isNote, stateForNewNote, stateForNewField);\r\n}\r\n```'), ('Comdex', 'Thanks. In fact, the most troublesome thing is the handling of dummy data.')]"
396,Implement an ability to wait for transaction inclusion into the block,shimkiv,closed,`Mina.transaction().send().wait()` one.,[]
395,Implement the way to get sent transaction hash back,shimkiv,closed,"There is no way at the moment to get sent transaction hash using return data of the `Mina.transaction().send()` invocation. 
But we definitely will need a way to track just sent transactions execution.",[]
391,make local blockchain verify transaction proofs,Trivo25,closed,TODO: expose permissions of accounts to snarkyjs,"[('Trivo25', 'duplicate of https://github.com/o1-labs/snarkyjs/issues/150')]"
388,template doc comments for merkle tree,Trivo25,closed,,[]
385,Make `.js` imports work in Jest,mitschabaude,closed,"Relayed by @maht0rz

When trying to integrate a `zk` project into create-react-app, it won't resolve imports successfully unless we change imports in our (TS) contract to use an ESM style import:
```ts
import ... from ""./relative/path.js""
```
Note that it needs the `.js` ending, even though it is a TS file. This is expected and seems to be how TS-ESM integration works.

This needs to be changed in our examples. Also, we need to find a strategy so that Jest can still import files with this syntax, because currently, adding the `.js` extensions breaks the Jest tests.

Maybe the solution is to, like in snarkyjs, import contracts into Jest tests from the JS build output instead of from the TS source files","[('mitschabaude', 'this should have been an issue on https://github.com/o1-labs/zkapp-cli'), ('mitschabaude', 'User reporting they have to add the `.js` import even before doing deploy: https://discord.com/channels/484437221055922177/1052978946645426176/1052978946645426176\n')]"
384,finish voting application integration testing,Trivo25,closed,,[]
383,Add docs for CircuitValue ,jasongitmail,closed,https://docs.minaprotocol.com/en/zkapps/how-to-write-a-zkapp,"[('MartinMinkov', 'PR here: https://github.com/MinaProtocol/docs/pull/220'), ('MartinMinkov', 'Done in the PR mentioned above ^^')]"
382,Add Merkle tree docs to Advanced SnarkyJS section of the zkApp docs,jasongitmail,closed,https://docs.minaprotocol.com/en/zkapps,[]
381,"Document tx construction, account updates, compiling, proving and signing",jasongitmail,closed,,"[('mitschabaude', 'In my judgement, this is the most important open doc issue we have currently, and I want to pursue it before testnet launch.\r\n\r\nHere\'s a proposal:\r\n* We add a new section, maybe titled ""Transactions, account updates and proofs"", at the bottom of ""How to write a zkApp""\r\n* We give succinct descriptions of what transactions and account updates are in Mina/snarkyjs\r\n* We introduce the `Mina.transaction` API, in generality -- i.e. without reference to any specific flow like ""interacting with Auro wallet via Mina provider"" or ""running a unit test with Jest"". (These specialized use cases should live in later sections IMO.)\r\n* We explain how account updates are typically created under the hood by more high-level methods, and we give a concrete example: creating a payment with the `send` API\r\n* We explain how calling a zkApp creates an account update under the hood (which needs a proof for authorization)\r\n* We show how to use the `Mina.transaction` output to create a proof, and how you have to compile the SmartContract first\r\n* We hint at how the finished transaction would be used in a web app -- passed to the wallet via Mina provider and signed there. (When it exists, we would link to the Mina provider docs here.) We also explain how a transaction can be signed and sent with snarkyjs alone (hint at use cases: testing, server-side/automated interaction with Mina)\r\n\r\nI think the existing testing section https://docs.minaprotocol.com/en/zkapps/how-to-test-a-zkapp can just stay as it is without change. It actually reads a bit as if `Mina.transaction` was introduced earlier already, and doesn\'t have anything that feels redundant to me if the proposed new section were added'), ('mitschabaude', 'Further thing that came up:\nwe should document how to fetch accounts and explain the caching that we do in some places. `Mina.fetchAccount` vs `Mina.getAccount`, `zkApp.x.fetch()` maybe'), ('mitschabaude', 'More stuff that came up: it should be documented that the transaction code runs multiple times, so using mutated global state as method inputs is not supported')]"
380,Make branch where hard-coded circuit size limit is changed,mitschabaude,closed,"This would be in support of anyone who needs to use snarkyjs with a bigger circuit than currently supported

Impact: This is currently blocking an implementation of SHA-256, which is a highly valuable experiment with snarkyjs, cc @xhliu @zhfnjust 
https://github.com/o1-labs/snarkyjs/issues/328

The issue refers to non-pickles circuits, which don't get deployed to Mina, for which there is no size limit imposed by verifier circuits on the network! It seems that there shouldn't be any fundamental issue preventing us from making these circuits as large as necessary.

This issue entails just changing any hard-coded values in both the OCaml & Rust code to change the size limits, so that interested people can work with larger circuits, and making a branch with modified snarkyjs bindings which make that change accessible

This would be _a first step_ in the direction of making the size limit for plain (non-Pickles) circuits configurable in snarkyjs

Here is one known place where the size of the domain (lagrange basis) is hard-coded to 2^16, which currently affects snarkyjs:
https://github.com/MinaProtocol/mina/blob/48b44c16bcc704efb7c67fdfdcf4a14d3877e4da/src/lib/crypto/kimchi_backend/pasta/basic.ml#L17

From first experiments by @Trivo25, it seems that changing the limit is more involved than just changing this value","[('xhliu', 'Code is here https://github.com/sCrypt-Inc/snarkyjs-sha256'), ('haoustc', '我们也在开发相关功能，请问这个限制什么时候可以去掉呢？热烈期盼中。'), ('haoustc', 'we are also doing some development in sha256 circuit, when will the limit be removed? expecting.'), ('mitschabaude', ""This branch exists now: https://github.com/o1-labs/snarkyjs/pull/496\r\n\r\nHowever, when trying doubling hashing from the [snarkyjs-sha256](https://github.com/sCrypt-Inc/snarkyjs-sha256) repo, the prover runs into an out-of-memory error, apparently hitting the hard 4GB limit on the Wasm memory size.\r\n![image](https://user-images.githubusercontent.com/20989968/196783696-70d30afd-3481-4dc9-b305-1694914894e1.png)\r\n\r\nI'm closing this and will raise the issue of high memory consumption with our crypto team, but this is likely not something that can be fixed in the near term.\r\n"")]"
379,Fix web version (infinite loop),mitschabaude,closed,"The web version of snarkyjs is reported to go into an infinite loop when compiling, cc @maht0rz @jackryanservia 

one difference to node is that for web, there's some manually written ""table"" of functions that are run from workers. if that table got out of date, we had the web version break sometimes
here:  https://github.com/o1-labs/snarkyjs/blob/main/src/chrome_bindings/worker_run.js
","[('maht0rz', ""Are there any pointers as to how this can be fixed? I'd like to help\r\n""), ('mitschabaude', 'I see two possible strategies for fixing:\r\n\r\n1. Look at the recent history of the file bindings.js in the Mina repo, to see if functions where added / changed that got out of date with that function table mentioned above. Try to fix by updating the table\r\n2. Try to figure out where the infinite loop happens. I usually do that with ""log bisection"". That probably requires to build snarkyjs from source and put print_endline statements in ocaml code (e.g. snarky_js_bindings_lib.ml in the Mina repo). Snarkyjs is built by running \'make snarkyjs\' from the Mina repo '), ('maht0rz', ""@mitschabaude is this the file you've mentioned above? I'll try comparing it manually\r\nhttps://github.com/MinaProtocol/mina/blob/develop/src/lib/crypto/kimchi_bindings/js/bindings.js""), ('mitschabaude', ""> @mitschabaude is this the file you've mentioned above? I'll try comparing it manually https://github.com/MinaProtocol/mina/blob/develop/src/lib/crypto/kimchi_bindings/js/bindings.js\r\n\r\nYes, @maht0rz, this is it! That file is huge so I recommend looking at its recent git history for guessing relevant changes.""), ('maht0rz', ""Thanks to @gregor#5446's instructions i've noticed a discrepancy in the web/chrome bindings, introduced in the following commit: https://github.com/MinaProtocol/mina/commit/99dc99ea479ab2b22eb3a5568757c3f62e3f22b4#diff-c2c0ff175c607b726ab7857e08ab0d7389d6c6f2b2fb1039583a0505c47b28e9R1217\r\n\r\nSeems to me like `caml_pasta_fp_plonk_index_create` now also accepts a new argument `prev_challenges`, but this isn't reflected in [`worker_run.js`](https://github.com/o1-labs/snarkyjs/blob/main/src/chrome_bindings/worker_run.js#L19)\r\n\r\nAttempting to fix 🎢 ""), ('maht0rz', ""Here are two profiler outputs from firefox, [before the fix](https://profiler.firefox.com/public/w0gg6xzvbjb33g08wxwfsnhe4pcqzb9kgec3dt8/calltree/?globalTrackOrder=01&implementation=js&thread=1&v=7) and [after the attempted fix](https://profiler.firefox.com/public/0j404c8bppdz7sqjp3arwgrypp93wre5g3mbxg8/calltree/?globalTrackOrder=01&implementation=js&thread=1&v=7).\r\n\r\nI've added `undefined` since i was not able to find a coresponding WASM-ish value in the `plonk_wasm` argument.\r\n```\r\ncaml_pasta_fp_plonk_index_create: {\r\n        args: [\r\n          plonk_wasm.WasmFpGateVector,\r\n          undefined /* number */,\r\n          undefined, // this is what i've added\r\n          plonk_wasm.WasmFpSrs,\r\n        ],\r\n        res: plonk_wasm.WasmPastaFpPlonkIndex,\r\n      },\r\n ```\r\n \r\n You can see the stack trace / calls changing after i've added the extra argument in the binding but i am still unable to compile my contract. \r\n      \r\n       ""), ('mitschabaude', 'awesome! `undefined` seems to be fine because `prev_challenges` is an integer. I think you just need to fix `caml_pasta_fq_plonk_index_create` in addition to `caml_pasta_fp_plonk_index_create` (note: `fq` vs `fp`)'), ('maht0rz', 'It works, i will issue a PR right now! :)\r\n')]"
378,Make snarkyjs run inside a web worker,mitschabaude,closed,"This refers to enabling user-land code to run snarkyjs in a web worker, in its entirety

A separate task that would be even more valuable, but more involved & not in scope for this issue, is to run the performance-intensive parts of snarkyjs (compile, prove) in a web worker automatically, but maintain the normal interface to interact with snarkyjs from the main thread.","[('mitschabaude', 'cc @jackryanservia @maht0rz')]"
375,"DEX zkApp, initial implementation",mitschabaude,closed,"doesn't include adding test cases beyond ""it runs the happy path""

does include:
* [x] witnessing arbitrary parties layouts",[]
373,Fix simple zkapp example,mitschabaude,closed,,[]
369,Move recursion under experimental,jasongitmail,closed,,[]
364,Fix Jest tests in CI,mitschabaude,closed,,[]
363,Generalize method arguments to allow auxiliary data,mitschabaude,closed,,[]
362,Docs homepage development,jasongitmail,closed,,[]
359,reducer cannot be used in composed contracts,Trivo25,open,"`reducer.reduce` cannot be used within a contract that has been called by a caller contract

`Error: Can not analyze methods inside Circuit.runAndCheck, because this creates a circuit nested in another circuit`

MRE

```ts
class ReducerContract extends SmartContract {
  reducer = Experimental.Reducer({ actionType: Field });

  @method reduceEvents(): Field {

    let { state: s, actionsHash: a } = this.reducer.reduce(
      [[Field.zero]],
      Field,
      (state: Field, _action: Field) => {
        return _action;
      },
      // initial state
      { state: Field.zero, actionsHash: Field.zero }
    );
    return Field.zero;
  }
}

class Caller extends SmartContract {
  @state(Field) sum = State<Field>();
  events = { sum: Field };

  @method callAddAndEmit() {
    let c = new ReducerContract(adderAddress);
    let sum = c.reduceEvents();
  }
}

// ...

tx = await Mina.transaction(feePayer, () => {
  zkapp.callAddAndEmit();
});
```

https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L685

# Temporary fix to unblock integration tests
- [x] pass in dummy values instead of invoking the function that causes the issue https://github.com/o1-labs/snarkyjs/blob/feature%2Fvoting-contract/src/lib/zkapp.ts#L769

# TODO
- [x] remove dummy values
- [x] temporary fix: call `.compile`

# Update

`analyzeMethods` behaves weirdly sometimes, it would be nice to analyze all contracts that are part of a tx in advance, but is out of scope for now","[('Trivo25', 'This only appears when compile *was not* invoked. Solution: Make sure `analyzeMethod` is being invoked anyway '), ('mitschabaude', ""Yeah that'd be the solution!"")]"
355,`reducer.reduce` calculates an incorrect sequence hash for composite data types,Trivo25,closed,"`reducer.reduce` seems to calculate an incorrect sequence hash for composite data types like custom `CircuitValue` or `PublicKey` which store more than one Field element. the incorrect sequence event results in an unsatisfied account preconditions 

MRE:

```ts
class Sum extends CircuitValue {
  @prop a: Field;
  @prop b: Field;
  constructor() {
    super();
    this.a = Field.one;
    this.b = Field.one;
  }
}

let INCREMENT = new Sum();

class SumApp extends SmartContract {
  reducer = Experimental.Reducer({ actionType: Sum });

  @state(Field) counter = State<Field>();
  @state(Field) actionsHash = State<Field>();

  @method incrementCounter() {
    this.reducer.dispatch(INCREMENT);
  }

  @method rollupIncrements() {
    let counter = this.counter.get();
    this.counter.assertEquals(counter);
    let actionsHash = this.actionsHash.get();
    this.actionsHash.assertEquals(actionsHash);

    let { state: newCounter, actionsHash: newActionsHash } =
      this.reducer.reduce(
        pendingActions,
        Field,
        (state: Field, _action: Sum) => {
          return state.add(1);
        },
        { state: counter, actionsHash }
      );

    this.counter.set(newCounter);
    this.actionsHash.set(newActionsHash);
  }
}

const initialCounter = Field.zero;

let pendingActions: any = [];

let Local = Mina.LocalBlockchain();
Mina.setActiveInstance(Local);

let feePayer = Local.testAccounts[0].privateKey;

// the zkapp account
let zkappKey = PrivateKey.random();
let zkappAddress = zkappKey.toPublicKey();

let zkapp = new SumApp(zkappAddress);

console.log('deploy');
let tx = await Mina.transaction(feePayer, () => {
  Party.fundNewAccount(feePayer);
  zkapp.deploy({ zkappKey });

  zkapp.setPermissions({
    ...Permissions.default(),
    editState: Permissions.proofOrSignature(),
    editSequenceState: Permissions.proofOrSignature(),
  });

  zkapp.counter.set(initialCounter);
  zkapp.actionsHash.set(Experimental.Reducer.initialActionsHash);
});
tx.send();

console.log('action 1');
tx = await Mina.transaction(feePayer, () => {
  zkapp.incrementCounter();
  zkapp.sign(zkappKey);
});
tx.send();
pendingActions.push(INCREMENT.toFields());

console.log('rollup transaction');
tx = await Mina.transaction(feePayer, () => {
  zkapp.rollupIncrements();
  zkapp.sign(zkappKey);
});
tx.send();
```

```ts
Error: [[[""Account_sequence_state_precondition_unsatisfied""]],[]]
```

this assertion seems to fail https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L826

As described in Slack, the following condition always evaluates to false if the action type has more than one Field element, resulting in the reducer to always process empty actions, even though the actual actions are not empty
<https://github.com/o1-labs/snarkyjs/blob/main/src/lib/zkapp.ts#L792>

`length === n ? actions : emptyValue(type)`



## Temporary fix to unblock integration tests
- [x] removing the assertion that fails until the reducer has been fixed

## TODO
- [x] add assertion back after fixing reducer
",[]
354,Do we have to compile the circuit before verifying the serialized proof,zhfnjust,closed,"

The following code can be verified normally, but if I comment out this line of code ` await MyProgram.compile();`, it will report an error：


```
import { SelfProof, Field, ZkProgram, verify, isReady, shutdown } from 'snarkyjs';

await isReady;
let MyProgram = ZkProgram({
  publicInput: Field,

  methods: {
    baseCase: {
      privateInputs: [],

      method(publicInput: Field) {
        publicInput.assertEquals(Field.zero);
      },
    },

    inductiveCase: {
      privateInputs: [SelfProof],

      method(publicInput: Field, earlierProof: SelfProof<Field>) {
        earlierProof.verify();
        earlierProof.publicInput.add(1).assertEquals(publicInput);
      },
    },
  },
});

let MyProof = ZkProgram.Proof(MyProgram);

console.log('program digest', MyProgram.digest());

// console.log('compiling MyProgram...');
await (async () => {
  // If you comment this line, `verify` return false
  await MyProgram.compile();
})()


const verificationKey = `DxeDLTrpGY1GU75BSh4xnzzmg65feCHPpbfeX8V3Z63FE9PcgbU7ci4NviK6LRFdt9hUG9MV7sLkZx43rWMmzeeaHbZdApUa9Sr77QVkkJLJXfeSiGUnJJs7vQadDHij2f5T2zR2DjFoKsKSEnvTcqtPhCf9ssHfrzGDSvrCWhTnrdLSrGsQcNofrP4JEpxWbJWFQspi4T9cRPG1wWtMMTEm3qRTaomco1Zw6PZxkP38u9rXGDbafxNC5gfK9eBfS3GBt6fXkEDRdFApPxK9wEuad5aPEAGwR8XvAqXtouBjzcRXQPNwvmRQ7pajhj4bkvNKn35MtggrZainrbZetxpVH4kyKgjccC1En65ATNKnJhrrcFkCC46eVjfgqG3nS5n5pLDmV3btDMZS7EQ8QvbaNBRZAUK3JgKbBr3ZcjCX49uT3Bmm2ei5XTRgXic5JvyPb39caAFduLTdEvHfqc95hUfyPHAuXWer7wESCYVEupan8kPd9i8Y8SuvpK7GSBLUFKPKXAb1H2qL45e5RTUVzvMQ3AAw9ECv3krdMkcbVYBZopqLmxp8iL3KXdNpiMi4w6rzGyiqGT5K3gNdMqbuFMNUV9QgP1bnsSzhrDHDtkhj8HfJtX62SHgDE4UiLg4Rw9UxDRV9LjbLd9Hyy3j6Doj7BSTMpYqKReqRN9Y7rz1C6B2pXondu5KppEXhJt9rDXbtWoFjeZsMPAR79t9B1xij3U2dwv8MYtx8SZ3jZihp2wCJXNDkmz15Jo8w85dpnjJBw9u84Lw2kaSYHGrRTH7u7vTM11tVgwWRfAhibgmeci6jGFqq5kX4q7HWJMvf99tUwpdfQMsKyEn7cDtdyubRCjkChnUdNYt7XVMg8yNjagTuq4SF8SJeYCYJAg5zUypm2FwmqEVWequPD7u5qhq9v9SmvArZgtjvqDdv9XaubTzrjZ35iwYCMMvzFZhANMUThzpDSXbsVT1iSxzxgAQsbyKZYRE3wRtMbQ4p4smcX4ksTucAZwhbfiTHPWTuz8eHNH42wsy19vsCt8XuXTCiPGM6tEtaxV4BvWGkjJiQTrWdxaaN49bDnUDsqnrc3Z3HBMK1cEy1uZzZo47a3Ui1s7uj22T5mpffaUDVLqEVbtGhLLZ6ougckMVR5qMs3XJDgfrXRnyTzoXU6UiUBX2bn4TK9UgcR2Vy6Po2EodFTYSh5bmKkaL3Heo5vRfZK5RQWjY6r8WtyGzA9fUdZkfJ5hZ8a4oZ8yRdnCS2M495XbVD3Egt9CtCUMJsLgxS7gXbmWJ5n7pX7e6hjQ8GvNYkKbJ2t1QLFmSgorzaDoUhfJXrmwt8KHA6HFqMKsUcjyKTBtwB3bEHk5HtEuq7gNkX73azDEYuWFHroomkD3p57PHzJE81KQNBTNAwXYE8hV4VhzJefHo7vZH3ub3y5DtuR5VyzGqGdrnadTAxDHQp8ha5SLZ8wuWLwoDE9viXCjRQH6UokZd9DfGDYhoqL7m1v1haixx2eCTzYtUBRLH8QWy3ap965w66TMgVzvzUFjTycZEMjWrcGcSDSQKzkx6PTjSk335Pdu8D2d3wELWwUaoVU7N6hWv2KhoXBqpeX7EcQtMxnrJbN54c9r8Y3KgvoVCRULNFKoXri87EkB9idNjYUebJKVzcMDDUeUUkLp8HKcc92YmkCXEBXD6xfiLF94WQjVEAqCn1EqcaTpqmszcbGznFSfypH5MndKtvBkR8rQKnJanmdzxVi7b67oA9Gs6E3vfDMZF3P9CEQFc2BvGNFoC8gGDSt6vaD3F98Utv22STHzSc6Tdc2k3rpsySkSGaay1tEVvgmWCWxJiPsUXEhjXQn48unBNf4SRFhLaFFpWeAcZ5HUoPyfw3b8fiJkVeDYq486CXUKj7QddsRV8jQvcQUir7hwR868J2jj96mFvpezbVbT1fgxBDLfRemdMd8QKXkquVygKGxoxa1bsLTmeyM2FjVtX8iwHM9mqjZi41M9qQ1bsgTn6ttwyXboRemRCCLxsyDMRFStstKWvwZXGUDpk8Xd5uCRyCgkV3PXg6eV6SZr1BYw9KSVto97GnZzYNa8iRF5JRmchzz6TNSge7MeNo4mgQPEuQ3VntNXon4b6LU9qMvo4RPdSivRR83xaeTqZm7izD3XwRHHtB3fcAKjdxeVJCkArqBqg9N1QaHNyHSumnENrGUuXVKtQWvAn6G62xCfGAEZabkWHujLwxNNEPx2JX2Ey1YUbKLvzdsdUbaxMLNQTwHkvRUdtAmEJkkq8BazKRrULWvqWuRBMvaBAHMTZzYVMFr2SPAe4BQsffpMygk9oSvvsGy1SDN97M1woMVgzpqwV1MNfuDHkZZo8sAUSAgMqzfExqSZ5XbN8N82TdVHzQBJSnKoFa855HRJvyKPwghMBcqHGYHUXooxRSx8HNiBwo8EGmJS5XaVeySHUiLE4yuu`

let proof: any = {
  publicInput: [
    ""0""
  ],
  maxProofsVerified: 1,
  proof: ""KChzdGF0ZW1lbnQoKHByb29mX3N0YXRlKChkZWZlcnJlZF92YWx1ZXMoKHBsb25rKChhbHBoYSgoaW5uZXIoZGEzODE4YTU2OWVhMjI2MSBmMTg3NDYyY2EzNGFhYzEzKSkpKShiZXRhKGZjODI2M2VmYjg3NGFmZjYgZGE3YjllMDY5NDA0ODgxMikpKGdhbW1hKDAwODMxMThlYTM2MTAzYjQgOGU2MTc2MzRmOWY3MzE4OSkpKHpldGEoKGlubmVyKDdhNDVlZTNmMTljNTQ1ZTYgZTUzNzRhNWM2MGE3MmNkMikpKSkoam9pbnRfY29tYmluZXIoKSkpKShjb21iaW5lZF9pbm5lcl9wcm9kdWN0KFNoaWZ0ZWRfdmFsdWUgMHgyQzAzN0UxODg3NUMwRjRDOEQzREE1RUJCODBGNjFGMjU2QTY0NTg5MjYxOTc5RUVFODQ5NzU2OUM5NjI3NDBEKSkoYihTaGlmdGVkX3ZhbHVlIDB4MDA1MDAzQUZFMjJCN0Q1N0FDMjFCOTUxMDlBQTQxMUZCNTJDMzBEODY0N0E5QTY3MTNFRUUxMUEyODkwODFFNSkpKHhpKChpbm5lcihhNmM2ZjFkNzFhMjUxM2Q3IDcxYTM2Yjg1ZjliZTA4MDcpKSkpKGJ1bGxldHByb29mX2NoYWxsZW5nZXMoKChwcmVjaGFsbGVuZ2UoKGlubmVyKGZlNDgzMTJlNzJiNmU5NDAgZTUzMzQ5ZDRkMWFkMTUxMSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDY0OTU0Y2E3OTIzOTdmZTAgNmQ0MzBhM2MzODgzYzE2MCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDQ1OGZhN2M1OGY4YTE0ZTggOGUwZWQxMjNmM2M5YWExYikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDE1ODFiMTVlMTVlMzUzNTYgYWZkMjJlZWRjMDBjOTM2ZSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGU1ZmQ3MzliMTUyMzMzYjIgNzQ4NmVmYWQ2NjkzNDZmNykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDcwN2ZiZTdkZjg5ZTk1MWUgNjYyMWU5MWU3ZDA1ZGYxNikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDE1NGNhZjQxNzM1M2NiZDcgY2I1ZmJkYzYzMmUxNDNmZCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDc3ZTUzYmIxMTJmYTgyNDIgM2NkN2UxMWQ4YjlkYzQyMSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDU4NDExNTI0NjIxNGRkNmIgNTE5OTNlYTBmZDU0M2RiZCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGJjMzIzNWZmZTlkNmVhMTkgNzI4ZWVlYWUwODlkZTVmYSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDg2NjM2YWY1NDBjYTZkYjkgNjIyNjgzMTE0YzZmM2EwNCkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGUyNzcyNmM2ZmMwN2M3YTkgODVkYTEyMWUzMjdjNDk2NykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDk4MWQ2NjYwMzk5ZDc1ZjIgZDQ0MjI5YWJiMTkzOGRlYykpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDRjM2U5MzYyNDdhMDllZjIgNjZiN2M2NzkyMzhlMTQ1NikpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKGM5ZWJkOTllY2I4NzVlYjggMTlkZmU3MDUzNmJmM2YwNSkpKSkpKChwcmVjaGFsbGVuZ2UoKGlubmVyKDYzNDNkYjI4ZjlmZDI0MDQgMzdkOWVmNjE5MDBlOWRlZikpKSkpKSkoYnJhbmNoX2RhdGEoKHByb29mc192ZXJpZmllZCBOMCkoZG9tYWluX2xvZzIiXG4iKSkpKSkoc3BvbmdlX2RpZ2VzdF9iZWZvcmVfZXZhbHVhdGlvbnMoMTNjNzRmNzg0NTM0MWY1NCA2OTBlZmU4Y2I4ODI3MDNlIGQxNzMzY2NiYmNiYjBmODQgMzQ1NDhjODI3OWNkMDM2MykpKG1lc3NhZ2VzX2Zvcl9uZXh0X3dyYXBfcHJvb2YoKGNoYWxsZW5nZV9wb2x5bm9taWFsX2NvbW1pdG1lbnQoMHgxQjREQURDQzVFMDZEQjRDOEIyRDkzRjY1MjdFRTZEOEVGQUY4NTMzRTI1MjBFQkM3MkRBMkU4MjM3QUY3QTFDIDB4MzlBNjZCMUYwMjExMUU3MTRENTVBRTM5MEQwMTE4RDkxQTJFNEMxNUZGNzY1RTcyM0Q1ODIzMUM4QTdGN0JDRikpKG9sZF9idWxsZXRwcm9vZl9jaGFsbGVuZ2VzKCgoKHByZWNoYWxsZW5nZSgoaW5uZXIoMzM4MmIzYzlhY2U2YmY2ZiA3OTk3NDM1OGY5NzYxODYzKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoZGQzYTJiMDZlOTg4ODc5NyBkZDdhZTY0MDI5NDRhMWM3KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoYzZlOGU1MzBmNDljOWZjYiAwN2RkYmI2NWNkYTA5Y2RkKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNTMyYzU5YTI4NzY5MWExMyBhOTIxYmNiMDJhNjU2ZjdiKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoZTI5Yzc3YjE4ZjEwMDc4YiBmODVjNWYwMGRmNmIwY2VlKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMWRiZGE3MmQwN2IwOWM4NyA0ZDFiOTdlMmU5NWYyNmEwKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOWM3NTc0N2M1NjgwNWYxMSBhMWZlNjM2OWZhY2VmMWU4KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNWMyYjhhZGZkYmU5NjA0ZCA1YThjNzE4Y2YyMTBmNzliKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMjJjMGIzNWM1MWUwNmI0OCBhNjg4OGI3MzQwYTk2ZGVkKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOTAwN2Q3YjU1ZTc2NjQ2ZSBjMWM2OGIzOWRiNGU4ZTEyKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNDQ0NWUzNWUzNzNmMmJjOSA5ZDQwYzcxNWZjOGNjZGU1KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNDI5ODgyODQ0YmJjYWE0ZSA5N2E5MjdkN2QwYWZiN2JjKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoOTljYTNkNWJmZmZkNmU3NyBlZmU2NmE1NTE1NWM0Mjk0KSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoNGI3ZGIyNzEyMTk3OTk1NCA5NTFmYTJlMDYxOTNjODQwKSkpKSkoKHByZWNoYWxsZW5nZSgoaW5uZXIoMmNkMWNjYmViMjA3NDdiMyA1YmQxZGUzY2YyNjQwMjFkKSkpKSkpKSkpKSkpKG1lc3NhZ2VzX2Zvcl9uZXh0X3N0ZXBfcHJvb2YoKGFwcF9zdGF0ZSgpKShjaGFsbGVuZ2VfcG9seW5vbWlhbF9jb21taXRtZW50cygpKShvbGRfYnVsbGV0cHJvb2ZfY2hhbGxlbmdlcygpKSkpKSkocHJldl9ldmFscygoZXZhbHMoKHB1YmxpY19pbnB1dCgweDIwNTgyMUMwQTU4NTQzNzhBQUQ0MzlBNzQzRTQ4MTI3RjQ1NENCNTk3RDM3Q0Q1Q0U5NkIyOURBRTgxOUI5RjAgMHgzMDZBOTIwMjY4NTJGOUJCRjEyQ0ZFNURBQTZCNzNGNEYyNTc3MTYyN0UwNUFDRjE1MjFFRTA0MDJEMUY0NjRFKSkoZXZhbHMoKHcoKCgweDI2NERFRjkyN0NENUQ0Nzk3QjhEQjVGMzE4QTFDNUVDMTY3MDY1QzEwQ0ExOTRCODExQjc2N0U1NTdDOThBRjMpKDB4MDMwNzgwNUVFQjA2MTFCRDkwQkUwRDQ3QUY3ODJCMTA1NTUwNTg0NzM1MkVCMUM3QjFEMkZCNUY5Mjk3MzBGRikpKCgweDExRUZFNDEzNzc1RDk2MTYwMzA5NzNEMkI0RDJDQTE1ODlDOEI1OTVEMjFDOTBBODA0RUZCOUZEMDFGOTc4RkQpKDB4MzEwMUJCNUYwMjEzREU1NjQxNzM3MjMzOEQxQUFGNkJDRkFFQzMwNDhERjM3NkY2NEY4OTAwQjZEMkMzQkEzMykpKCgweDA4MzJBQzg5QUM4ODhFMkIzQ0ZCMjdBMDJENTJCNzlFMzMzOTE4QkRCMzExMTQxNUM4NjVBMEFBRjE4ODJEMzApKDB4MzQxRjQyMDlGMkY3RjU4Q0NERjQ3QUM2OEU5Nzg5NjY2QjVGMjlDNEE0REEwQTUzREVFQTYwMEQ5MTM1ODI1MSkpKCgweDM5RjlCQUE4N0E1NkQxNDFBMTBEMjVCMDJEMkQwNTU3QUVENTJCMTk2MDYyNDFCODQ0Njg0NEMzNzUxMEZFRDIpKDB4MDYzMEJDMDQ1RTdDNjI4OUIwMkU5MEU2QkNEMzkxMUQ3RDBFODdFQzgwNDk3M0U4ODk0ODJCNjJDMEU0RUU2MCkpKCgweDM0RDU2QzZENTFFNDRENDA4Qjk3MDlFMTYwQkREMkRBRjI2RDlFQzlCNkMwQ0I1RDVDQkE1QjMxRkE0QzU0RTQpKDB4MzBFMUVGNDIyNzRBNzA1QjlEOUY1ODc4NkZGQTQyQUFERkQ3MEVCMEI2MDNDN0M2MDg1NzdEQUUzMkVBNkNBRikpKCgweDJEQUE4MDI2MUJCQzMzRkQ2RjU3ODU5QTczNkI2OENDQTcxNTM4NkMyRjg4NjQxQjkxNTE4NzlCRDc2Mzg5QTkpKDB4MTYyQkUwNTkwNjE4MTk1MTBDNkJGOEM0RDMzRjczNUE2NUQ2QUMxNTkyNkM1MDMwQkZEM0UxOTA5RkJGMTI3OCkpKCgweDIyRkMxNTI1MjREQzBENEZBN0Q0NEU2Nzc3RDEwQzM0MkNBQTYwMzczRjhBOURGNzlCOEYwNzU2QjUyQUJEOUYpKDB4MUU2QTk4OUM3MDIyQ0I4RkE5Q0NERjVFNDVFMUYyMEQwRjgwMDRBNkNERDU5MThCMjNFNDBERTJFMURBMzgyOCkpKCgweDNFRDVFQkJCMTlBRDU5RTEyMUU0RTQ0MDg2MzA4M0FBNkMzMzY2NEZEODM3RkRFRjNEMkRBNDVERTM5NEI1ODcpKDB4M0Y0QjRDQkI4OTkxQzQ1NUY2RkM4Q0FGMDdFQjMwNDY5RTVDM0JFNEIyMEI2NDQyRjc1Q0JENkIzM0Y3MjY3RCkpKCgweDFGMTQwRDVDNzZDMEQ3RDE2NjE1RTcyQjEyNzA1RTIyN0QxRjU3MUE1M0U3Nzg0QjQ1MTlFQUQwQjk5RDQ1NzUpKDB4MTQyNTgyQ0MxNjkxQzU5MUZEODlBOEQzMzY1NjU2RUE5RUQxQkZFQjdGNkY0OEIyMzVFMDU0NjU1RURERTgzRSkpKCgweDI3NzZCMjY0NDk3QzQ1OUFFQ0Q4MDRBNjY3MTVDOUU2RDNGQjJBRDRENzlCMTgyMkMzMjI5Q0FDMUNCNzE3ODApKDB4MEEyMjc0MjM4QUVDQzk2NDJEQUY5ODQ1Q0E4NkMyQ0NDQTU4NjNBRUMyNEQ2REZGNjE5RDQ3RDlBNjNCMDQ3NykpKCgweDBGOTRCMEIxNUE4NjRGMTQ1MzRCNjY2QTRDNkY5MzUyQjFBRkFFMDM1OEY0OENBQjM3N0Q3M0I4NDUyQzBDMzIpKDB4MkI0NzUwRkYxMjVFNjFCMDg1Q0U3MjJGMkQwMzUxRUFBMTE5RkU4NzM5RkUyMzU5Nzk3RTM2RkFFNzA0RDkyMSkpKCgweDExQ0E2RUJFMjNDOEQ5NzY4MTJEQjhENzY3NzRBNUNGRjM5QjAyNTk3MEZCNjEwN0I5RTcwNUM5RjNFMEYzRDkpKDB4MkJGMjdBNDBCOTc1RTgwMEVFNDU4MEUyRDYyQThDQzkzMUJFMDE0RDQwNkFCNTBBMzMzMDMxMDBBMTZDMDEwMikpKCgweDFDNjc3MDBBM0YyNjE5QUM4MDIwNDgzMkZGRThEQTg0OEJFMEE0Q0NBMjRCQkU1MDMyOUYxQzA2NjI2ODI3OUMpKDB4Mzc5NDYzNkZFRjIyREVCMDczN0VFQUI2RkI4MDBCOUUyMzEwMTA2QzAzMDA0QTY5NjJDMDE3OEVGM0JBNDFGNSkpKCgweDIwRTIwNDY2Nzc5Q0RCN0VGRUQ2QzBBMjVBMUU5MjJFRjdGM0IwMjlCMDRGMjIwMDk0RkFDOTEzM0JENDEzRUIpKDB4MDkxRTkyMTMxMEY3NUEwMUMzNjRDMzA5NUJEOTJCQTI4MjlDOThBQkQ1MTY0NUIwMDVGNDBCMDdGNEIyQkFERSkpKCgweDBDQjI1Qjk1NzI3QkVDNkJCMjc5QTM0MDYwQUQ2MjdDMzU2NzU2QTM2ODBCMzlBQzk5Q0IzNTNCNzU2NTgxMTMpKDB4MkQ3RTY0QUZEODIxQjlFNTc4MTYyQjU5NTFDNTVGQ0IwMTFCRUFGMkNBOTIzRUExRTM0NTk4RjAyRTQzQ0FBMykpKSkoeigoMHgyNUU1Qjg0OThCQThBQkFDNTFCNUFFRjI1NDQ2NEU5NzMwNEFFREUyRjJENzAzNTNFNjY1MkNBQ0M2MTExRTIxKSgweDMzNzQxQjBCM0RGREFCRjdBMzIyRUMwQUM1MkEwNkUzNEE2NDE2OTEwMzU2MjZDNDQ5RERCRDNDRDE2QUY0MzEpKSkocygoKDB4MDUzNjFEMzdCMTY5RTY0NERFREExMTQyN0UxRUZFMTU2NEIwNzA2OUIzMjVGQTAzQjhFQzIwODEwQ0VFRTU4NCkoMHgzQzNFRjYyQ0FDRDMyN0UxNDRENTg5QUJGQTIyMUVENDNGRDkyQzMyNTFFMDc1MjJDNzhCOUZBQUQxNTc4MjEzKSkoKDB4MTc4RDQzNTY3OUJERTBBNkQzNzc5NDA4RUNGMTlGMkQ5NTI2QUYyQUU0NkU4NzFGMDZEMzdFNzlBNDdEMTE1NykoMHgwNUExODNDNTYxNTg4NUY2N0RDNDNEMDU2RDA1QUE2OTI1QjZCOTA1NzY3ODBBNUZCMDJGM0ZBMDExRDdBREY2KSkoKDB4MjA1MkU4NTFDQjdBNTU1MTBGQzExQjgyODNCQTZBMDI1NDI5NDQ0RUYyQUI1MjVGRjc5MzVCMTM0MUVDNjMzNikoMHgyN0I5OEMxOTczNzc4OUU2QTQxMTJBQzY1Mjk4MkZERTVFMEQzQUM5ODBFOEUyMzZFNUEyMzczQ0U2Nzc1ODc3KSkoKDB4MTdCNUM2NzlGOUI5MDVCNDk4QkMwOEU1NkQ4NEUwMkEwNjlBNzM3Rjg3OUQ3MTQ5QzM4OURDQjRCQjVEMENBRCkoMHgyM0JFRjFDQ0QxREQxRUVEQzI5MDBENjE5MjlEMDY5MTNERjE1RUUzMDgxOUVDRTcxQzIyRjA2QzE1NjZCNjY2KSkoKDB4MTQ3MkRFNEU0NEFEQjIzMzU5OUQ2NDNFMURGQTlFRjA1RDhGMTE2QjNCMjYxQUNEOTFBNTQxODJCNjdDMkIwRikoMHgxQTVGNDg0MDM3RTlCOTU3NzgwQUM4OTM3NTVCNzFDREIwMjhCMTU0OUI3RDM5RjkzRTEzNUM2RjhENzMxNkNDKSkoKDB4MENFRDgyOUUwRDZDMjY4QUU0NTVDOURBMjlEQjExQzU4MzAwMjBGNTgzRTU1OTg4QjJFMDM2NjBCNkUzNkExMykoMHgzQjUzMzQ0RDZENTUxOTNENEMzOTA5OTA0MEU5OEM0MjlGREU0N0QzQjU2OUUyNzc4OTgyMTJDNjlGRTlGQ0U0KSkpKShnZW5lcmljX3NlbGVjdG9yKCgweDAzNzBFREVFOTgzMjNGQTgzNDVBREMxQkRENDEzOTI5QUExOUY5MjA0M0QwMzJCMzEyQjIwRkMyMkM0ODM4RkUpKDB4MzgzMzAyOUMyNjUzODIzRTdGMkRBOURBMkI1NzJCRkI1RDFCQzgxMjI2NDRFMTM3QkM4QUJDNTVCMzJDRkY0NCkpKShwb3NlaWRvbl9zZWxlY3RvcigoMHgwRTczOUQ2Q0QyNjk1NEM3OTcyNTRCQ0NEREJEOEEyODAyOEJENDA4M0I1MUVFNjc4OTgyNEM2MEQ3QkE4MjEzKSgweDMzNTRCMjVCNkRBRTE3RDNCMjNFRkREOTM2OTM2RDlERTFGNzZGRUEwODVDMjU4M0I0OUNGQjlEOTg5MjA0ODYpKSkobG9va3VwKCkpKSkpKShmdF9ldmFsMSAweDAyQTJFRTU5M0JDRjUxNTNBRUJDNjc3Q0I1QjY5RDQ0NjYwNTk0RDFFREUxQjYwNTQzMjkxRjY3N0MzMDU2OUIpKSkocHJvb2YoKG1lc3NhZ2VzKCh3X2NvbW0oKCgweDJDQkNGRkE2N0MwOUIzODdCNjlDRTVCQTRGNUE5MDc2QTYyOUY0RjQyRTAwQjcwODY3QjYwRTU5RkJENTA0NzIgMHgzN0FBNUYwMTlBNDE0NEI5MjlFNzQ5QjMyMkQ1MkY5MjUyODREOTMyNjc0NDY3Q0U1MjNBRTc0RTNENTFGRTNBKSkoKDB4MTkzMDhDMkFGN0I3RDk0RjJGQTc2MTk1RThERUYxMDA5NzQ5QUY1NTU4ODE0NTI5QzUyNTJBRDg2MzI4MTg4NyAweDM5MkJCNUNEMjQ5NDJCMjMzNDQzNkMwNkIyMkM0RTkzMzI4MjUwNENEQjU3QzM0NEJDM0RBNDNFNDlFRDUwNjQpKSgoMHgxQzBDRkY0QkFCMzlFRTFGRjJFNThFQTI2MkIzREVCMjM5RDgwMkJERDM1NjZEQzJFNkU4Q0IwNzlDMDVFNjY4IDB4MkIzMUExQ0JEMEE2QjdDOTRBNEQwRUQ0QUYwMTdGMTU3QjZFREQyMDZDM0YzQjkzQjlEMDM5NEU0M0YxQkZBNikpKCgweDBFQTkzQzQ0OUI2REM4QUY0QUU2MUIyOTQwQTg5NjA4OUFERDE2ODRGNzQ0MkQzRUUyMkRDQTk2NkU4MUY2NDIgMHgyQzBEQzg4NTY3RkUwRkFENDEwNjhGMkNDQzFEODRBMzE1MjRDQzRCMzg3M0REQUJCMzFBQkZCRTMzNTAxNkVDKSkoKDB4MEYwQ0YyRjc0MjVEQUEyM0I4QTYzQzM1RkYwQkYyNTgxQzQzM0NFNDZDN0NCNUU3MTRDMUUzRDNFRjdGNTRGNSAweDBGNTdCRjAzMzk0NzQxMzA0OTNBMkUwNEQwOEMxNUM3RkNBQzJBOEQ4NzJDQTFBOUQxMjRBOTRGMTQ5RTFGQTIpKSgoMHgxQTU1MUJFNzM1NTJCNEQxMzZDODlERUE1M0I4RDIzNjcxRTQ3OUJGN0YzRjIzNkZENjREMEYxNkI2OUQ2NUUwIDB4Mjc3MTY3MTU5QThCQkY3MTFGNTIyMTg1M0Y4NzZCRTZBRjRCRjg3Mzk2Qzc2N0ZFRDI4QTNCMTA4MzdFMEE1MSkpKCgweDBFNUREMjQ4QUNCMTA4NjZCQTAxRTk4QTMwRjFCNjQ1NTY1MEI1N0Y5QjhGNUQzMkEzMzcyOTlCMzJCRENCODAgMHgyOTE0RkE2MDNBRTQzOTE2QUFENUI4MzRCRkZCMzQ5MzcwRjQ1MkY0MUZBQzczMjFBRjM4NEI1OEM1QjI2OTk0KSkoKDB4M0QxRDRDNzgwRTU5QjIxREQwNjFGM0IzQjI5QTM0QUM1OTAzNUUyMTY4MUYwODM3MEVCNzQ5NDk0QjBEMUFFQiAweDE0MjkyQzIwQzNCMEZDOTVENTdFQUY5MDYwQ0ZBMTI1ODUyQzlBNkJFQkEyMzVEMEFDM0NGNDY2RTFCRDg1RkMpKSgoMHgxRTY0NkVBQzlFRjU2REEzQjFGRTc4QkJBMTk0MTk2RDMyMTI1Q0I5ODY1NzU4RjBERjRCRUZFM0M5MUU4RjFFIDB4MzJGRDcyOTg3MURCQ0U0NTUxM0U5ODY2MjhCQjM0MEFGNUQ0OTgzMDlGQTlBRUQ1MkY4QkQxOTM5RjlFRjlCMCkpKCgweDJGRjFGMjMzNzZDMTk3MTQ0NURGMzFGNkFDRjc4NzIwNEQ2NTY2NjZFNzE2ODVFMkNGMjE4MEY4NUVGQkNBMTkgMHgxODk5NEVGRTY3RkVCQzIyNDBCNDU1NUE0MDFBMEI1NUVBOUJCRjc2Qzg1MzUxRUFFMzc5ODUyOTRCNEM5QjJCKSkoKDB4MzExNkE1NUU2NThCM0UwMTlCNzM3OEUyMEFGMkRBQzhCNEVDOEVFNjRGNTdFMkUyNDI3M0E4MTA5MDQ4QTM3MyAweDI4ODcyRDQ3REM3RTRCMThGNTJCOTZDOTYzQzc1RkJGOTk2NjM5NTFERTc1QkI5MjRCNkEyQzBDNTE2NTRFRUMpKSgoMHgyRTIyQTFEMEYyRTg0RkExMjJBODgwREE5NkM1Q0NBM0VCNDFEODZFOTY5NDZGOEREMTQyNzVEOTUxODJBMDM0IDB4MURGNTA2RjdDQzkwNUVBRjg0NjY0MjcwMjU4NzM2MjNDMzE1NkM3RUYyRERFNTJGRjE1RTgxMEY0OTVDNTU5MikpKCgweDJFNDBFOEY3Nzc0QjEyNUQyRTg5QzJCODJFNzIxNERGODUwN0RFM0VERTI0REYzRUU1NTg1NTk1QkJGODgwOTQgMHgyNEI0Q0E2QjhERTgyOTM2ODc0MDk2NEQyRTkyMEFBRkEzNDI3QkE3NDZCM0UyMzA2QTBGMjdFODQwMDVBNTQyKSkoKDB4MzREQ0Y5RjM4NUZEMDQ2RTg4Nzg2MkU4RDExRTlFNDRGQzc2RkE3NzE4RjI4QjgzM0RBRUU0M0IyOEUyOUY3OSAweDM3M0I3MEJBMDk1QTNFMEZDODkxNjI4QjlEQzFGRkQ3MjU0RTc5ODI2NTUxNDFGN0VFREQ0MjM0MUYyMzY2RDkpKSgoMHgzNEU2RjVENERDRUY0MTE1RDE4RjdCMUQxRTlBRjMzQ0M4RTM4MkU3NEE2QTlEQTZFNDQxNEI5REM3ODk1NjUwIDB4MjI0RERCNjY4OUQ2QjZCNjEyNDI1MkQ2MDU2ODk1N0EzMjY0MDM4NzVGRkZDMUU3M0IyNzFCMUU1RDg0M0UzNykpKSkoel9jb21tKCgweDI3MEYxMkY2QjVCQjdBNjk1MkYyNDcyNDY4NjgzQ0FCQjg5MzM1ODIxNzhFQzhGMkJCRkY5RjQzMkZFN0M0OTkgMHgzMTYyQ0U5REQzQjYwRjFDNUUwMTEyN0JENTI3NTQ0OTFDNzZERkMwODgzNjkzQTJFMjk1NzM5NkQ0OUQ1Q0EzKSkpKHRfY29tbSgoMHgzNjExN0U5REY3QTI0MjM1Q0QzOTQxRDVENzdCRkMyRTI4Q0E3QzA1NDlENDlFNzVCNTc0RDg5N0VENEY3MDRGIDB4M0QyREU3QUI3MDlDRUY2QTcxNjE2MjA0ODU1M0UxNTQ3Mjc3NTEyQjU2NzUzNEZBOEIwQzZGMzI0MEU5QTNGMikoMHgwNDQ0OTY1RDM0NTQ3MEE5RkU3Mjc4MzNGOEIwRjQ4OTlGQkNDMUYxMUE4MTEyQTBFN0U4QTBBMTVCMzA0RDBEIDB4MjE3NzlBQTFFNjlCN0E5OTJDMEU1RTQ4MjM0QUMzODc5QTUyRUE1QTREMjg1NUM3RDJGODM4Q0U1RkNDNjE1MSkoMHgyM0M0MEYxOUIwRjNENDBEOUI1NzQ5REQzODc3REFEQTIxMTVCNUYxOUYwMkZFRjhBRjJBRTc5ODEzNENFQzVFIDB4MkY0MDgwMzU3NjcxMUM1MDI2OTIyODFFRjE2QjEzOUMxM0M1RDhCMTEyNUQ0QUEzNDZDN0E1QzYxRDdFOURCRSkoMHgyREJDQjNCMjQ5QkZFOUQxQzcyOEM0Rjc1NURBMUQxMUVEQTlEMDAxNEIyNEE2NDU4NTFBNEZCNzJDMzlGMzNEIDB4MTQ5MjY4NEFCN0NBOTVGMTdGRUU5Q0EwQTQxOUExNzQ2Q0IwNDc2MDIyQTgwRTkyMDQ0NEFCMTM0MkNBREQ4NCkoMHgxQjlDNDVERjY0RTBGRURBMTI3NDVDMEM0N0VGNzA2MTVFNzhENDNGN0E0MkJEM0I1N0FBNTM1MjEzRDRCNUQzIDB4MUFEQkRCOTQxNkJDQjk1OUVCRkIyMTlBRDlCOUQyNjZEMURFNkFDMkVCNDI3RUY5NjAxQkI2RDY4NTQ5NkE3MCkoMHgyQUY2QzI3NEMzRjgzMkQ4MDAwNTBCNjE5OTgxQTUxMThGQjk1ODIxQzUyQjY5ODJFQTY4MTJBNjI4ODc4NEQ2IDB4MTNGNDRENDkyM0ZFQTJFQTFBRkQzQkJFRUJEMTE5MERERkI1RkY5NDhCMkM5RTI0MDFCQjZBNTFBOTdBNTE4QykoMHgzRDcyOTJFMjE1MDgwRjRERUIyQUMxQkVDOTgyRDM3QjJBQjNBOUYxMkRFMjlERUExQjQxNzA5MUZGNjg0MzAzIDB4MEQxOUNBMEUxOTE0MDQ3NjREMEI1NDU4RDJCQTk1MEEwMjU4RENFOUE4NDY4NDNGMzE0NUI1MUI4MUQ0ODg5NikpKShsb29rdXAoKSkpKShvcGVuaW5ncygocHJvb2YoKGxyKCgoMHgyRTVFQkMyNDBBMDMzQ0E5RkFERDUxOTM4OUY4NEY1Q0YyQUVEMkJBQUM3NjFBREZBODNCMDg0Q0E1MkFFNjg5IDB4MDk1MzU2QURFNTRGMEMxNkVCQzE3MDMwM0NBODZCMEUyM0M0OUY4OEREMEU3MTA5NjcwOUEwN0FGQzUyQjY2RCkoMHgxMjg1QzBFMTVGMzdGOERBM0QzNTJEMERCN0VGNTQ4NUJDODQ4MDhDNTEyQjk4RTVDRDg4ODdBOTdEOEMxNUU4IDB4MDlBQjJCMTU0MzlCQzk3N0FFNDQ5MDFDMzQzOUY3MDIzQzUwQUU1NUJGNDZCMDZCNDA1MUNDMUU4MTZGM0JGMykpKCgweDExRDREMEVCOTJCMjYwQzlBRjQ5NjQ1REYzQjlCQTQwNEMxRjYzNTc5RDIyMjZFNzRBMkVBMzlFNjEyQTAxNzQgMHgwRkIyOEJCMUQ4NUJGRjZGRDdBQkRCODM0MEEyMzkyMDI4QjVGM0ZCMTExMUNFOTE3QzE4NzgwODc3MDhEODIzKSgweDE5NDg0OTY2ODA4MUI3NzU0NTZERDk2QkVDRTI1QjYxRUM3OEU0ODk0OUVGMEU0ODMwQjM5QTIyNEFBNzFBNzUgMHgxMjQ1QkI2MzM3QzRFQzc4MzA5MjkzMUExNTE5Q0JDQ0JDM0U4NjA5OTY2OUQ1OUQ2ODJDOTEyRTFFOTkyNjVGKSkoKDB4MEJCNkNFM0VERTBFQkIyRDY3NEQyODdBNTVDOTk3MzI5OTE4RTgwQTI2NkNERDBGOERBNDJGMDZDOEIwMzc1QSAweDEwNEU1QTI3Njg2RDZCMDRENDk1QTkyRDNGNjJBM0MxNjYzRTMzQzM5RkE0MDg2RTFDMjFFNjQwNDlGNzQxRDUpKDB4MkUzN0RDRTlCMEY1MEZFNEEzN0IyMzQ4QkYyMTE5Qjc5NzE0QzEwNDAxMTk0MzM1REVFMkUxMjBDNEJDM0I1RiAweDEwMkQ4MDAzNjBDM0Q4QzY3QzdBNTg2RUU4ODhENjYwNTAzMTRENjE2MkY2Q0NGNTc5MzY1MDgyNzFDNjQ5NzEpKSgoMHgxNDZGNTBGOTE2NDgyOEE3RDExN0NBODhFNDU0N0RGM0EzMTJCMUMxRkFCN0FCNEFEQzRBRjE5NzQ3NUY3Qjg3IDB4MTVBRUQ5NTdBMEE4NzhDMDM0QjZEQzJFMTg4MEMwMUE2NTQzNTg4M0EzMUI0MkQ5MDU1NjE4QUVDRTE4RDAzNCkoMHgzNENCODkzRUEyNkM1RjU5QzNGMkJFODFCQTA0QzBEQURBRTM4RDE0NzZFNjFGNDY1NUExNzBBM0JFNzJBMzlFIDB4MjE0QjQ1QTczOTVBREUxM0I5QjRFRjIyMUFDNDA1MUVBQUJDN0M2NDU5NTc4Q0RFOTJGMEJFQ0E1MUQ5N0YyMykpKCgweDA2NUEwRTJEQjRDNjk4NUMzOTlFQkI2RkE5NjZFNzkwMzlEMTc1Q0I2NTM5QjVEQzRFMUQwMTg0NThCODRFRjkgMHgwRjI4NTg5QjE1NERCNkY2NkJCMjZFMTVGM0M4RThBRUYxQzQxQUY1MTJCNTVDOTVGMTlCQTRBNTg5NkNFMDNFKSgweDBCNTY2M0NENkIzQzUzMTZEQ0JCMzk3NDQ5RTBBNDhDMjlGM0M4Mjg4MUVDNDNCMTVGQURGMTZCMUEwQjU4MDIgMHgxRTREQ0MwNzNGOTA2MjJCNkU0NUVBRTBENUJDQUEwRDQ3RDZGOTM3Mjc2RkMyNTVENUJBQzlFNUQ2RDYyRTU4KSkoKDB4MDIzMjM5MDA0NDU5M0FDRjAxRDVGRTUxN0Q3MkREQ0YyQ0IwMTEwNjRCQTQyMjQ5OEE3NUVGQUFCMEVDRUFEOCAweDFDNTkxNzAzN0ZFRUVEM0YxNUQ4Qjg3Q0M0MUYyNDBGNUFCMkQ2QkEwN0Q3OUIzMzMxOThBNDYwNjcyMTcwMjMpKDB4MkE2NTZFQ0U0MkEwMTU0NEQxRjZEMEQ3QkY1NzYwNTY1QTUzM0VERjc5MUYzNzdBN0ZBRjYwQzEzREQzOTE1OCAweDA4NDc2NkY3NThFRkRERjk3N0Q1NTQ3NkE4N0E4QjU5NjRBOEVBODRDQUMwQzNGM0JERkYyN0MyRjRCQzJCMTcpKSgoMHgxQzVBRDA1MzQ5M0Y0NjYyRURBMUJGMUU3N0RDRTEwQ0I0OEM1NDFEOEVFRUYzRDU1MDZDMzc5ODdCMkU3RERBIDB4MzBFMTRBRTc5NTE1MEYzQjdEMzU4NTIyNTdDMUUwMTdGQ0YxODFCNEYwODMzQkU1RkY3Mjc2QzcwOUJGMUM4RikoMHgwQzU3NDVCOUZDOTIyMDM0QUQ1QTNCRjJBREFGRTYzQzI5QzRBMDZGNUNGM0QwNkU3QzE0ODZBMDMzRkIxRDU5IDB4MkQ1REFFQkFGQzFCMEQ3NTQ3OUQyRkVCNEJEMDU5MTJBNDY1OUQ1RkQxQTFDQ0VBNkU2QzI2N0MwNjg1RTlGMSkpKCgweDIwOEU0QTU1OUMxMTVFMENGQTg1NUYxQjExNTRCQ0I0MkYxMkI5RURBQ0RGNURDOUQ0NUUwQTI4QTcxMjk3REIgMHgzMEIxQTU2OTc0RjJBRDNGOEQ0OTBENEI2M0M5RTdDQkVBNThCNTJBQTdDMjJCNDk3QzNEOTI5NkUzQzRGMkM5KSgweDAzQjI4MUNCOUQwRDUwN0E4NTA3NzIyQTRDQkM5QkJCOEU0QzNBRjVFMkVGNzkwNTNBQzVDNEQ3REJCNjlDQkIgMHgzMzI0QTNCOTY0OEMxRjlBQ0YyMjBCM0QzMkVCRTNGQjI2RDREQUU3NzYxMDE4QzhBQTdGRjc3NkJGRTY3RkI3KSkoKDB4MkNERjhCQjY1OTYxMDI1QkNDRTZGRTkyRDQ4MEM1QkE4MDBERDc0QjFCRDZCQzUxMkUyMkVGMUE3RThCRTIxOSAweDI3Mjc0M0ZCODU0QTM5RkVBREQ1RENERTZCQzA1M0VDNzlBQzBENUZEN0E4REU0Mzk2OUMwQTE4RjM1MTE4NTcpKDB4MTRFNDA3QTlBMDQ4RjZFM0QzNDAxQ0JERjA5QjE5OEE2NTFGN0FBOTE0MzJDMDY0QjA0MDZEREUwNzlGQTE0QSAweDJEOTA0OThDMDA2MjM1Mjk0RDdFNDZEMTlENjFGQjJFQTcyMkRCOUY2QkEyNTExMEEwREQyMzM4RkJCMzdEQjUpKSgoMHgyOTg2NzA3MTY2NjI5Nzk5MjlERUY0QUJCOEExNDIxOEU3MDUwNTcxMzQyODg5QzYyRjk5NjNFMzAyRjY4MTE3IDB4MEZGNTY5RjY5ODFEMjc0QTA1MjhERjlCNDcyMDUyNTIyMDE5NTEyNTk2MUJEQUQ3MzRCRTMyODM4Mjk5QkExRikoMHgzRkI3NUE1Rjk1M0I1RjNGREQ3QkIzNUUyMzI5MDUyMTJENUE1RkUwMzA1QTI4Mjk0N0ZFRDM2Qzk4MjhCMTlBIDB4M0NBQzE1MTA5Q0M1QjQzOTg5NzMyMUY2QTFCRUZGOTFDRDE4NkVGMjQ4MEYyNkVCRERCNUQwNDZDRTA0NUVGOCkpKCgweDIwNEZDMjQxNTU2RTE2RTY0NjM2MDY0RUJGNDdDNzdBNTM2MzkwOTNDNEZGNTEyNkNEMUJFRjYxMjEwRDg5RjQgMHgyRkZDM0Y2RDgyOTBEOTNFOTU1Q0ZCODRBRjI4RjkzRDRCRDVDRTE0QURFNEI2MEMwRkE5N0MwQUMyNjQ4Qzc4KSgweDM3NzFBM0Q4OEU0MEY2RkQwQkFBNUVEQjBCREFDRTM5RTgxOEQ1ODlDOEE3NzFDRTNBNjc1RDVGMjYwRjJEQ0EgMHgyMTQ0NjkzMzQwRDc3MjIxNUQxNTUxRDJEQjRCQzk1MEJEODE1N0JBMUM2RDA5NEQwODZCQjE3NDZFQTA4NDlGKSkoKDB4MTFBMkU2NTVDMDk4MzU0NDYwMEFENTUzNTRBRUUyQTgxRjY2RDQ4NUZBMEY0MDUyNzU1QkFBQjVDMkZBNTI1OSAweDE2MDlEQzE1NDdFNjZGNDcxQzVCRkQ2N0NDNDdEOUJEMDZFMEJGQ0I3RkM4QTVFOUJDMDIzQkMxN0ZDNjgwNUEpKDB4MEI1RjkxQzkyN0U4QTFDRUEyODZCNzJDMzQ0RjIyOTE4QzkyN0YxQ0RFNDNFMUY5RjE0Mzk1MDI1MzYwNzc2NiAweDE2OTdFRDIyNzAwMEJGQThCQjdENzQ1MEM2RDVCNDdCRTRCMzBDNTI5NUU2MzAyRDIxMDkyQjY4REYxMkY4ODgpKSgoMHgwNkE0OTNEMUY5MkNFQjdCQjc5MjQyREY1ODIwMDA5MTM0NjlGMUE0NzIyNzZENjdBOEY5QTUzMEZGODQ2MTI0IDB4MzY2QTA3RTdBQzFDQkE1NDNFNjRFNTk5Rjg5OTJCMjY3NzExNTFFQ0U5RTZBMzBEMkQ3N0U0NkMwNUQ0NEE2NCkoMHgxM0VGMDczMUVDMTZBMTg4RjQ2QTg3QjhCNUUwQ0QwMUYzQTU1NDBGRTAyOUFBMjg2RDcyNjk1NDEwMzE0QjVGIDB4Mzg1Njg4OTE0Nzc4QzdBRDgxRDdDOUVEMkQ1RkQ1MDc3NzZCODRERTJDODQ5OTc2OUUyRDY0QkE4RUI0NzZFQikpKCgweDIxQ0ZGODE4QTEzQkE4NUQ4NTI3NjJFOTVCMDFBQjgzOUM0RjY2MUJDRjMwOThBNDkzNTE5ODMyMDA5NUREQUUgMHgzQkMyMTM4M0I5MjYxQzJCNjhCQUFFMjU4RkRBRkFBMDQwNEEzNThFNkQ4Q0M1NkI4MjZGQzUwODk1QjMyNEVFKSgweDAyNjM4ODc1QUM3NEZGRjMzRDZBQ0NDNTU1OEM2OTEzNTFDNTdFMzZGNDY2MjFDMTg1MEIyNUM3Q0ZFQjRCODkgMHgzRDMxRDhENTIwOThFQjMwMDUzNzJENzk0QkMyQkJCMzBFRUFGRThEOTZBQTRCMUFERTMzN0M4NTc2MjQ1QTIwKSkoKDB4MjJEMjNFRDE2RkQ2REE5MTMwMzFGRUE4ODhFQ0U1OTUxNDFENzE0RTMwNTlGNzUwQjE3Njc4RUM5QzlGMkIzOCAweDEzNzAyODIwMUEyMzM4QzBDRTk4Mzc5QUI3NDg2QjJDNzFDRkUxNDRCNEZDMUU5RjBBOUJDRjIyMzdGMDM4QzMpKDB4MDVCMzY5ODJEOUZFMTk3NzA0MzlBOEZENkNDRDhERjVGRDk3MzE3ODU4Qjg2MDYzMzVEMEJBRjc2RDk0MUY2NyAweDM2OEM5RjA1NjE3RTFGQzlDNUZCMDAyNUEwRDk0NDgzMzQ2OEI0NTIwREY4MDJGNUNBREVDQzRFMTY0NzNCQkQpKSkpKHpfMSAweDAwM0QwOTkxRjEwQTUyRkFGRkE2QjZFMDNFM0M4NkI5MDdCMjU3NUI1NkM0RjUwOEM0NUY1MzY4QTY1NkFGMjUpKHpfMiAweDAzRUFFQTBFODU3NjM2RjY5OTdENzEzRTczOEU5MTNGMzcyMUU1MkExNDQ2M0M1QjFERTk5MEY5QzdGRTUxNkQpKGRlbHRhKDB4MzlCRUJEQTY1NjJGQTcyMDQ5ODI2RTQ2NDkzMEI5NUExOUFGRTk5N0JEQ0ZGQjc1M0ZBQTdGODI5Nzg4RTA4MSAweDFFRTU3QjlBRUVBNEU1RjVGOTgyQzJEMzhBQzA2NTcwNEE1MDQyOEE1NEE4NEFGNzUxNTMwQUI2NkI1NkZGQUYpKShjaGFsbGVuZ2VfcG9seW5vbWlhbF9jb21taXRtZW50KDB4MjREQTg0RjM2OTZGQkREMzRDOUQ4RTE0NjQ0OTFERjU1MTMyQTJCQTQ3QzIxQUM3NEY0QTk3ODUxOTdDQ0M5MiAweDFEQjZEMTcwOTNBNTA5RjYxNUEzNzQ1OEIyQ0Y2N0Q5Q0Q0ODc3QTkwNjE1Njk2RTFGNDc4RDNCOTZBQ0RERDgpKSkpKGV2YWxzKCh3KCgoMHgxNTEyNUZGNjc4QUQ4OUQxRTUwMEJBRjdDNjU5RjE4MjNEQjRGOEE5RkZCMkJEQTRDNjA2OTA3NzJGNDdEM0YwKSgweDM5Q0Y3N0RDOTMxMDkyMkIzNjMzRTVBNkQzNUFDREFCMDk2NEQ5RjlBRTlGRDI1NTY2QjRCMUVDNDhBMDZDNUMpKSgoMHgxMjJERTQxRTU2Rjg2N0Q1QzhBMDc2NThGMzI4MDQyNkVEMjU3Q0VERjg2NTMyNDY2REQzMDA1MTREMDUxNzM4KSgweDNEMjFBRTcyOUVGRUIyMzU4Q0M3RTY0QkFBNDFBQURENTU1MTk5QTMzRkI1RkE1NjkxQTc5NTA4MUUyNDVEMzApKSgoMHgyNEFFMTg4NzA1RkNERTAzOEM4OEUxRkUzNDk4MzAyNTYwN0E5RjUzMDAzOENGMENEMjU1QjYxRjZCMTI1OTk0KSgweDEzRjVCRkMxMDIzNjJENzUwNjZGQzJERDNBNjJGNEE4RUY3QjIyQ0I2QURGMEQ0QUNBQUY1QTY1NTlFMzg5NDMpKSgoMHgyQzlGODg1N0MzRkY3Rjc2MTZFMjQyNkUyRDc0OTE2MzJCNDI1OUE3RTFGN0Y2RDkxNTQ0N0ZCRkIwNzIxNzMzKSgweDJCMThBQTA4MzZGRDQ4NThCQzFBNThDNDU0MTUzMDE2QzkzOEVGNDE4NDA2OUI4RTcyNEQxNjI0MzVFQkQxRjYpKSgoMHgyODMwMDJBRTg1MkI4NTAyQjQ5MThFQzYwMDMzOTAyQzU3RkFDOTIwMEY5Qjg1NTg2M0ZEQjU1MzZFRDdEMzhDKSgweDAxRDE0NzBBNzlBRUY0NjUwMkE3NjlCNEU0MjAzMUVDODdENEY1QzE0NTA4RjNCMUUzMjVFMUQwOUU2NjdGMjIpKSgoMHgwOUY1N0Y4MTY2MzlBMEQxNTZBMTI0RUJENzM2OTc1QjlBREU0NDU5M0Q0RkQ3REIzQUQ2RDNBOTEwMTFBRUU2KSgweDEwQjU3MEJFOTJCNkU0RkNBM0M2RDlCQTQ1MDYyNDI0RTMwMDFBNzZEMThEMkVEOTVCQjZDMjFGRDQyRkZCNDcpKSgoMHgxQTcxODU0NDlBNDQ3M0NEODZDRkVFQzYyNzU3RDk4OUIyNTg2MDZBOEI3QjMxMzgzMDhGMkRBODcwRTlEOUM5KSgweDM1REZGRkYyQTY5NTY3NUFDQjgxNDM5OTc2NjMxREI4RUMwMDIzQ0I5MEQ2MTYxRDg1Njg1NUMwMzJERjI2QTUpKSgoMHgzRjBGREY5MTYwMjkwQURDNzNBRjQxNDM0RThDMDU2NDcyMjkyM0EzRjlDQTA1NkRFNjM2MzQxMDI5NUZFOTM1KSgweDA2ODYzRTVCNTJFNTI2QjY1NkQwMzBBMjExRjAxRkEyRDdFRDgxNzgxNTkwRDc5QUFBREQ1OTQ4NzM1NjA0NkYpKSgoMHgwQzRFMkIwNjgyNjRBQjg4REFEMjkyNkY5RjM4NjlGQTlEQUFBNUY2RTYwQzc2RjQ3QzNBQTYwQUI0NEM1MUJFKSgweDNCMzI0OTM2QURENUVCNDdCNDJCREVEMjAwQzVEQ0QxNEIxMTE4QTcxNDhFODc3RjE2RkM0NUIzNjVGMjc2RTIpKSgoMHgzOTBFQTVCMjBGOURDN0QyN0Q1RjdERkFBOThBMjE4NDQ3MERFMjIxMjQ2NTgwMDExODk0REI1QjY3MjE1OTEzKSgweDM4RjRGQjkzNkQ5OEQ0QjdFMDE5RjdBMDg3ODBDMEQ4REIyQzhEOUNBODhFNzIwQUNCRUUzQUQxREM2MEMzOUQpKSgoMHgwQzA5NUQ3MjdEMUQzRjMwRTY5QzRBNUFDRTJFMEY3MDg4MUI3QUQ5RTY1RkJDRjIxNkI2MENERUE0NTBDRjk0KSgweDBGQUU4ODUxQ0RCREE1M0REMjJCRTVFOEE3OTNEMzNGN0VCNEFEQTZEOTVBQkMwMDE4RTM5NENGQTk1NTI3RjUpKSgoMHgzMEQzNDUyQjhEREY0ODA2MjcxQTlCM0IxOUM1QzBERUZENjU3REY5OThFNzE3REY0NjI3RTgyNjdENDFDQTQxKSgweDEyQkUwQTE4RDE1OTMyRjcyNjY5NjZGNEI3MzQwQTY0NUREQzhGRDEyNUYwQTlFQTc0NTUzNDAzNjFBMEEzNTIpKSgoMHgzNjY5MjUyMDQ5NDZGNzYxMjA4M0UyNzI1RUU1NTk5QkE4MDAyNzM0NkM2RDlERDAyMDZGODZBNThERTlBNUYzKSgweDJCRjk0RDhCMjQxRkQ0MDUzMDlCRDQwNThEMzRGOEYxRkFBNjVCRDM0QTk1RjAyNjg5OEVFMDVFOEQ3MjQzNUMpKSgoMHgyMDJCRkU4QkQyRDFFODU5NURGQzYyRjI2RkMwMDU5NjJFOTRFNzZCREQyQUJFNTUyNDAxNEI3MjdBRTU5REM0KSgweDI2NzU3OEM4OTA5NTZEODg0MTAyRDFBNzkxQjM1Qzc3RjFFMDlCOEU5MTQ0NTY0ODAzOTAyQjlCMzBDQTJBMzYpKSgoMHgwNzU5QzJFNUM2QkZEQkRBMENEOTcyNTJFMTg5RDgyQkMyNTYxQjA0NDNDQUY4MDk3MTVGNjczQ0Y2N0RGRjY0KSgweDFDOUY0RTRBMTA5QTEyRTA4REUyN0NBRTIxRUZBQjBGQkM3RkZBREI0RDY4QzRBOTdBMzI4N0Y3QjU4M0Q4Q0UpKSkpKHooKDB4MDRFQTIwNDJGOUFDNkIwRTY1MDE0N0JDNkEyMDFCRkM5M0QzRTFDOTQ4QTBFRUY1MDc0QTlCOEQxNzU0MDVBNCkoMHgxRDMzQjU3MTIwNzg0OTZFRDAwNDUwN0ZBNUQ1NUYyNDlERkM5QzJEOUMwRDA0RUZDMjhFNDc3OTlFMEMxNDg2KSkpKHMoKCgweDA1QjNGMDgwNkZEOTI3MDU5Njg3ODEzRUQyNTUwNEY1OUIwQzAxM0I2REVDQjk4RkJENUU1RjYzQzI4MTIzNEMpKDB4MUY4MTc0MTU1RDFFQTM2MEQzQUZGRDJFMkI2OThBMThBQkMyNzI2MDE5OTA4REFEQzQ2RUNCMzA2N0VGNTlGOSkpKCgweDMwRUNBMTI1Q0QwNUU5NkU2M0U2NjA4NjAyRTlDQkE5QUU3RTIzQjA1REUyMjAwM0QxQTEwRDExMjUwMjVBQTcpKDB4MDhDMUIxNTQ4NEZBRkRGNDYwNzkxODM4MDYwQTYxRTg2NjM5OEJERUZFRTRGODBDNTkxQTU5OTJGMTE1OUM5OSkpKCgweDFGQkMzRTM0MzA2OUE3NUY5QTQ0MUM3RTRDMzBBRjVCMEI3NDJGQTNCMUIyQzk1RUFFMDIxREVGMTgwMDhCNUIpKDB4MDM3QTc4QzQ0M0YxNjI0N0Q3MkRCRTU0OUY4MkJFRkNBNzc5MDQ4MEQyRjIyNDY0QzgxODNBRTI4QzkzODFFMSkpKCgweDM3QjJFOTZBMkJERURCMzcxMzMzNzFGMjMyQzFGRDc5MzJFQTZFOENCNTJFQjhFN0ZBOTY3QjVCREI1NDhDQTYpKDB4MDA1QUU0OTRCOEQxNTE2NUI3N0ZBQzNBOTE0NzREQjYzQjdGMjZBM0ZFODYzNUI1MjY3QjZDQ0M5OEE3QkNDQykpKCgweDFCMDg4QjdCMjgzMjc2OTZCRjQ5NEU5RUQ0MzlEM0ZBMEU2M0Y4QUIxNzdBNERFOTkyQURFQ0M3NTMzMTA1RTcpKDB4MEVEQUVCNkQ1RDkxMjc0N0U1OUE0OTA4Q0E2NTgyQkQ3ODk2OEQzMkU1OUJFOTcxMjUwRjE2NDcxQjE2NjdFMCkpKCgweDI5OTA4RDBGNjQwQjk3OEVBNDA3Q0U1NUY1RTRDMDc3NTE2NkJDQTc5OUNBNTM3NjcwNEQwQzU0NjIxODc4MTMpKDB4M0Y3RDJFNzYzNDA0NzcyRTZFRjk2NjA1QUQ3RjE5N0U0ODYwM0M2NzA5MDY0NDZBMzI0NTRDRDk3RjVDNjc1NSkpKSkoZ2VuZXJpY19zZWxlY3RvcigoMHgxN0ExMTVEQkJCMTcwOTE3OUFCMzVEOTAzQzZGMDQ1NzJGQUZCQUFERjREOEVEOTdBODM4MTgyM0ZCOTA1RUZDKSgweDNDODUxMzNDNUJEMjI4NEZBNTIxREU3OEZDQTk1NzYwQ0E4NzM2ODA3NTg5OERGQjQ3M0U2NDIzRkZFRjBFRDIpKSkocG9zZWlkb25fc2VsZWN0b3IoKDB4Mjg1REUwOEZBRDI1Q0VFREM4MEM0OThERDhBQjlBMzhCQjJBMDkwMjI1Rjc0QTcyQUI4Q0ZEOEQxNkM2Rjc1QikoMHgyMUY0N0NFMkEzRURENEJGRURGNkFDRkREMjk0ODM0Q0QxRjI0RDM0MEE4MDA0QkJFMTZDRjIwQ0Y5N0E4RUE4KSkpKGxvb2t1cCgpKSkpKGZ0X2V2YWwxIDB4MjY2Q0M1M0E2RjM1N0FBMjM0NTQ3QkEwREQzQkUwNUY4Q0M1NjcyNjZENjNDMDg0MUQ3RkU0NUFBREEyRkZGMikpKSkpKQ==""
}


console.log('verify...');
let ok = await verify(MyProof.fromJSON(proof), verificationKey);
console.log('ok?', ok);

await shutdown()
```","[('xhliu', 'I have a similar issue\r\n```\r\n> ./run src/examples/program.ts\r\nprogram digest 2e7f082cb1ff8b1ac0a6c67caff2162f7a164dd5219b1e96f80c7091167092ce\r\ncompiling MyProgram...\r\nverification key DxbfRV5Rdd..\r\nproving base case...\r\njson proof {""publicInput"":[""0""],""maxProofsVerified"":1,""proof"":""KChzdGF0ZW..""}\r\nverify...\r\nok? true\r\nproving step 1...\r\njson proof {""publicInput"":[""1""],""maxProofsVerified"":1,""proof"":""KChzdGF0ZW..""}\r\nverify alternative...\r\nok (alternative)? true\r\nverify...\r\nbad verify: dlog_check\r\nok? false <------ here\r\nproving step 2...\r\njson proof {""publicInput"":[""2""],""maxProofsVerified"":1,""proof"":""KChzdGF0ZW..""}\r\nverify...\r\nbad verify: dlog_check\r\nok? false    <------ here\r\n```\r\nWhy do the last too checks fail? Especially, why does `verify()` at Line 39 succeed, but it fails at Line 52?'), ('zhfnjust', 'yes , `verify` returns false , but `MyProgram.verify()` return true. '), ('Trivo25', 'This bug seems to occur only with proofs that recursively merge another one and are verified using the ""serialized"" variant `verify(proof, verificationKey)`. Thanks for bringing that up, we will look into it!'), ('mitschabaude', ""The latter bug is tracked at https://github.com/MinaProtocol/mina/issues/11389 \r\n\r\nWould be nice to check if the first issue also only occurs with 'verify' ""), ('Trivo25', 'a fix seems to be on the way\r\nhttps://github.com/MinaProtocol/mina/pull/11698'), ('mitschabaude', ""Btw, the difference between `verfify` and `MyProgram.verify` is that the former transforms the proof in a way that makes it accepted by Mina, before verifying. It's this transformation which causes the bug. So, you only should worry about this if you want to send your proofs to Mina. (That case will also get fixed soon though)""), ('xhliu', 'In my use case, I (the prover) send the verifier the proof, which he checks against the verification key. He does not have `MyProgram`, which would require him to have the `ZkProgram` source code and compile it. He just wants to use `verify`.'), ('mitschabaude', 'closing this in favor of the similar #427')]"
353,The latest version(0.5.1) does not export the JSONValue type ,Comdex,closed,"```typescript
import { JSONValue } from 'snarkyjs';  // error
```
Has this type been converted to an inner type？","[('mitschabaude', ""Yes - it's an oversight that this is not in our changelog. Many inessential exports have been removed. Do you think we should export JSONValue? ""), ('Comdex', ""> Yes - it's an oversight that this is not in our changelog. Many inessential exports have been removed. Do you think we should export JSONValue?\r\n\r\nIf we can use the toJSON() method of CircuitValue directly, I think it is necessary to export JSONValue. ""), ('mitschabaude', ""I think we want to replace APIs like this:\n```ts\nField.fromJSON(json: JSONValue): Field | null;\nBool.fromJSON(json: JSONValue): Bool | null;\n```\nwith APIs like this:\n```ts\nField.fromJSON(json: string): Field;\nBool.fromJSON(json: boolean): Bool;\n```\nIf we do that, maybe we don't even need the `JSONValue` type anymore""), ('MartinMinkov', 'Closed as #536 removes the usage of `JsonValue`')]"
348,dump serialization of (prover) index and proof when verification fails,mimoo,open,"It would be helpful to dump a base64 serialization of the prover index and the proof when verification fails, so we can debug things on the kimchi side without having issues with printing things (because wasm)",[]
347,add `gte` to UInt types,Trivo25,closed,,[]
344,Circuit verify fails when the public input is all zero,freedomhero,closed,"This simple program outputs a log of `verify false` at the end, which is very confusing.  It seems to fail at `y.assertGte(0);` when the public field `y` is given `0`. If `y` is given `1` as its value, the output becomes `verify true` as expected.

snarkyjs version: 0.4.4

```
import {
  Field,
  Circuit,
  circuitMain,
  public_,
  isReady,
  shutdown
} from 'snarkyjs';

class Test extends Circuit {
  @circuitMain
  static main(x: Field, @public_ y: Field) {
    x.assertGte(0);
    y.assertGte(0); // should pass if y == 0 but not
    Field.fromNumber(0).assertGte(0);
  }
}

async function main() {
  await isReady

  try {
    const kp = Test.generateKeypair();

    const x = Field.fromNumber(0);
    const y = Field.fromNumber(0); // change y to `1` will pass
  
    const pi = Test.prove([x], [y], kp);
    console.log('proof', pi);

    const success = Test.verify([y], kp.verificationKey(), pi)
    console.log('verify', success);
  
  } catch (error) {
    console.log(error)
  }

  shutdown();
}

main();
```","[('mitschabaude', ""thanks -- will investigate! it doesn't seem to have anything to do with `assertGte` fwiw"")]"
342,Add Merkle Tree Implementation to SnarkyJS,ymekuria,closed,,[]
336,Application B Voting contract scaffolding ,ymekuria,closed,,[]
334,"Change the ""party"" name",mitschabaude,closed,,[]
333,"Estimate # and type (proof, signature, no signature) of parties for some use cases",jasongitmail,closed,"- Attestation 
- Rollup (Florian)
- Recursion 
- DEX (Gregor)","[('mitschabaude', '* Recursion: a simple example like mastermind:\r\n  * 1 proof party -- the zkApp which consumes the off-chain proof and verifies it in the circuit\r\n  * 1 signature party -- the user account which pays the fee'), ('mitschabaude', '* DEX (minimal case) -- swap interaction:\r\n  * 4 proof parties -- the two token contracts for the X & Y tokens that are swapped + the dex contract for token Y + plus the ""main"" DEX contract (could be the one that owns the lqXY token)\r\n   _note: the DEX can probably get away with no proof party for X, because it only receives that token_\r\n  * 2 signature parties -- the user who interacts, with the account for the X token, plus the normal (MINA) account as fee-payer\r\n  * 2 none parties -- the Y token account of the user, the X token for the DEX\r\n  '), ('Trivo25', 'A rollup or potentially an application that batches payouts might involve multiple parties. 4+ parties permissioned by a proof'), ('Trivo25', 'However, some use cases might involve writing batching contracts, or ICO contracts, that send out batches of transfers (parties)'), ('mitschabaude', '* Attestation -- step 1: creating the on-chain verification (minimal case)\r\n  * 1 proof party -- the zkApp\r\n  * 1 signature party -- the user\r\n  \r\n* Attestation -- step 2: proving to a 3rd party that step 1 happened\r\n  * if the 3rd party is just a website -- no parties\r\n  * if the 3rd party is a zkApp: 1 proof party (the zkApp), 1 signature party (the user)'), ('mitschabaude', 'Final thoughts: I wouldn\'t set the most minimal possible implementations of any example as the benchmark, because that would mean there is no composability, no re-usability of other zkApps. For example\r\n* a DAO zkApp might want to see attestation that a user has completed a ""proof of humanity""\r\n* ... which is managed by another zkApp, which can provide the proof by looking up in its own sequence events / other off-chain storage\r\n* ... for which it might rely on a third zkApp, for example, a generic off-chain storage provider zkApp\r\n* that interaction with the DAO might also involve sending tokens, which would involve the token owner zkApp as a 4th party\r\n* and, the user might interact through a smart contract wallet, which is another proof party\r\n\r\nThat\'s 5 proof parties for being able to interact with that DAO. IMO, this is the kind of composability which has made Ethereum great, and which we should also strive for')]"
332,Deploy new version of SnarkyJS,jasongitmail,closed,,"[('mitschabaude', '- [ ] update changelog')]"
328,issue  when implementing sha256 ,zhfnjust,open,"


i am implementing sha256: 

now I have a version that validates normally

https://github.com/sCrypt-Inc/snarkyjs-sha256/commit/bd52bddff0958849876a8434bff1845901213a2c


But if we make a simple modification and comment out lines 254~257, that is, run one more line of code 259, the whole circuit will crash.

see this commit :

https://github.com/sCrypt-Inc/snarkyjs-sha256/commit/fcaefcc1139ce9a11d2329044c5b73cd15d8913f

","[('mitschabaude', 'Amazing that you got this far! Will check it out on monday'), ('zhfnjust', 'this is the error message: \r\n\r\n<img width=""1873"" alt=""image"" src=""https://user-images.githubusercontent.com/995909/183043802-00e1b3f0-fd3a-4d2e-ac8a-3d446c5fdd49.png"">\r\n'), ('mitschabaude', 'By the way, you get more useful error traces with\r\nnode --stack-trace-limit=1000'), ('zhfnjust', 'I think this may be because I implemented the not operation on Uint32, and the inversion of 1 becomes -2. Because sha256 needs to use xor and not. Please help to see if there is a problem with the implementation of these two functions, and if there is a better way to implement it'), ('zhfnjust', 'all strace:\r\n\r\n\r\n```\r\n\r\nRuntimeError: unreachable\r\n    at wasm://wasm/00b11606:wasm-function[782]:0x1fe03b\r\n    at wasm://wasm/00b11606:wasm-function[2036]:0x2a53dd\r\n    at wasm://wasm/00b11606:wasm-function[104]:0xaa5a1\r\n    at wasm://wasm/00b11606:wasm-function[448]:0x16cce0\r\n    at Object.module.exports.caml_pasta_fp_plonk_index_create (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/plonk_wasm.js:1856:14)\r\n    at caml_pasta_fp_plonk_index_create (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:3:12353)\r\n    at _f32_ (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2215:3669980)\r\n    at caml_call3 (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:4:693)\r\n    at R (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2215:3466003)\r\n    at caml_call1 (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:4:543)\r\n    at generate$0 (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2215:3894164)\r\n    at /Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2215:5060508\r\n    at caml_call_gen (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2:39192)\r\n    at Function.<anonymous> (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2:73570)\r\n    at Function.a.type.l.<computed> [as generateKeypair] (/Users/hh/code/zk/snarky-ex/node_modules/snarkyjs/dist/server/index.js:1:6157)\r\n    at main (file:///Users/hh/code/zk/snarky-ex/build/src/sha256.js:210:23)\r\n```'), ('zhfnjust', 'A version with simpler code implementation has just been submitted, which removes the for loop. but still has pb'), ('zhfnjust', 'Another possibility is that my circuit is triggering some limitation of the system'), ('zhfnjust', 'any update?'), ('zhfnjust', 'a  minimal reproducible example : https://github.com/sCrypt-Inc/snarkyjs-sha256/commit/33f89d1b868446f017e8303022524138b4a2c8de\r\n\r\nit just crashed when calling `generateKeypair()`, has nothing to do with proving.\r\n\r\nIf you comment the following line of code, `generateKeypair()` will run successfully\r\n\r\nhttps://github.com/sCrypt-Inc/snarkyjs-sha256/blob/master/src/sha256.ts#L121\r\n'), ('mitschabaude', ""Update: discussion on this was continued on discord. The issue turned out to be a limitation on circuit size, uncovered by this error message from kimchi:\r\n```\r\npanicked at 'add_lagrange_basis: Domain size 131072 larger than SRS size 65536'\r\n```\r\n\r\nTo uncover this error in snarkyjs, we needed to improve the stack trace, by printing error messages from Rust in the JS console: https://github.com/MinaProtocol/mina/pull/11644\r\nWith this PR merged, these changes are now available in the snarkyjs `main` branch: https://github.com/o1-labs/snarkyjs/pull/338\r\n""), ('xhliu', 'Our sha256 is finally working, thanks to your help! It has 58830 constraints.\r\n\r\nUnfortunately, we need double sha256, and it exceeded constraint limits of 2^16=65536. Any way to bump the limit or alternative to get around this limit?'), ('jackryanservia', 'Unfortunately, bumping up the constraint limit is not as simple as changing a hardcoded number somewhere in SnarkyJS, but you could use recursion! :) Try proving the first SHA-256 evaluation, then verifying that proof inside the proof where you do the second evaluation.'), ('xhliu', 'Hmm, 58k constraints is just for hashing one chunk. And a bitcoin transaction is at least 5 chunks (250 bytes: 1 input & 2 outputs). On top of that, we need to double hashing. A second recursion is gonna be very difficult, we need to break it into 5 smaller steps (5 chunks + second hashing) to fit in 2^16 constraint limit.')]"
320,how to get the preimage size for implementing  sha256,zhfnjust,closed,"hello , I am implementing sha256.


before that i should know the preimage size to do the padding.


```
  export class Sha256 extends Circuit {
    @circuitMain
    static main(preimage: Field, @public_ hash: Field) {

      let size = preimage.toBits().length

    }
  }
```

but when calling `toBits().length`, it returns `255` all the tme.


so any idea to get the preimage size?","[('mitschabaude', ""Is there anything wrong with using `255`? That's the (max) bit length of a `Field`. (Sorry I'm not familiar with the sha256 algorithm)""), ('zhfnjust', '`sha256` algorithm need to append some padding bytes according the `preimage` length. but in this case I have no way of knowing the real size of the `preimage`。'), ('zhfnjust', 'I also need to add a parameter `preimageSize: Field` to indicate.'), ('mitschabaude', ""You could do that, yeah! But I still don't get what's wrong with always using 255 as the length.\r\n\r\nEDIT: Is it a problem for sha256 if some significant bits of that 255 bits are zero? (this would surprise me, to be honest..)""), ('zhfnjust', 'another question:\r\n\r\n if i use slice()  on array when writing a circuit,  it crash right?\r\n\r\n<img width=""505"" alt=""image"" src=""https://user-images.githubusercontent.com/995909/182338879-dd1b9e51-da3a-42fe-8710-b46b1f1a0306.png"">\r\n'), ('mitschabaude', ""> if i use slice() on array when writing a circuit, it crash right?\r\n\r\nno! the code inside a circuit is normal JavaScript. Normal JS doesn't crash when you use slice on an array, except when that array is undefined or something like that.""), ('mitschabaude', ""Closing this issue, let's continue debugging in discord"")]"
319,Modify network state of local blockchain,mitschabaude,closed,,"[('mitschabaude', 'done')]"
318,Archive node implementation of `fetchEvents` and `fetchActions`,mitschabaude,closed,,"[('MartinMinkov', 'One thing to note: The archive node does not store the latest `k` blocks.\r\nAdditionally, sequence events can be complicated as they are not stored in the archive node either.'), ('MartinMinkov', 'Related: https://github.com/o1-labs/snarkyjs/issues/606')]"
317,zkApps testing for Berkeley Testnet,jasongitmail,open,,[]
316,"Update ""state"" portion of SnarkyJS docs",jasongitmail,closed,"Gregor mentioned this needs to be updated, presumably for preconditions. Consider just briefly mentioning it and linking to the preconditions section for actual explanation.","[('jasongitmail', 'Moved to docs repo at https://github.com/MinaProtocol/docs/issues/192')]"
315,zkApp CLI after Berkeley Testnet,jasongitmail,open,,[]
314,SnarkyJS after Berkeley Testnet,jasongitmail,open,,[]
313,Docs after Berkeley Testnet,jasongitmail,closed,,"[('barriebyron', 'closing since we have issues in the docs repo')]"
312,import `SelfProof` `ZkProgram` `verify` error,zhfnjust,closed,"hello, I can't run [program.ts](https://github.com/o1-labs/snarkyjs/blob/main/src/examples/program.ts)

<img width=""768"" alt=""image"" src=""https://user-images.githubusercontent.com/995909/182128061-b14fd9b4-b6e1-44b9-9bf0-680f11845ee4.png"">

i found this error:

```
Module '""snarkyjs""' has no exported member 'SelfProof'.ts(2305)
```

my project is created by **zkApp Cli**,  snarkyjs version is `0.4.4`","[('mitschabaude', ""this is expected, because proof recursion is not published to npm yet. Usually, the snarkyjs `main` branch will be ahead of the latest released version. So, you can't expect that all examples in snarkyjs run with the latest version."")]"
309,Make node version work with bindings to native Rust,mitschabaude,open,,"[('Trivo25', 'https://doc.rust-lang.org/nomicon/ffi.html')]"
308,"Build Application B - Events, Preconditions and Call Stack  and P0 test cases",ymekuria,closed,,[]
305,Simplify circuit value declaration in places which don't rely on decorator metadata,mitschabaude,open,,"[('mitschabaude', 'should be supported in ZkProgram')]"
303,zkApp composability RFC,mitschabaude,closed,"# zkApp composability RFC

""zkApp composability"" refers to the ability to call zkApp methods from other zkApp methods. Technically, it uses the `callData` field on the zkApp party to connect the result of the called zkApp to the circuit/proof of the caller zkApp.

An initial spec by @mrmr1993 laying out the ideas for how to use `callData` can be found here: https://o1-labs.github.io/snapps-txns-reference-impl/target/doc/snapps_txn_reference_impl/call_data/index.html

We propose the following API for snarkyjs:

## API

```ts
@method myMethod() {
  let calledContract = new CalledContract(address);
  let result = calledContract.calledMethod(arg);
  // .. do anything with result
}
```

That is, we can **just call another method** inside a smart contract method. That's the API 😃 

**NEW**: To enable returning a result to another zkApp, the result type must be annotated with a TS type:

```ts
class CalledContract extends SmartContract {
  @method calledMethod(arg: UInt64): Bool { // <-- HERE
     // ...
  }
}
```
The return type annotation is captured by the decorator (like the argument types), and supports all circuit values.

Since it is easy to miss adding this, we take care to catch the case that
* a method is called by another method, and returns something *else* than undefined
* BUT no return type annotation exists

In this case, the following error is thrown:
```
Error: To return a result from calledMethod() inside another zkApp, you need to declare the return type.
This can be done by annotating the type at the end of the function signature. For example:

@method calledMethod(): Field {
  // ...
}

Note: Only types built out of `Field` are valid return types. This includes snarkyjs primitive types and custom CircuitValues.
```

zkApp calls **can be arbitrarily nested**! So, the `calledMethod` above could itself call another method.
(In theory, a method could even call itself! But we would need logical branching to make that work -- right now, it can't *conditionally* call itself, so calling itself would cause infinite recursion.)

## How it works under the hood

At a high level, calling a zkApp does **not** mean that the called method is executed inside the caller's circuit. Instead, the callee should have its own party, with its own execution proof for the method that was called. This means that we have to be all the more careful to constrain the callee party in the caller's circuit, in a way that we fully prove the intended statement: ""I called this method, on this zkApp, with these inputs, and got this result"".

To make the caller prove that, we do the following:

* In the callee circuit, we compute the following hash, and store the result in the callee's `callData`:  
```ts
this.body.callData = Poseidon.hash([...inputs, ...outputs, methodIndex, blindingValue]);
 ```
--> `inputs` are the arguments of the method call, represented as an array of field elements
--> `outputs` is the return value of the method call, represented as an array of field elements
--> `methodIndex` identifies the method that is called, by an index starting with 0, among all the methods available on the called smart contract (the index is represented as a full `Field`)
--> `blindingValue` is a random `Field` that is made accessible to both the caller and callee circuits at proving time (it has the same value in both proofs!). In the circuit, `blindingValue` is represented as a witness with no further constraints.

* In the caller circuit, we witness the party of the callee, plus the result of hashing the callee's own children (= the `calls` field of the callee's public input), plus the return value of the called method. Then, in the caller circuit we perform the same hash as before and compare it to the callee's `callData`:
```ts
// ... witness `callee` and `outputs` ...
let callData = Poseidon.hash([...inputs, ...outputs, methodIndex, blindingValue]);
callee.body.callData.assertEquals(callData);
```
--> this check proves that we called a method with a particular index, with particular inputs and output. To also prove that we call a particular zkApp, we have to add more checks (see next bullet point)
--> the `blindingValue` is needed to keep the inputs and outputs private. Note that the `callData` is sent to the network as part of the transaction, so it is public. If it would contain a hash of just the inputs and outputs, those could potentially be guessed and the guess checked against the hash, ruining user privacy. Since guessing the `blindingValue` is not possible, our approach keeps user inputs private.

* In the caller's circuit, we also assert that the publicKey and tokenId on the callee are the ones provided by the user:
 ```ts
callee.body.publicKey.assertEquals(calleeInstance.self.body.publicKey);
callee.body.tokenId.assertEquals(calleeInstance.self.body.tokenId);
  ```  
--> these checks make sure that the child party in the transaction, which belongs to the callee, has to refer to the same account which is defined by `publicKey` and `tokenId`. Thus, we're proving that we're calling a particular zkApp.

And that's all we do under the hood when you call another zkApp!

An important thing to note is that we add stuff to the callee circuit, although the called method didn't specify that it can be called. To make that work, we in fact add that stuff to _every_ zkApp method. In particular, the `callData` field will always be populated, regardless of whether a zkApp is called or not.

Making all zkApps callable is a deliberate design decision. The alternative would be to add a special annotation, for example `@callableMethod` instead of `@method`, to tell snarkyjs that this method should add the `callData` computation to its circuit. That way, we would save a few constraints in methods that aren't callable. However, many zkApp developers would probably not consider the requirement of a special annotation at first, or overestimate the performance impact of adding it (it is really small, just 20-odd constraints for the extra Poseidon hash). To make the zkApp callable later, it would have to be re-deployed later. Also, we would have to ensure that a non-callable zkApp aren't called by accident, because that would leave the call inputs and output completely unconstrained, making the caller's proof spoof-able.

In my opinion, it's much better to spend a few constraints to make composability the default!

EDIT: Another decision I made is to not expose the callee's child parties to the caller's circuit. Instead, I just witness the relevant hash, leaving it up to the callee to do any checks on its children. The rough idea is that when you do a function call, you usually don't want to / shouldn't have to ""look inside"" that function and inspect inputs and outputs of nested function calls. I'm curious if there are considerations that I missed!","[('jasongitmail', ""> ```ts\r\n> @method myMethod() {\r\n>   let calledContract = new CalledContract(address);\r\n>   let result = calledContract.calledMethod(arg);\r\n>   // .. do anything with result\r\n> }\r\n> ```\r\n> That is, we can just call another method inside a smart contract method. That's the API 😃\r\n> \r\nNice :) \r\n\r\n> --> methodIndex identifies the method that is called, by an index starting with 0, among all the methods available on the called smart contract (the index is represented as a full Field)\r\n\r\n\r\nDo we think `methodIndex` is sufficient or should it be a `methodDigest`? If a digest, could it be computed at build time to have no performance implications anyway? I assume it could be\r\n\r\n> In my opinion, it's much better to spend a few constraints to make composability the default!\r\n\r\n +1 Reasonable first step and probably the right long term choice too\r\n""), ('MartinMinkov', 'Awesome work! A few quick clarifying questions for me :D \r\n\r\n> At a high level, calling a zkApp does not mean that the called method is executed inside the caller\'s circuit. Instead, the callee should have its own party, with its own execution proof for the method that was called. \r\n\r\nHow does one construct the party for the callee? Will users have to construct this value before calling into a method or will it be auto-generated in some way?\r\n\r\n> is check proves that we called a method with a particular index, with particular inputs and output. To also prove that we call a particular zkApp, we have to add more checks (see next bullet point)\r\n\r\nJust wanted to confirm my understanding that methods on a zkApp are stored in some sort of known order for `methodIndex` to be used. For example, if I\'m calling into a zkApp for a certain method, I would just reference it by the order in which all the methods are declared?\r\n\r\n> The rough idea is that when you do a function call, you usually don\'t want to / shouldn\'t have to ""look inside"" that function and inspect inputs and outputs of nested function calls. I\'m curious if there are considerations that I missed!\r\n\r\nI\'m wondering how this will affect token transfers in callable methods where one zkApp imposes some sort of strict layout of parties. As I understand it, a callee zkApp will be able to inspect the parties of its caller but not the other way around? If so, how does the callee have access to these parties?\r\n'), ('mitschabaude', ""> How does one construct the party for the callee? Will users have to construct this value before calling into a method or will it be auto-generated in some way?\r\n\r\nIt's autogenerated! Here is a full code example, there's no extra logic apart from calling the other zkapp: https://github.com/o1-labs/snarkyjs/blob/2b30db84f90ce7b1e0f13983ebf8353634213619/src/examples/zkapps/composability.ts\r\n\r\n> Just wanted to confirm my understanding that methods on a zkApp are stored in some sort of known order for methodIndex to be used.\r\n\r\nYes, the methods are stored in a fixed order, and that order is also baked into the verification key when compiling. Order depends on the order that the `@method` decorators are called in, but that's an implementation detail\r\n\r\n> I'm wondering how this will affect token transfers in callable methods where one zkApp imposes some sort of strict layout of parties. As I understand it, a callee zkApp will be able to inspect the parties of its caller but not the other way around? If so, how does the callee have access to these parties?\r\n\r\nYes, for tokens the parties relationship between caller and callee is exactly reversed.. maybe we have to find a different API for calling token contracts, where we pass some sort of callback. In any case, as Matt pointed out on slack, for tokens the token contract actually has to inspect all the children's children etc, so that they can't transfer tokens without violating the token contract's rules. One simple (but probably too limiting?) way of achieving that would be to require that a token contract's children have no children themselves""), ('mitschabaude', '> Do we think methodIndex is sufficient or should it be a methodDigest? If a digest, could it be computed at build time to have no performance implications anyway? I assume it could be\r\n\r\nThat\'s an excellent question! We should really discuss what behavior we want in the case a called zkApp updates its verification key. I see two possibilities:\r\n\r\n1. The intention of the caller is: ""I call this particular method on this particular zkApp"". If the called zkApp updates its methods, by changing the verification key, the caller zkApp still continues to work without updating, and just uses the updated method on the callee contract. If the update on the called zkApp is malicious, users might be at risk immediately. (EDIT: only if the code that\'s shipped to users _is_ updated though. Because all execution is still on the user side, also of the callee, so its client-side JS has to agree with its verification key)\r\n\r\n2. The intention of the caller is: ""I call this particular method on this particular zkApp, and it has to be at this particular snapshot"". If the called zkApp changes its verification key, the caller zkApp will stop working until it is updated as well. This also means that a malicious update which affects the method digest of the called circuit can be caught by a diligent developer, before it can affect users of the caller zkApp.\r\n\r\nWith taking the `methodIndex` as identifier, I was going for behavior (1). However, now I no longer think that the index alone does the best job there, because it can happen that the callee is updated by inserting another `@method`, and then the index would no longer point at the intended function. That\'s why in the PR, I now implemented (1) as follows: Instead of the method index, I take the string `""${methodIndex};${methodName}""` and convert that to a `Field` (using `Encoding.stringToFields`). I think this captures the intention of calling a method with a particular name.\r\n\r\nWith regards to a possible implementation of (2), it _should_ be possible to create some sort of digest of the callee method at compile time. We\'d want to include that method digest as a constant in the callee circuit though, which creates a cyclic dependency: We can\'t digest the method circuit _before_ using that digest in the circuit itself. I assume we can come up with a reasonable workaround though. Like, create a digest of the same circuit, with the constant which represents the method digest replaced by zero.\r\n\r\n**The main question to resolve, however, is which behavior we want: (1) or (2)**. This is a nuanced discussion and inputs are highly welcome! I\'m _slightly_ tending to (1), for the following reason: There are many ways of launching a supply chain attack on dependants of your snarkyjs smart contract _without_ affecting the method digest. For example, an npm package that is included which contains the callee smart contact could modify snarkyjs, such that the method digest doesn\'t change while the real behavior and verification key do change in ways that harm users. Besides that, there are probably 100 ways how an imported npm package could pwn the developers and users of the caller contract. So, IMO failing on an update of the method digest makes the developer experience of calling other zkApps much worse without notably improving the security of users; it might even give a false sense of security. _Real_ diligence would mean restricting updates to the entire JS code contained in called zkApp packages. This can be done, for example, by fixing the version of the dependency in `package.json` (not allowing patch release updates). This also achieves what fixing the method digest in the circuit gives you -- users can\'t create proofs for the callee from an outdated verification key -- but in addition is also blocking all those other ways a malicious package update could create harm.'), ('mitschabaude', 'I have another argument for not forcing the caller to update the verification key when the callee changes: A substantial fraction of zkApps might want to set their permissions so that their verification key is non-updatable -- to remove any doubts about the trustworthiness of the zkApp. Making this decision of freezing your zkApp would be made near impossible if you have dependencies that can update, if this would break your zkApp forever.'), ('ymekuria', ""> ```ts\r\n> @method myMethod() {\r\n>   let calledContract = new CalledContract(address);\r\n>   let result = calledContract.calledMethod(arg);\r\n>   // .. do anything with result\r\n> }\r\n> ```\r\n\r\nThis simple API is great! \r\n\r\n> Making all zkApps callable is a deliberate design decision.\r\n\r\nThis feels like the right approach.\r\n\r\n> For example, an npm package that is included which contains the callee smart contact could modify snarkyjs, such that the method digest doesn't change while the real behavior and verification key do change in ways that harm users. Besides that, there are probably 100 ways how an imported npm package could pwn the developers and users of the caller contract.\r\n\r\nThis made me think about how users will use this API to interact with other contracts. In your opinion @mitschabaude or anyone else, do you think composing smart contracts by importing them as npm packages(similar to how we guide to add them to a UI) will enable developers to easily use this api and be a good experience?\r\n""), ('mitschabaude', '> do you think composing smart contracts by importing them as npm packages(similar to how we guide to add them to a UI) will enable developers to easily use this api and be a good experience?\r\n\r\nYeah I think this would give a good experience!\r\n\r\nSlightly tangential: I wonder if long-term, we should come up with something else than npm for dependency management, like leveraging the on-chain `zkappUri` to store the smart contract code plus metadata, which could potentially be made more secure / transparent / targeted to smart contract development than npm.\r\n\r\nBut it _is_ nice that we already have a package manager which everyone knows how to use! So maybe the zkapp metadata idea is complementary to that and not replacing it.'), ('ymekuria', '\r\n\r\n\r\n\r\n> Slightly tangential: I wonder if long-term, we should come up with something else than npm for dependency management, like leveraging the on-chain `zkappUri` to store the smart contract code plus metadata, which could potentially be made more secure / transparent / targeted to smart contract development than npm.\r\n\r\nI like the potential of using the `zkappUri` to store contract code in the future. We should all discuss this possibility further.'), ('mimoo', 'This is a really well written doc! I have some clarification questions on the RFC:\r\n\r\n> party\r\n\r\nI\'m a huge noob but I still don\'t really get why it\'s important that the callee has its own party. Is there some doc on ""parties"" in zkapps somewhere?\r\n\r\n> plus the result of hashing the callee\'s own children (= the calls field of the callee\'s public input)\r\n\r\nwhat are the ""children"" of the callee?\r\n\r\nalso, what is the ramification of not including the verifier index/key in the hash we\'re doing on both sides? I\'m wondering how things look like in terms of proofs when we call another zkapp, do we first create a proof running the other zkapp with a specific set of inputs (and the public input of the callee zkapp contains both the output and the calldata) and then verify that proof + use its public input within the caller zkapp? If this is the case then aren\'t we limited in the number of other zkapp calls we do?'), ('mimoo', 'ok reading the comments I\'m wondering if your `""${methodIndex};${methodName}""` is:\r\n\r\n* _resistant to simple updates of the callee_: if the methodIndex change, then it won\'t work anymore\r\n* _enough against breaking changes_: it sounds like the callee should at least keep the same argument types and return type. This is what solidity does IIRC when it computes its method id (it\'s a hash over the name of the function, and the types of its arguments and return value)\r\n\r\nso considering that, why not compute `methodIndex` like Ethereum does (and include name + types of arguments + type of return value)?'), ('mitschabaude', '> I\'m a huge noob but I still don\'t really get why it\'s important that the callee has its own party. Is there some doc on ""parties"" in zkapps somewhere?\r\n\r\nA ""party"" is just an _account update_: A set of changes and events to a single account, authorized by a proof which has to verify against that account\'s verification key. The callee is a smart contract method, so by design it creates such an account update. So, calling another zkApp is about much more than obtaining a return value and doing something with it -- it\'s also about composing smart contracts, which can move balances, change on-chain state etc. For all that, the callee has to include its own account update.\r\n\r\nI think the currently best general doc on parties is https://o1-labs.github.io/snapps-txns-reference-impl/target/doc/snapps_txn_reference_impl/index.html\r\n \r\n> > plus the result of hashing the callee\'s own children (= the calls field of the callee\'s public input)\r\n> \r\n> what are the ""children"" of the callee?\r\n\r\nThe account updates of a transaction form a nested structure -- they\'re a list of trees (a ""forest""). In our example, the caller is a top-level element of that list, and the callee is one of the caller\'s children. But the callee also has it\'s _own_ list of children (which could be empty).\r\n\r\nI\'ll try to explain what the purpose of this nesting is. It has to do with the public input of a zkApp proof.\r\n\r\nIn a zkApp proof, the public input consists of **two field elements**:\r\n1) a hash of the zkApp\'s own account update\r\n2) a hash of the entire tree of account updates below the zkApp\'s own update\r\n\r\nSo, this is the information we can reason about / make assertions about in a zkApp proof. In particular, a zkApp proof will reason about its own account update, and at the end, it will hash its update (in the circuit) and assert that it\'s equal to the first public input. This is how the account update gets authorized by the proof.\r\n\r\nSimilarly, you can authorize whatever the account updates below you in your tree are doing -- your children, their children, etc. Because you can hash them in your circuit and compare the result to your second public input!\r\n\r\nSo that\'s the purpose of nesting account updates -- enabling some zkApps to make statements about what other zkApps are doing. In this composability API, the caller has to make statements about the callee\'s `callData`, `publicKey` and `tokenId`, which are all contained in the callee\'s account update; that\'s why we make the callee a child of the caller. What I\'m saying in the quote above is just that we don\'t care about making assertions about the callee\'s own children / the account updates deeper down in the tree.\r\n\r\n> also, what is the ramification of not including the verifier index/key in the hash we\'re doing on both sides? I\'m wondering how things look like in terms of proofs when we call another zkapp, do we first create a proof running the other zkapp with a specific set of inputs (and the public input of the callee zkapp contains both the output and the calldata) and then verify that proof + use its public input within the caller zkapp? If this is the case then aren\'t we limited in the number of other zkapp calls we do?\r\n\r\nWe _don\'t_ verify the callee\'s proof in the caller circuit. This is an alternative model, which is lighter-weight on the client and heavier on the server: Both the callee\'s and caller\'s proof have to be verified independently by the Mina node. They\'re just connected via their public inputs.\r\n\r\nIn particular, the callee\'s verification key is not a dependency for the caller; it can be changed without changing the caller (on-chain). However, the client-side code that produces the caller + callee proof _has_ to be up to date with the callee\'s verification key, of course, otherwise we couldn\'t create its proof (or, we\'d create a proof that fails).'), ('mitschabaude', '> ok reading the comments I\'m wondering if your `""${methodIndex};${methodName}""` is:\r\n> \r\n>     * _resistant to simple updates of the callee_: if the methodIndex change, then it won\'t work anymore\r\n> \r\n>     * _enough against breaking changes_: it sounds like the callee should at least keep the same argument types and return type. This is what solidity does IIRC when it computes its method id (it\'s a hash over the name of the function, and the types of its arguments and return value)\r\n> \r\n> \r\n> so considering that, why not compute `methodIndex` like Ethereum does (and include name + types of arguments + type of return value)?\r\n\r\nThat\'s very good input! I agree that the `methodIndex` is unnecessarily constraining, I\'ll leave it out and just include the full name converted to a list of field elements (previously I cut if off to one field element, that\'s why I thought I need the index for uniqueness, but there\'s no reason to restrict the name to one field element.)\r\n\r\nRe types: Right now, at least the cumulative length in field elements of argument + return types is baked into the hash. However, this is very ambiguous. I propose that we do the following instead:\r\n* convert each argument $i$ to an array of field elements $X_i$ with length $n_i$\r\n* let the argument\'s hash input be $X_a := [n_0, ... X_0, n_1,... X_1, ...]$\r\n* let the total argument length be $n_a = n_0 + n_1 + ...$ (can be zero)\r\n* similarly, convert the return value to fields $X_r$ with length $n_r$ (can be zero).\r\n* let the method id be a list of field elements $X_m$ with length $n_m$\r\n* let $b$ be the `blindingValue`\r\n* compute $\\mathrm{hash}([n_a, ...X_a, n_r, ...X_r, n_m, ...X_m, b])$\r\n\r\nBy including the lengths in the hash, we fix the number of arguments, length of each argument in fields, length of return value in fields, and the method name. (I learned this from your book @mimoo 😁 )\r\n\r\nI don\'t think we can/should attach richer information than ""length in fields"" about any type, because a type doesn\'t necessarily have a name attached to it. From the circuit point of view, types really _are_ a certain fields layout, plus some associated assertions that are added to the circuit, like the booleanness check for `Bool`. I don\'t think there\'s a good way of serializing the assertions though, fields layout seems to do a good job.'), ('mimoo', '> a hash of the zkApp\'s own account update\r\n> a hash of the entire tree of account updates below the zkApp\'s own update\r\n\r\ninteresting, is there a limit in account updates per transactions, because it takes room in a public input somewhere or something? Or perhaps this is information that\'s used in a proof and discarded? I guess I should just read the spec you linked to as this is starting to get unrelated :)\r\n\r\n>  In this composability API, the caller has to make statements about the callee\'s callData, publicKey and tokenId\r\n\r\nI\'m guessing the `tokenId` of a zkapp is passed as public input, so it\'s important that we\'re in a model where the nested zkapp proof is verifier by the network and calls are glued by the network. (Otherwise I might lie about the callee\'s `tokenId` and they might lie about it too right?)\r\n\r\n>  (I learned this from your book @mimoo 😁 )\r\n\r\nwow nice :D\r\n\r\n> I don\'t think we can/should attach richer information than ""length in fields"" about any type, because a type doesn\'t necessarily have a name attached to it. From the circuit point of view, types really are a certain fields layout, plus some associated assertions that are added to the circuit, like the booleanness check for Bool. I don\'t think there\'s a good way of serializing the assertions though, fields layout seems to do a good job.\r\n\r\nThat\'s true, but they also don\'t have several arguments or even a return value after being compiled, it\'s just one single array of field elements. So IIUC, the decision is about where we want to put the line and break when changes occur. \r\n\r\nI agree though that type names are probably going to be a pain if you\'re in a situation where you call a zkapp written in snarkyjs that calls a zkapp written in another language whenre type names have a different spelling convention.\r\n\r\nIn general the proposition looks good to me!'), ('mitschabaude', ""> interesting, is there a limit in account updates per transactions, because it takes room in a public input somewhere or something?\r\n\r\nthere's no limit in general / on the protocol side, because the public input is just the two hashes, i.e. it has a fixed size of 2 field elements.\r\n\r\nlimits on children of a particular zkapp could be caused if the zkapp fully (re-)computes those hashes in its circuit. for the composability API, we don't make any assumptions about the callee's children, since we do not recompute its children's hashes in the caller circuit.""), ('bkase', 'Just catching up here -- (1) makes sense to me; as you\'ve said, clients can ask dependencies to become non-upgradable if they are worried by this. Plus upgradeability of dependent contract calls enables libraries to publish security fixes.\r\n\r\nAlso the security tradeoffs with the latest ""smart contract method name mangling"" algorithm sound good to me too 👍 ')]"
301,Translate `LocalBlockchain` errors from `apply_parties_unchecked` to excellent user-facing error messages,mitschabaude,open,"Example error message:
```
Error: [[],[[""Account_nonce_precondition_unsatisfied""]],[]]
```

This error is already not the worst and usually helps seasoned snarkyjs developers with figuring out the issue.
However, it could be made **more** helpful by 
* translating it to an english sentence instead of a construct involving nested `[]` brackets
* saying _which_ party (i.e., which part of the transaction) has the wrong account nonce. this information should be available on the OCaml side, and you can even guess that it's the second party from the layout of `[]` brackets above :D
* saying what people could try to fix or at least debug this, e.g. manually incrementing some nonce to the correct value should be a straight-forward quick fix for this issue",[]
300,Token transfers between zkApps,mitschabaude,closed,"The `token()` APIs `burn` and `send` should enable authorizing token sending with a proof

Initial discussion here: https://github.com/o1-labs/snarkyjs/pull/273#discussion_r927860973","[('MartinMinkov', ""# Current Approach\r\n\r\nTo serve as a point of discussion and documentation, we outline the current approach being used to implement token transfers between zkApps. \r\n\r\nWe want to be able to support zkApp's to transfer tokens with proofs instead of just signatures. The reason for this is to support one zkApp that is holding a custom token to transfer it without requiring a signature from the token owner zkApp. Currently, there is no way to support this since the zkApp that wants to transfer a custom token must get authorization from the token owner zkApp, and requiring a signature does not work from a programmatic standpoint. For this sort of interaction, we need to enable token transfers to be authorized by proofs from the token owner since ~~those can be generated asynchronously without requiring a signature from a private key.~~ we need the token owner to inspect child parties that use it's custom token id.\r\n\r\nTo solve this issue, we present a new class to be added to SnarkyJS called `Callback` which will represent a callback method that a child zkApp can create and then pass into the token owner contract so that a transfer can be authorized. \r\n\r\n## Using a Callback to generate proofs\r\n\r\nThe only way to generate proofs for zkApps is via a `@method` declaration on the Smart Contract. This is because we need to compile/generate the verification key first before creating proofs for a specific zkApp. To get the verification key of a zkApp, we must analyze all methods that a zkApp supports and take that information into account when compiling.\r\n\r\nWith this in mind, we can declare a new class called `Callback` which holds a function as well as parameters to authorize to the callback. The intention of the usage of this class is to use this `Callback` class to store a smart contract method on a child zkApp that we wish to get authorization for from the parent zkApp. Once we store this child method in the Callback, we can then pass the callback into the parent zkApp where the parent zkApp will run the contained child method to generate the Parties the child wants to create. This enables the parent zkApp to inspect the Parties layout and enforce certain conditions if the zkApp developer wishes to do so.\r\n\r\n### Code Example\r\nLet's assume we have a parent token contract called `TokenContract` defined as below:\r\n```ts\r\nclass TokenContract extends SmartContract {\r\n  ...\r\n  @method sendTokens(\r\n    senderAddress: PublicKey,\r\n    receiverAddress: PublicKey,\r\n    callback: Experimental.Callback<any>\r\n  ) {\r\n    let senderParty = Experimental.partyFromCallback(this, callback);\r\n    let amount = UInt64.from(1_000);\r\n    let negativeAmount = Int64.fromObject(senderParty.body.balanceChange);\r\n    negativeAmount.assertEquals(Int64.from(amount).neg());\r\n    let tokenId = this.experimental.token.id;\r\n    senderParty.body.tokenId.assertEquals(tokenId);\r\n    senderParty.body.publicKey.assertEquals(senderAddress);\r\n    let receiverParty = Experimental.createChildParty(\r\n      this.self,\r\n      receiverAddress,\r\n      { caller: tokenId, tokenId }\r\n    );\r\n    receiverParty.balance.addInPlace(amount);\r\n  }\r\n}\r\n```\r\n\r\nYou will notice that the `sendTokens` method takes a new parameter called `c` which is the Callback. The code below is how a child zkApp will initialize and interact with this Callback.\r\n\r\n```ts\r\nclass ZkAppB extends SmartContract {\r\n  // A method to send custom tokens derived from `TokenContract`\r\n  @method authorizeSend() {\r\n    let amount = UInt64.from(1_000);\r\n    this.balance.subInPlace(amount);\r\n  }\r\n}\r\n...\r\nlet tx = await Local.transaction(feePayer, () => {\r\nlet authorizeSendingCallback = new Experimental.Callback(\r\n    zkAppC,\r\n    'authorizeSend',\r\n    []\r\n  );\r\n  // we call the token contract with the callback\r\n  tokenZkApp.sendTokens(zkAppCAddress, tokenAccount1, authorizeSendingCallback);\r\n});\r\nawait tx.prove();\r\n```\r\n\r\nThis callback will be run by the parent zkApp and then authorize the callback with proof. The child zkApp can then call the parent zkApp method `sendTokens` specifying its own method as a callback to do inside a transaction block. Then, when the transaction block is completed, we can prove the transaction as normal methods on a zkApp. This concludes the flow of how this feature is envisioned.\r\n\r\n## Deploying a child with a custom token ID\r\nAnother change to be added is to make a tokenId an optional parameter to be passed into a `SmartContract` constructor. This will enable a zkApp to be deployed with a specific tokenId it can reason about and it hides the implementation details of dealing with the tokenId in the parties from the developer. All the developer has to do is get the token id of the parent contract it wishes to interact with and pass that into its constructor like so:\r\n\r\n```ts\r\nlet tokenZkApp = new TokenContract(tokenZkAppAddress);\r\nlet tokenId = tokenZkApp.token().id;\r\nlet zkAppB = new ZkAppB(zkAppBAddress, tokenId);\r\n```\r\n\r\nOne requirement that is imposed on the child zkApp when they deploy with a custom token id is that they must get authorization from the parent zkApp. Concretely, this means we cannot deploy as normal if we specify a different custom token id since we would need permissions from the parent zkApp just like regular custom token interactions. To get around this, we will add a new type of `deploy` method which handles this specific case of a zkApp wishing to specify a different token id and authorize the child with proof. This custom deployment would be handled by the parent zkApp by adding an additional `@method` in it's declaration like so:\r\n\r\n```ts\r\nclass TokenContract extends SmartContract {\r\n  ...\r\n  @method tokenDeploy(deployer: PrivateKey) {\r\n    // Authorize a child zkApp using TokenContract's custom token id to be deployed\r\n    super.token().deploy({ deployer });\r\n  }\r\n}\r\n...\r\nlet tx = await Local.transaction(feePayer, () => {\r\n  Party.fundNewAccount(feePayer);\r\n  tokenZkApp.tokenDeploy(zkAppBKey);\r\n});\r\ntx.sign([zkAppBKey]);\r\ntx.send();\r\n```\r\n\r\nAs a final thing to note, this means that each instantiation of a zkApp with a different token id must be deployed for each unique token id. The same zkApp code can be re-used but must be initialized with a different token id and redeployed. ""), ('mrmr1993', ""> For this sort of interaction, we need to enable token transfers to be authorized by proofs from the token owner since those can be generated asynchronously without requiring a signature from a private key.\r\n\r\nAm I correct in reading that this is essentially a workaround for 'proving is async, but circuits are not'? If so, it seems like we should probably just fix that.""), ('mitschabaude', ""@MartinMinkov @mrmr1993 I think the description is a bit inaccurate which might lead to confusion. We can already create proofs by the token owner /  token contract, what we're missing is a way to add a proof authorization from the sender - a zkApp that wants to send tokens.\r\n\r\nWe need a callback for that since the token contract wants to inspect its child parties, and the sender-zkApp needs to have freedom in what exact party it creates. So, for the token contract to support generic sender-zkApps, it has to be given a way to witness a party whose precise structure it doesn't know, and make assertions about it. That's what the callback is for (it's creating the sender-zkApp party, to be witnessed and inpected by the token contract)"")]"
299,Bring efficient range check gates to snarkyjs,mitschabaude,open,"Proof systems PR (merged): https://github.com/o1-labs/proof-systems/pull/620
","[('mitschabaude', 'Bumped estimate to 13 days, since this also means lookup tables have to be integrated in snarky (ocaml)')]"
298,Use compressed representation for `PublicKey`,mitschabaude,closed,"In the OCaml in-snark representation, which also has to be used in snarkyjs for hashing a party into the public input (which has to be the same on both sides), a public key is represented in ""compressed"" form: `{x: Field, yIsOdd: Bool}`

In snarkyjs however, we use the ""full"" form `{x: Field, y: Field}`. (The full `y` coordinate can be re-derived from the compressed form, so both forms can be converted into another.)

Conversion from full to compressed is pretty expensive in a circuit and now has to be done in *every single zkapp*. In addition, zkapps that witness a party (when calling other zkapps) in addition have to do the other direction (compressed -> full), which has the same high cost.

To save these costs, we should use the compressed representation by default in snarkyjs. It then would have to be converted to/from the full form for some common operations, like deriving a PublicKey from a PrivateKey, and verifying a signature, but it would probably happen much less often than now.",[]
291,Improve SnarkyJS README,jasongitmail,closed,"From Slack convo:
flesh out the [SnarkyJS README](https://github.com/o1-labs/snarkyjs/blob/main/README.md) with 
- a marketing-focused overview
- bullet points of benefits or key features to impart understanding quickly

In a ‘Ceviche multi-chain world’ where the README becomes a primary entry point for users, rather than the Mina docs, this content and context all become even more important.

_Future: We’ll add a brand graphic to the README after the rename is finalized._ ","[('barriebyron', 'We have more work to do, #866 is just a bare-bones starter update.\r\n\r\nFuture updates to provide:\r\n- Marketing-focused overview\r\n- Bullet points of benefits and key features to impart understanding quickly'), ('barriebyron', ""Let's identify and answer these questions so that the updated README can inform the world about the awesome SnarkyJS uses:\r\n\r\n1. who needs to know about SnarkyJS? \r\n2. what are the top 5 benefits of using SnarkyJS? \r\n3. what problems does SnarkyJS solve?\r\n4. what is the call to action for this README? \r\n5. what is a compelling use case for SnarkyJS? \r\n6. what is the question you get asked the most about SnarkyJS?""), ('barriebyron', 'Content inspiration\r\n- include some code examples, so people can get a feel for what snarkyjs is like @mitschabaude \r\n- call to action IMO is starting a zkapp project with the zkapp cli, or try out snarkyjs in another way @mitschabaude '), ('stevenpack', ""Some things I'd like to see (based on some of my favorite READMEs like https://github.com/BurntSushi/ripgrep)\r\n\r\n- Badges (for CI etc.) if we have them\r\n- Link to change log\r\n- Link to contributing doc\r\n- Link to docs (on the MF site)\r\n- Bonus: A screen recording converted to a gif that shows how easy it is to download, scaffold a project and start building.""), ('mitschabaude', '> Bonus: A screen recording converted to a gif that shows how easy it is to download, scaffold a project and start building.\r\n\r\nGreat idea!'), ('barriebyron', ""SnarkyJS is the best zero-knowledge SDK (gleaned from https://www.notion.so/minaprotocol/SnarkyJS-Feedback-14797844e7144d15bbb35fda7375c5e5 \r\n\r\nSnarkyJS is the best zero-knowledge SDK\r\n- Code is aesthetic and readable\r\n- chaining API\r\n- Separation of TypeScript and SnarkyJS\r\n- Convenient stuff when you need it and out of the way when you don't""), ('barriebyron', 'Still lots of work to do, iteration in https://github.com/o1-labs/snarkyjs/pull/886 before the next release so that npm is updated https://www.npmjs.com/package/snarkyjs')]"
290,Deploy should auto-initialize state with proofs,bkase,open,"Deploy auto-initializing state with proofs ensures that the contract can _only_ be updated by proofs and not be cheated by the owner of the private key. We should have a way to opt-out of this for advanced users, but that can come later.","[('mitschabaude', 'this is a medium term item that has to be discussed before moving on')]"
289,Publish Sudoku to NPM,jasongitmail,closed,,[]
286,Add an optional string parameter to any `assert` methods to indicate an error message,MartinMinkov,closed,"# Description
Taking motivation from[ Solidity's function modifier](https://solidity-by-example.org/function-modifier/) to allow failure messages, it would be nice if any sort of `assert` method in SnarkyJS also supported optional strings that were shown to the user when there is a failure. This would communicate the developer's intent easier and would be a nice feature to have.

# Example
Assertion methods are implemented for a variety of classes for SnarkyJS. For example, one such class is the `Field` class. The `Field` class exposes the following assertion methods:

`assertLt`
`assertLte`
`assertGt`
`assertGte`
`assertEquals`
...

For any of these assert methods, we can add an optional string parameter that indicates an error message to be shown if an error is thrown. 

The function signature for `assertLt` is 
```ts
assertLt(y: Field | number | string | boolean): void;
```

We can change the signature to
```ts
assertLt(y: Field | number | string | boolean, message?: string): void;
```
and print the message passed in if an error has occurred. We should change all assertion methods for all classes to behave in such a way.",[]
284,Local blockchain implementation for `fetchEvents` and `fetchSequenceEvents`,bkase,closed,"These should pull from some local store of events/sequence events for the purpose of writing tests.

Spec / mini-RFC coming soon.",[]
283,Flesh out Application A and P0 test cases,bkase,closed,Flesh out Application A and the P0 test cases that are identified for it. Specifics still being iterated on.,[]
282,Scaffold for zkApp VM application test,bkase,closed,"Build the scaffold for ""Application A"" of the zkapp VM application tests and sort out decisions related to where these should live in the repository and how the tests should behave and execute.

Specifically:

- [ ] Add the application A example to the repo (just stub everything for now)
- [ ] Add one example integration test (just stub it for now to always pass)
- [ ] Add the integration test to the GitHub Actions so these tests run on every PR

These tasks will imply decisions on several things which should be rationalized via an RFC-issue if it is large enough or a sentence or two in the PR.

These decisions include (but may not be limited to):

- [ ] Where should these zkApp application examples live?
- [ ] Where should tests for these applications live?
- [ ] How should these tests be written? How are they executed?
- [ ] What's the pattern for adding tests to GitHub Actions
",[]
281,Implement API for sending MINA tokens via Party transactions,MartinMinkov,closed,"# Description
During an internal discussion of the [Tokens RFC](https://github.com/o1-labs/snarkyjs/issues/233), the product team decided to not include an API for transfers of MINA for zkApps. We instead decided to punt on this for a later PR as we wanted more time to decide on an easy to use API.

Once we have a good design in place for tokens, this should be implemented as part of this issue.","[('MartinMinkov', ""# RFC\r\n\r\nWe wish to expose an intuitive and easy-to-use API for supporting sending MINA in party transfers. Adding transactions for MINA payments was discussed in #233 but was cut out of scope and should be implemented in another PR. Here, we propose an API that zkApp developers can use to support transactions with default MINA that is separate from the custom tokens API.\r\n\r\n## Sending inside a zkApp method\r\nAn easy-to-use API should be exposed on the zkApp instance inside a method's execution. For example, a method name such as `send` can be attached to the `this` property inside a zkApp method. The send method will take as input an address to send MINA to as the receiver and the amount to send. The following code would be an example of such a method:\r\n\r\n```ts\r\n@method sendMINATokens(receiverAddress: PublicKey) {\r\n    this.send({\r\n        to: receiverAddress,\r\n        amount: 10e9\r\n    })\r\n}\r\n```\r\nWhen the `sendMINATokens` method is invoked, the method will execute `this.send` with the specified properties. `this.send` will construct the parties necessary to represent a valid balance change in both the zkApp balance and the receiverAddress. \r\n\r\n\r\n## Sending using a constructed Party\r\n\r\nIn addition to exposing a way to send MINA tokens on a zkApp method execution, we would also like to support generating the parties structure by the zkApp developer outside of a zkApp. This can be done by adding a `send` method to the `Party` class inside SnarkyJS. This `send` method will behave similarly to the zkApp version by taking in an address to send to as the receiver and the amount. The following code would be an example of such method:\r\n\r\n```ts\r\nlet party = Party.createSigned(privateKey); // create party from a private key\r\nlet party2 = Party.createUnsigned(publicKey); // Can also create a party from a public key but require authorization later before txn is submitted\r\nparty.send({ to: someAddress, amount: 10e9 }); // send MINA from the party's account\r\n```\r\nThis way to construct a signed party and specify a send operation can be done inside a transaction block. This means that sending MINA in SnarkyJS isn't dependent on interacting with a zkApp and can be done anywhere a zkApp uses it.\r\n\r\nThe combination of these two approaches (inside a zkApp and with a signed party) should cover the primary use cases that a zkApp developer needs to send MINA in an easy-to-use way. \r\n\r\n## Testing\r\n\r\nA suite of unit tests should verify that these methods behave correctly. The following test cases should cover these behaviors:\r\nA zkApp successfully sends tokens when invoked in a smart contract method\r\nA zkApp cannot send an amount greater than its current balance\r\nA signed party sends MINA when used inside a transaction block\r\nA signed party cannot send an amount greater than its current balance""), ('Trivo25', 'clean and easy to use :) '), ('mitschabaude', ""this looks great to me!\r\n\r\nsomething I think we still have to improve is the naming of `Party.createSigned`, but that's an independent issue.""), ('ymekuria', 'This is a very intuitive API. Nice work Martin!')]"
277,Party.setValue is a confusing API,bkase,closed,We should set values in the party structure in a cleaner way,"[('mitschabaude', ""how about this: we extend the `this.account` fields with `.set()` methods, e.g. `this.account.delegate.set(delegate)`.\r\nwe could add new fields for the ones that aren't preconditions, e.g. `this.account.permissions`""), ('mitschabaude', 'dupe of #186')]"
276,"Enforce limits on # of parties, events, & sequence events to match those defined by the protocol ",jasongitmail,closed,,"[('jasongitmail', 'Ideally we throw a compile time error'), ('Comdex', ""Hey! I don't know whether it is appropriate to ask here, because I only found this relevant open issue. How many fields is the limit size of each event and sequence event? And what is the total limit size of events and sequence events in each transaction?""), ('mitschabaude', ""there's no extra limit for the number of fields in one (sequence) event, but there'll be a limit on the total number of all fields in all events / sequence events. We're still in the process of deciding the exact number, but it'll be about ~20-30 I think""), ('Comdex', ""> there's no extra limit for the number of fields in one (sequence) event, but there'll be a limit on the total number of all fields in all events / sequence events. We're still in the process of deciding the exact number, but it'll be about ~20-30 I think\r\n\r\nPersonally, I prefer this limit >= 30, which I think would be more friendly to some privacy use cases based on the UTXO model, such as coin mixers.""), ('mitschabaude', 'Most of these limits will be fairly tight, because the time budget for snark workers to create proofs becomes much tighter with zkApps'), ('jasongitmail', ""Gregor explained well. We're trying to be conservative initially and then can potentially increase limits over time ""), ('bkase', 'Ask @deepthiskumar for the formula for the limits and translate the formula to the client side'), ('bkase', ""The constants will probably change, but the formula probably won't change much"")]"
275,Use public output for account update returned from a zkApp method,mitschabaude,open,"This is the snarkyjs equivalent of https://github.com/MinaProtocol/mina/issues/10747
So it's supported by Pickles, just needs to be used by snarkyjs.
",[]
271,Don't increment nonces on accounts that are the fee payer,mitschabaude,closed,"This is an important fix because with some upcoming changes on the protocol side, transactions will likely fail (or partially fail, which is even worse) if a fee payer is present in the other parties and also increments its nonce in that other party.

Here's how we could handle creation of a signed Party:

* see if there's a current transaction that has a fee payer
* if yes, look if our new party is the same account
* if yes, useFullCommitment. If no, incrementNonce

And here's how we should handle adding a fee payer to an existing transaction:
(this needs to happen in mina-signer as well! cc @MartinMinkov)

* see if the fee payer account is already present in other parties
* if yes, see if that other party increments its nonce
* if yes, throw an error.
* add the fee payer as usual

We also have to adapt the zkapp CLI, because in there we manually increment the nonce on the zkapp account which is also the fee payer. We should useFullCommitment instead.","[('jasongitmail', '- [x] Update SnarkyJS\n- [ ] Update Mina Signer \n- [x] Update Mina zkApp CLI '), ('mitschabaude', ""I'm going to declare this closed with https://github.com/o1-labs/snarkyjs/pull/637, which covers snarkyjs. In mina-signer, I think we can wait for the re-implementation instead of changing the old version"")]"
265,Sequence Events RFC,jasongitmail,closed,,"[('mitschabaude', '# Sequence Events RFC\r\n\r\n## Part 1: Motivation\r\n\r\nLike [events](https://github.com/o1-labs/snarkyjs/issues/248#issuecomment-1172474317), sequence events represent arbitrary information that can be passed along with a zkApp transaction. However, they have one additional feature: they are committed to on chain. We call that commitment the ""sequence state""; it is a field on every zkApp account. Roughly, the sequence state is a hash (Merkle list) of the entire history of sequence events that have been posted to the account so far. Like with other account fields, you can set a precondition on the sequence state.\r\n\r\nBeing able to set this precondition means that **you can use previously emitted sequence events inside your smart contract method**. To do this, you pass in a list of sequence events and an old sequence state hash, and recompute the new (current) sequence state hash inside the circuit. Then, you set this new sequence state hash as a precondition. Thus, you prove that the sequence event list you have is actually the same list of sequence events that were posted on-chain -- in the same order -- since the old sequence state hash.\r\n\r\n@mrmr1993 designed this as a clever mechanism to circumvent the problems with concurrent state updates in zkApps.\r\n\r\nLet\'s state the problem first: Say we have a zkApp that wants to update its state in each user interaction, such that the new state depends on the old state plus the interaction inputs. (This probably applies to most zkApps!) The naive way is to directly update on-chain state in every interaction. To compute the new state, however, we have to use the current state. To _prove_ that we\'re really using the current state that\'s on-chain, we have to set a precondition on the current state. The problem: If multiple users send their transactions to the same block, without knowing from each other, they will set _the same precondition_ on the current state, and both will also update that state. Thus, every transaction after the first one has an outdated precondition on it, and is rejected.\r\n\r\nLet\'s picture this with a simple example, where the `state` is just a number and the user interactions are trying to increment that number by 1:\r\n\r\n```\r\n\r\ntransaction                             zkapp account after transaction\r\n{ state: 0, newState: 1 }  ---------->  { state: 1 }\r\n{ state: 0, newState: 1 }  -----X---->  { state: 1 }  // transaction fails, wrong state precondition\r\n\r\n``` \r\nTwo users sent an ""increment"" transaction, but the on-chain state was only incremented once!\r\n\r\nHere\'s how we can solve this: Assume that we can represent our state updates as sequence events, such that the order in which those updates are applied doesn\'t matter (this is typically possible; more on that later). Then, we could write our smart contract so that normal users do **not** update on-chain state. They just emit a sequence event instead. No precondition, and no conflicts with other transactions!\r\nThen, after a couple of transactions, we would have the following: An untouched on-chain state, and some emitted sequence events. Those sequence events are like ""pending updates"".\r\n\r\n```\r\n\r\ntransaction                   zkapp account after transaction\r\n{ event: INCR }  ---------->  { state: 0, events: [INCR] }\r\n{ event: INCR }  ---------->  { state: 0, events: [INCR, INCR] }\r\n\r\n``` \r\nThe two user transactions are not conflicting -- both get applied, and they end up creating an account with two ""increment"" events.\r\n\r\n(Note: To simplify the explanation, here I am just picturing sequence events as ""events that are stored on chain"". This is not precisely what happens, but is a reasonable abstraction, since we can _prove_ that certain events were stored on chain.)\r\n\r\nThe idea here is that the on-chain state is slightly lagging behind the state implied by the current list of events. To bring the on-chain state up to date with the list of events, we have another smart contract method, which we could call the ""rollup method"". \r\nWhat it does is:\r\n* Prove that we have a list of sequence events that was sent to the chain (since some specific index)\r\n* Prove that we have the current on-chain state (i.e., use a state precondition)\r\n* Inside the circuit, apply those sequence events one after another to the old state, to produce the new state\r\n* Set the new state to what you computed\r\n\r\nLet\'s add that rollup transaction to the picture above:\r\n\r\n```\r\n\r\ntransaction                            zkapp account after transaction\r\n{ event: INCR }           ---------->  { state: 0, events: [INCR] }\r\n{ event: INCR }           ---------->  { state: 0, events: [INCR, INCR] }\r\n{ state: 0, newState: 2 } ---------->  { state: 2, events: [INCR, INCR] }\r\n\r\n``` \r\nNow the on-chain state reflects all the updates that happened so far! 🎉 \r\n\r\nThe rough idea is that anyone would be able to send rollup transactions, so it\'s censorship-resistant; but probably the zkApp developer would want to set up some service that monitors the chain and makes sure to update state from time to time.\r\n\r\nNote: If two people would send _rollup_ transactions at the same time, one of them would fail. But this doesn\'t matter, since no data is lost -- all the data about actual state updates is in the list of events, which can always be added without conflicts.\r\n\r\nAnother note: The pictures above may make it seem like someone could now run the rollup transaction again, using the two existing events as inputs _again_ to update the state to the corrupted value of 4. However, it\'s not hard to prevent this in the real implementation.\r\n'), ('mrmr1993', ""> However, it's not hard to prevent this in the real implementation.\r\n\r\nExplicitly: by burning an appState entry to keep track of the most-recently-applied sequence event state, and adding that into the precondition.\r\n\r\nGreat write up, thanks so much @mitschabaude!""), ('mitschabaude', '# Sequence Events RFC\r\n\r\n## Part 2: API\r\n\r\nA bare-bones sequence events API could look like this:\r\n```ts\r\n// property that has to be set on `SmartContract`\r\nsequenceEvent: AsFieldElements<T>; \r\n\r\n// emit a sequence event\r\nthis.emitSequenceEvent(event: T): void;\r\n\r\n// compute the new sequence state (i.e., a hash) from a previous state and an array of events\r\nthis.updateSequenceState(stateHash: Field, events: T[]): Field;\r\n\r\n// fetch array of arrays of sequence events (inside the circuit, so pre-fetched and not async)\r\n// each of the arrays are the sequence events emitted by one party.\r\n// they have to be fed to `updateSequenceState` one by one\r\nthis.getSequenceEvents({ fromStateHash: Field, toStateHash?: Field }): T[][];\r\n```\r\n\r\nDisclaimer: I didn\'t implement that API, and will explain why in a minute.\r\nStill, here are some notable considerations which will turn up in any API:\r\n* There are no different types of sequence events (as with events), there\'s just one type. This is because in the typical use case sketched above, users have to apply those events to a state one by one to compute a new state. This is hard to do in a circuit, in a static way, if the type can have any of a number of meanings. I think it\'s much better to just remove that headache for users by just giving them one possible event type. If they need multiple ""kinds"" of events, they will naturally build some kind of enum into that single type themselves, but in a way which is probably easier to deal with in a static circuit.\r\n* The natural data structure to store sequence events is not an array of events `T[]`, but an array of arrays `T[][]`. Each of the arrays are the events emitted by one party. Those need to be fed to `updateSequenceState` in one chunk to get the next sequence state hash. Thus, we can\'t store them as a flat array, we need to preserve the chunk structure to be able to compute the correct sequence state hashes later.\r\n\r\nIn the current implementation (https://github.com/o1-labs/snarkyjs/pull/274), **I decided to skip exposing this low-level API, and instead reached for a slightly higher level of abstraction.** The reason is that when I implemented the ""rollup transaction"" described above, it was much harder than anticipated. The complication is that the number of sequence events you want to roll up in one transaction should be dynamic, so you can be flexible with how frequently that method is called. Also, you might have several smart contract methods which emit *different numbers* of events. So you end up with a computation that\'s dynamic-size in two dimensions, which has to be fit into a _static_ circuit.\r\n\r\nI think most users just wouldn\'t have an idea on how to do this -- which means we need to give them a function which abstracts it away: which takes the dynamic-size events list and handles rolling them up. However, part of the rolling up logic is user-defined. E.g., in the example with the ""increment"" events above, rolling up meant to count the increment events. But that\'s application-specific, so users need a general-purpose framework for defining this kind of update logic themselves.\r\n\r\nHere\'s what I came up with (already [implemented](https://github.com/o1-labs/snarkyjs/pull/274)):\r\n\r\nOn a `SmartContract`, you can set a property called `stateUpdate`, which takes three parameters:\r\n* A type for a `state` (not necessarily related to your on-chain state, but in many cases would resemble it)\r\n* A type for an `update` to that state (i.e., the sequence event)\r\n* An user-defined `apply` method with the signature `(state: S, update: U) => S`, i.e., taking an old state plus an update, and producing a new state.\r\n\r\nHere\'s the code for our ""counter"" / ""increment"" example:\r\n\r\n```ts\r\nclass CounterZkapp extends SmartContract {\r\n\r\n  stateUpdate = SmartContract.StateUpdate({\r\n    state: Field,\r\n    update: Field,\r\n    apply(state: Field, _update: Field) {\r\n      return state.add(1);\r\n    },\r\n  });\r\n\r\n  // ...\r\n}\r\n```\r\n\r\nIn this particular case, the value of the `update` isn\'t even needed in the `apply` logic, but I think you get an idea how to use this in general. As usual, the types for `state` and `update` can be general circuit values, instead of `Field`.\r\n\r\nThe `stateUpdate` field now has the methods on it to interact with sequence events. There are currently two of them. They have two generic type parameters -- `S` (the `state` type) and `U` (the `update` type).\r\n\r\n```ts\r\nthis.stateUpdate.emit(update: U): void;\r\n\r\nthis.stateUpdate.applyUpdates({ state: S, stateHash: Field, updates: U[][] }): { state: S, stateHash: Field });\r\n```\r\n\r\n`applyUpdates` is what the ""rollup method"" uses to apply state updates. It handles all the complicated things -- hashing, adding the sequence state precondition, computing the new state using your custom apply method, all for dynamically-sized updates. The `stateHash` in the `applyUpdates` method is of course just the ""sequence state"" that\'s stored on the zkApp account. The reason that it is exposed to users in this way is that you need it to refer to a particular point in the history of updates (you can\'t use the state itself for that, because different points in the history can have the same state). To use `applyUpdates` the first time, you\'ll also need the initial state hash. It\'s always the same value, and available via  `SmartContract.StateUpdate.initialStateHash`.\r\n\r\nA fully-fledged example is here: https://github.com/o1-labs/snarkyjs/blob/fc4dcf7ad5293e6f89ec5f8f4560e5d2a09bf48e/src/examples/state_update_rollup.ts\r\n\r\nFurther remarks:\r\n* This API doesn\'t use the term ""sequence events"" at all. I just found no place to introduce that word, and thought it would be confusing, so I went with the more familiar terminology of ""states"" and ""updates"". As usual, comments are welcome on the naming!\r\n* We will also need a `fetch` method of course, it\'s not implemented but could be\r\n```ts\r\nthis.stateUpdate.getUpdates({ fromStateHash: Field, toStateHash?: Field }): U[][];\r\n```\r\n* Different than for normal events, this time I use a function call to declare the state update structure: `stateUpdate = SmartContract.StateUpdate( ... )`. This makes typing much, much better -- in fact, normal events are essentially untyped, while this is typed precisely. I think that\'s easily worth adding the bloat in API.\r\n* This API makes absolutely no assumptions about what you do with the `state`. You *can* store it on chain directly, but I didn\'t want to prescribe that, to retain the full flexibility that sequence events give you. In many cases, for example, on-chain state could be *derived* from the rolled-up `state` instead of equal to it; or only a *part* of on-chain state could be computed from it; etc etc.\r\n'), ('jasongitmail', 'Thanks Gregor!\r\n\r\nSome questions on pt 1 CC @mrmr1993 \r\n\r\n> transaction                            zkapp account after transaction\r\n> { event: INCR }           ---------->  { state: 0, events: [INCR] }\r\n> { event: INCR }           ---------->  { state: 0, events: [INCR, INCR] }\r\n> { state: 0, newState: 2 } ---------->  { state: 2, events: [INCR, INCR] }\r\n\r\n- What happens to the first two tx\'s if a rollup tx does _not_ arrive by the time the next block is created? How long will they remain in the mem pool until rolled up & under what conditions would they be evicted?\r\n- What is max # of sequence events per zkApp that the Mina node will retain in the mem pool? How does the node handle a situation where the ""queue"" is full, if that can occur, and another tx containing a sequence event arrives?\r\n- Are sequence events available via Mina GraphQL API on Berkeley?\r\n- What happens if a _rollup_ tx is received and then subsequent tx\'s containing sequence events are received? Will their precondition be invalid and subsequent tx\'s will have their precondition fail until the next block & they\'d need to generate a new tx based off the new state? I suppose that depends on what precondition they choose. Or do zkApps have a way to know about this intermediate state after the rollup via the GraphQL API, implying that subsequent tx\'s containing sequence events and rollup tx\'s could be accepted into the same block?\r\n\r\n> There are no different types of sequence events (as with events), there\'s just one type. This is because in the typical use case sketched above, users have to apply those events to a state one by one to compute a new state. This is hard to do in a circuit, in a static way, if the type can have any of a number of meanings. I think it\'s much better to just remove that headache for users by just giving them one possible event type. If they need multiple ""kinds"" of events, they will naturally build some kind of enum into that single type themselves, but in a way which is probably easier to deal with in a static circuit.\r\n\r\nMakes sense.'), ('mimoo', 'very well written! some questions/thoughts on part 1:\r\n\r\n* my way of thinking about this: the ""sequencer"" (the agent that orders transactions to be rolled up) is on-chain, built as part of the zkapp. The downside, if it is one, is that the sequencer is not cleanly separated from the rollup/protocol.\r\n* this translates into an overhead for every application: you need to wait twice. Once for the event to be emitted, then for the rollup to happen\r\n* I guess no sequence events can be lost when you apply them in a rollup?'), ('bkase', 'Thanks @mitschabaude ! This is a great write-up and I really like your StateUpdate abstraction. But I think we should take it even further!\r\n\r\nWhat we have here is really close to the Elm Architecture-style state management. This is a really nice way to deal with state machines in an application and have really nice properties, so it makes sense that it comes up when we\'re trying to model our state machine here!\r\n\r\nBy the way, what we really have is  a `scan` over an implicit infinite stream of actions that are aggregated in chunks -- this is exactly the same problem that came up when processing transactions in the Mina Protocol with Snark Workers: https://minaprotocol.com/blog/fast-accumulation-on-streams except in the transaction processing case it was important that the ""actions"" themselves were monoidal (so we could combine them in a tree) and there wasn\'t a commutativity requirement (see below).\r\n\r\nThis should be familiar to TypeScript/JavaScript web developers through its instantiation via the Redux library or more ""recently"" (does this age me?) via the `useReducer` hook in React.\r\n\r\nNot only is it important to call this out in documentation because it will help people reason about how to model their state-update logic, but I think we should try to push the API to feel more like Elm/useReducer/Redux/etc. This actually doesn\'t meaningfully change what you\'ve proposed too much.\r\n\r\n### Naming\r\n\r\nSomething that immediately falls out is the nomenclature:\r\n\r\n* `sequence events` or `updates` become `actions` \r\n* `emit` becomes `dispatch` or `send`\r\n* `applyUpdates` becomes `reduce` (or just `update` if we take from Elm)\r\n\r\nWe\'re missing a nice way to define the `initial state` or `init` or `z`\r\n\r\n### Commutativity Property\r\n\r\nWhat\'s unique here and slightly different than a typical Elm Architecture implementation is that actions are deferred from being reduced immediately against the state and that you typically want your state machine to allow actions to commute ie (given a left-associative update $\\circ$):\r\n\r\n$$\\begin{eqnarray} \r\n\\forall a,a\' &\\in& \\texttt{action}  \\nonumber \\\\\r\n\\forall s &\\in& \\texttt{state}  \\nonumber \\\\\r\ns \\circ a \\circ a\' &=& s \\circ a\' \\circ a \\nonumber \\\\\r\n\\end{eqnarray}$$\r\n\r\nWith a quick google, I haven\'t found any prior art for any ""Commutative Elm Architecture"" or ""Reducers with Commutative Actions"", but I think this doesn\'t actually impact the way the API is defined -- it\'s just something developers need to think about when they\'re designing their state and reduce logic.\r\n\r\n### Instantiation and dispatch\r\n\r\nRough proposal:\r\n\r\n```typescript\r\nreducer = SmartContract.Reducer({\r\n  stateType: Field,\r\n  actionType: Field,\r\n  initialState: new Field(0), // see below, this assumes we do state management\r\n  reduce: (state: Field, _update: Field) {\r\n      return state.add(1);\r\n  }\r\n})\r\n\r\n//...\r\n\r\nthis.reducer.dispatch(action: Action): void ;\r\n```\r\n\r\n### Fetching and reducing\r\n\r\nAs far as managing fetching and reducing the actions (ie ""settling the rollup""): In some ways, I really like the ""rollup"" nomenclature because it truly is performing a similar settling operation as any rollup, but in other ways there will be a lot of different rollups floating around given that a lot of the time the smart contract will be a zk-rollup on another dimension simultaneously.\r\n\r\nAlternatively, we can just stick with the Elm Architecture / Redux / useReducer world and say something like `this.reducer.reduce`; I\'m partial to `scan` since we\'re not _really_ doing a proper reduce, but I guess the world has decided to use `reduce` in this case.\r\n\r\nThe other question that comes to my mind is: To what extent should we manage the state for people? What you\'ve proposed above is explicitly not managing it at all. The developer needs to decide where to store the state if anywhere and remember which actions they have processed so far. Alternatively, we could manage the state for the developer -- potentially via some mechanism where you can say if you want it in on-chain state, off-chain via a merkle root, or somewhere else. I haven\'t fully thought this through, but I think this would make it a lot easier to use this tool in their zkApps.'), ('mitschabaude', '@bkase I love the idea of using ""reducer"" terminology! `reducer` / `reduce` / `dispatch` will immediately get developers in the right mindset and give them something familiar. Much better than ""stateUpdates"" / ""apply""! I prefer `reduce` over `scan` since its better-known and clearer IMO (I didn\'t know `scan` at least).\r\n\r\nRe: should we manage state -- when thinking more about the use cases for sequence events, I discovered what feels like an important use case, that isn\'t covered well by having a single `stateType` and a single `reduce` / ""apply"" function. So my answer (elaborated below) is that we shouldn\'t manage state, and make the API even more flexible than proposed before.\r\n\r\nNamely, there\'s the case that\r\n* the potential length of the history of sequence events is reasonable; say in the tens or hundreds\r\n* there is no _single_ neat / small-ish state implied by that history which captures the history well\r\n\r\nExample: Let\'s say a simplified poker zkApp creates events of the form `{player: PublicKey, bet: UInt64, round: Field}`, i.e., recording the bets that various players make during the game. And the zkApp might want to reason about things like ""did player X make a bet in the current round? if yes, how large was that bet?"".\r\nIf you try and capture that in a single state type, you end up with something huge, e.g. `{ players: [Alice, Bob, ...], rounds: 3, didBetInRound: [[true, false, ...], [false, ...], ...], betSizeInRound: [[100, 0, ...], [0,...], ...] }`, which is annoying and inefficient to process in a circuit. Instead, if you can make your state *specific to the current player and the current round*, the answer to your reduce query is small: `{ didMakeBet: true, betSize: 100 }`.\r\n\r\nSo, there are two points here:\r\n* the `reduce` operation may have parameters that depend on the current run of the smart contract method. This doesn\'t work if it is specified beforehand at the top level of the smart contract\r\n* instead of storing the state returned by `reduce` either on-chain of off-chain, it might make sense to just use it within the current smart contract method run, and discard it.\r\n\r\nBasically, the list of events themselves is the state in this use case, and it\'s important to reason over that list of events inside smart contracts, so we have to use sequence events instead of normal events.\r\n\r\nAs another point, there might be other smart contract methods that run an *entirely different* query on the list of events, so that the `stateType` can be mutliple different things in different `reduce` calls. In the example above, other queries could be\r\n* in which round are we?\r\n* which players\' turn is it?\r\n\r\nTo offer such flexibility, we should only declare the event type, i.e. `actionType`, as part of the top-level `reducer`, and pass in the `(state, update) => newState` callback, as well as the `stateType` and initial state, as arguments to `reducer.reduce`.\r\n\r\nHere\'s how that could look in a full example -- the counter example we already discussed.\r\n\r\n```ts\r\nconst INCREMENT = Field.one;\r\n\r\nclass CounterZkapp extends SmartContract {\r\n  reducer = SmartContract.Reducer({ actionType: Field });\r\n\r\n  @state(Field) counter = State<Field>();\r\n  // we also need the stateHash in on-chain state to know where in the action history we are\r\n  @state(Field) stateHash = State<Field>();\r\n\r\n  @method incrementCounter() {\r\n    this.reducer.dispatch(INCREMENT);\r\n  }\r\n\r\n  @method rollupIncrements() {\r\n    // get on-chain state & state hash, add preconditions for them\r\n    let counter = this.counter.get();\r\n    this.counter.assertEquals(counter);\r\n    let stateHash = this.stateHash.get();\r\n    this.stateHash.assertEquals(stateHash);\r\n\r\n    // fetch list of actions\r\n    let actions = this.reducer.getActions({ fromStateHash: stateHash });\r\n    // state type\r\n    let stateType = Field;\r\n\r\n    // reduce takes not only the actions and initial state / hash as parameters (as before),\r\n    // but also the stateType and reduce callback\r\n    let { state: newCounter, stateHash: newStateHash } = reducer.reduce(\r\n      actions,\r\n      stateType,\r\n      (state: Field, _action: Field) => {\r\n        return state.add(1);\r\n      },\r\n      { state: counter, stateHash }\r\n    );\r\n\r\n    // store the new state / stateHash on chain\r\n    this.counter.set(newCounter);\r\n    this.stateHash.set(newStateHash);\r\n  }\r\n}\r\n```\r\n\r\nNote: In this example, we do have just one `stateType` and just one `(state, update) => newState` callback. And we do just store the reduced state on-chain. But I argue that doing this within a more flexible API is still quite straight-forward. It\'s a pattern for how to use `reducer` that can be easily copy-&-pasted and adapted to similar use cases. Still, we offer the full list of use cases people might have for sequence events.\r\n\r\nFor reference, this is the proposed API:\r\n\r\n```ts\r\nreducer = SmartContract.Reducer({ actionType: AsFieldElements<A> });\r\n  \r\nthis.reducer.dispatch(action: A): void;\r\n\r\nthis.reducer.reduce<S>(\r\n  actions: A[][],\r\n  stateType: AsFieldElements<S>,\r\n  reduce: (state: S, action: A) => S,\r\n  initial: { state: S, stateHash: Field }\r\n): { state: S, stateHash: Field };\r\n\r\n// to be implement later\r\nthis.reducer.getActions({ fromStateHash?: Field, toStateHash?: Field }): A[][];\r\n```\r\n\r\nThe only part I\'m not very confident about is the naming of the `stateHash` parameter and return value in `reducer.reduce`. That hash actually represents the history of actions, and has no connection to the `state`; so the naming ""stateHash"" might be confusing if there\'s now the potential to use `reduce` with different types of states.\r\n\r\nMaybe it should be `actionsHash`? `reducerHash`? `actionsCommitment`?'), ('mitschabaude', '@jasongitmail \r\n>  What happens to the first two tx\'s if a rollup tx does not arrive by the time the next block is created? How long will they remain in the mem pool until rolled up & under what conditions would they be evicted?\r\n    What is max # of sequence events per zkApp that the Mina node will retain in the mem pool? How does the node handle a situation where the ""queue"" is full, if that can occur, and another tx containing a sequence event arrives?\r\n\r\nJust to clarify, the first two txns modify the account state immediately. They update the ""sequence state"" on the account, which is a hash of all sequence events so far; so the fact that these two events happened will be forever recorded on chain, even if there is no rollup tx at all. Not sure if that answers your questions -- I think we don\'t really depend on the txns being in the mempool.\r\n\r\nWe do depend on being able to fetch the list of events from somewhere, to be able to rollup. We could fetch recent events from the Mina node, but they probably will get unavailable after some time (don\'t know the technical details). Or, we could fetch them from an archive node, where they will be available forever; or keep track of them on our own.\r\n\r\n> Are sequence events available via Mina GraphQL API on Berkeley?\r\n\r\nI don\'t think they are, currently\r\n    \r\n>  What happens if a rollup tx is received and then subsequent tx\'s containing sequence events are received? Will their precondition be invalid and subsequent tx\'s will have their precondition fail until the next block & they\'d need to generate a new tx based off the new state? I suppose that depends on what precondition they choose. Or do zkApps have a way to know about this intermediate state after the rollup via the GraphQL API, implying that subsequent tx\'s containing sequence events and rollup tx\'s could be accepted into the same block?\r\n\r\nExcellent question! Event-emitting txns don\'t have a precondition on them, so they can\'t become invalid. But the rollup txn has a precondition on the current sequence state, so it\'s valid to ask: What happens if more event-emitting txns sneak in while the rollup txn is being prepared -- will the rollup txn have an outdated precondition?\r\n\r\nThe answer is no, but requires digging into the details:\r\n\r\nThe on-chain sequence state field actually stores **sequence state hashes for the 5 most recent slots that contained sequence events**, and the sequence state precondition is accepted if it matches **any of these 5**.  \r\n\r\nSo, say that an account has the following sequence state hashes at the end of a slot: `[s1, s2, s3, s4, s5]`, and we know these were all included in a block already.\r\nLet\'s say we\'re now in a subsequent slot, where we want to construct a rollup tx but at the same time people are submitting new events.\r\n\r\nThe first of the new events will shift the on-chain sequence state to the right, and add a new element, which represents the current slot:\r\n```[sNEW, s1, s2, s3, s4]```\r\nNotice that the `s5` state was thrown out, it\'s no longer a valid precondition.\r\n\r\nNow, if another new event gets submitted within the same slot, it doesn\'t shift the states to the right again, but also updates _the first_ entry:\r\n```[sNEW_modified, s1, s2, s3, s4]```\r\n\r\nSo the state `s1`, which represents the state at the end of the most recent block, will still remain a valid sequence state precondition **for five additional slots** after that block. Since a slot is 3 minutes, that are 15 minutes (in the worst case, where all those slots contain blocks with sequence events).\r\n\r\nSo, what do we do if we want to create a rollup txn?\r\n* We look at the sequence state from the last completed block, `s1` in this case. We fetch sequence events up until that state, and rollup those events with `s1` as the precondition\r\n* The newly submitted events, which all modify `sNEW`, don\'t bother us, since we are easily able to construct the rollup txn and submit it within 15 minutes, so we know `s1` will be a valid precondition\r\n* Our transaction gets accepted, independent of how many events were submitted around the same time\r\n\r\nIt only ever makes sense to refer to the sequence event state at the end of a completed block, because that\'s when the order of sequence events has been fixed. It doesn\'t make sense to target the block that\'s _currently_ being constructed, and guess the order that the events in there will be applied.\r\n\r\n@mimoo \r\n\r\n> I guess no sequence events can be lost when you apply them in a rollup?\r\n\r\nYes, if we do it like in my code example in the last post, no events can be lost -- since the smart contract method forces us to start at the `stateHash` that\'s stored on-chain, and which was the result of the last update\r\n\r\n> this translates into an overhead for every application: you need to wait twice. Once for the event to be emitted, then for the rollup to happen\r\n\r\nThat\'s a good point. Maybe we want to encourage a framing where the pending events are also considered part of the current state, and UIs display it as such, because it\'s basically guaranteed that they will eventually end up in on-chain state. Not sure if that\'s smart though...\r\nOtherwise it could be just ""wait for two blocks instead of one"" if the zkApp developer is willing to pay for maximally frequent rollups, or makes users pay for them'), ('bkase', ""I really like the latest version of this 👍 . I like `actionsHash` or `actionsCommitment` with some associated doccomments that explain that it's the merkle hash of a list of actions I think?""), ('bkase', '> That\'s a good point. Maybe we want to encourage a framing where the pending events are also considered part of the current state, and UIs display it as such, because it\'s basically guaranteed that they will eventually end up in on-chain state. > Not sure if that\'s smart though...\r\n> Otherwise it could be just ""wait for two blocks instead of one"" if the zkApp developer is willing to pay for maximally frequent rollups, or makes users pay for them\r\n\r\nI like this idea and I think it\'s pretty safe as you said. Depends on the application, but for most the existence of a sequence event is good enough I think.')]"
262,Make Proof.verify inside a circuit work from serialized compile output,mitschabaude,open,"It would be nice if we wouldn't have to recompile ZkProgram dependencies, but could serialize the compiled output to a file and recreate everything that's necessary for verifying inside circuits just from that file

this is already possible for verifying *outside* the circuit, where the serialization is the base58 verification key

probably similar to #87 and could be tackled in one sprint with that issue",[]
258,[recursion] passing `CircuitValue` as argument to another `CircuitValue` breaks,Trivo25,closed,"When passing in `CircuitValue` as argument into the constructor of another one, the passed in value will become `undefined` in in the recursive proof system `ZkProgram`


""pseudo code"" example: 


```ts

let a = new MyClass(
	new NestedClass() // argument becomes undefined
);

a.nestedClass; // undefined


```

Example to reproduce:

```ts
import { Field, ZkProgram, CircuitValue, prop } from 'snarkyjs';

class MyClass extends CircuitValue {
  @prop nested: NestedCircuit;
  @prop x: Field;
  constructor(n: NestedCircuit) { // this argument becomes undefined
    super();
    this.nested = n;
    this.x = Field.zero;
  }
}

class NestedCircuit extends CircuitValue {
  @prop x: Field;
  constructor() {
    super();
    this.x = Field.zero;
  }
}

let MyProgram = ZkProgram({
  publicInput: Field,

  methods: {
    proofBatch: {
      privateInput: [MyClass],
      method(publicInput: Field, c: MyClass) {
	// returns 'undefined'
        let x = c.nested.x;
        x.assertEquals(Field.zero);
      },
    },
  },
});

await MyProgram.compile();
```

However! Creating the object *inside* the constructor (not passing it as argument) works

```ts
...

class MyClass extends CircuitValue {
  @prop nested: NestedCircuit;
  @prop x: Field;
  constructor() {
    super();
    this.nested = new NestedCircuit(); // this works!
    this.x = Field.zero;
  }
}

...
```

There seem to be a bunch of edge cases where some properties return `undefined` - happy to provide more examples","[('mitschabaude', ""can you try to move `NestedCircuit` above `MyClass`? the reason it's undefined here is because the `@prop` decorator runs before the `NestedProgram` is actually defined. unfortunately classes don't seem to be hoisted to the top in JS""), ('Trivo25', 'Oh yep, that seems to fix it! Thank you very much :)'), ('mitschabaude', 'Ran into this as well a couple of times ;)')]"
256,socket hung up error while deployment with snarkyjs v0.4.1,ashish173,closed,"I am trying to deploy the sudoku example application on berkeley network but got an error of socket hang up. This happened right after the `Build transaction` step in the deployment sequence.
Trivo (from discord#zapp-developers) helped to solve the issue by changing the snarkyjs version from 0.4.1 to 0.3.7 and it worked.

Below is the error that I got in console as soon as I confirmed to send the transaction. 
```
Are you sure you want to send (yes/no)? · yes
✔ Send to network
  Failed to send transaction to relayer. Errors: request to http://devnet-producer_coda_1:3085/graphql failed, reason: socket hang up
```

## zk system         
```
Please include the following when submitting a Github issue:

  System:
    OS: macOS 11.6.5
    CPU: (8) x64 Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz
  Binaries:
    Node: 16.15.1 - /usr/local/opt/node@16/bin/node
    Yarn: 1.7.0 - /usr/local/bin/yarn
    npm: 8.11.0 - /usr/local/opt/node@16/bin/npm
  npmPackages:
    snarkyjs: ^0.4.1 => 0.4.1 
  npmGlobalPackages:
    zkapp-cli: 0.4.8
```","[('mitschabaude', 'this should be fixed in the new version `0.4.3`, which we just published!'), ('mitschabaude', '(note: new CLI version will be published later today)')]"
255,"Update SnarkyJS API reference, after newer version of QANet & SnarkyJS is deployed",jasongitmail,closed,,[]
254,Dog food Wednesday's Advanced Workshop presentation,jasongitmail,closed,,[]
253,Dog food Tuesday's Intro Workshop presentation,jasongitmail,closed,,[]
252,Add snarkyjs as a peer dependency in project-ts,jasongitmail,closed,,"[('jasongitmail', '- [ ] update project-ts\n- [ ]  Manually update examples in zkapp-cli')]"
249,Confirm if memo is committed inside circuit,jasongitmail,closed,,"[('mitschabaude', ""Memo is committed to inside circuit, but it apparently shouldn't, and we definitely shouldn't think of using it as a proof input"")]"
248,Events RFC,jasongitmail,closed,,"[('mitschabaude', ""Events represent arbitrary information that can be passed along with a transaction.\r\n\r\nAn example use case are zkApps which keep some large internal state, and only store a commitment to that internal state on-chain. E.g., a Merkle tree where only the root is stored in on-chain state. Events enable to attach the full information of state changes in transactions. In the Merkle tree example, this could mean sending any Merkle leaves that are changed by the transaction as events. This means that an observer of these transactions can follow along and keep track of the full Merkle tree on their side.\r\n\r\nFor an initial iteration, we propose to add two small pieces to the API to enable events:\r\n\r\n* a new, optional `events` field at the top level of a SmartContract, to declare _names_ and _types_ of the different events the smart contract will use\r\n* a function `this.emitEvent(type: string, event: T)` to publish an event.\r\n\r\nExample:\r\n\r\n```ts\r\nclass MyContract extends SmartContract {\r\n  events = {\r\n    'new-leaf': Field\r\n  }\r\n   \r\n  @method updateMerkleTree(leaf: Field, ...) {\r\n    this.emitEvent('new-leaf', leaf);\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nIn a second iteration, we also want to add a method \r\n```ts\r\nthis.fetchEvents(address: PublicKey, startBlock: UInt32, endBlock?: UInt32)\r\n```\r\nwhich returns a list\r\n```ts\r\n[\r\n  { type: 'new-leaf', event: Field(287182736) },\r\n  { type: 'new-leaf', event: Field(214193487) },\r\n  ...\r\n]\r\n```\r\n\r\n`fetchEvents` relies on changes to the Mina / archive nodes to expose the events in an API.\r\n\r\nInternally, every event is stored as a list of field elements as prescribed by the protocol. To distinguish different kinds of events when _receiving_ them, we essentially represent them as an enum, with\r\n* the first of the field elements representing the type as an index 0, 1, 2.. corresponding to the alphabetical order of the event type string within the keys of the `events` object\r\n* the rest of the field elements representing the event itself\r\n\r\nif there is only one entry in the `events` field, as an optimization we don't store an additional index.\r\n\r\nEDIT: made `endBlock` in `fetchEvents` optional @MartinMinkov ""), ('MartinMinkov', ""This looks good to me! \r\n\r\nOne thing I wonder about is making the `endBlock` parameter optional and grabbing events up to the latest block published starting from `startBlock` when it's not specified. \r\n\r\nAlso, can events track transfers or is it only on-chain state changes on a smart contract? ""), ('mitschabaude', ""Good idea of making `endBlock` optional!\r\n\r\n> Also, can events track transfers or is it only on-chain state changes on a smart contract?\r\n\r\nYes, definitely! Events can be anything. One thing to note is that balance changes are already tracked in the transaction structure, they're like a built-in event already""), ('bkase', 'What is the `UInt32` in `startBlock`? It needs to be a handle to the specific block to handle forks I think -- so a `stateHash` for example?\r\n\r\nWhat are the constraints of the types for events?\r\n\r\n```\r\n  events = {\r\n    \'new-leaf\': Field\r\n  }\r\n```\r\n\r\nIs it circuitvalues? Is there a max size of the field? Is there a max length for the event string? (I suppose not since we can reconstruct it from an index?)\r\n\r\n\r\n\r\n> In a second iteration, we also want to add a method\r\n> \r\n> this.fetchEvents(address: PublicKey, startBlock: UInt32, endBlock?: UInt32)\r\n> which returns a list\r\n> \r\n> [\r\n>   { type: \'new-leaf\', event: Field(287182736) },\r\n>   { type: \'new-leaf\', event: Field(214193487) },\r\n>  ...\r\n> ]\r\n\r\nCan you write the return type for `fetchEvents` -- it\'s a Promise right? Or does it work similarly to the state `get` where we prefetch so the actual method call doesn\'t have to be asynchronous? I think `fetchEvents` should be async and should be a Promise _and_ we should error if you use this inside of a smart contract where the error message says something like, ""you probably want to use sequence events if your smart contract depends on recent events""'), ('jasongitmail', 'Looks great. +1 Martin & Brandon.\r\n\r\n```js\r\nthis.fetchEvents(address: PublicKey, startBlock: UInt32, endBlock?: UInt32)\r\n```\r\n\r\nOut of scope for now, but maybe we should also accept a `type` parameter where the value could be `new-leaf` in your example, if a dev only needs specific events.\r\n'), ('MartinMinkov', '> What is the UInt32 in startBlock? It needs to be a handle to the specific block to handle forks I think -- so a stateHash for example?\r\n\r\nIs there any way we can identify forks in a different way? I don\'t know if this functionality is in Mina, but is there a concept of a ""chain id"" that differentiates a forked chain? Could we configure SnarkyJS in a way that can fetch from something specific like that? I think specifying a hash value for a range of blocks you want to grab feels a bit weird. '), ('mitschabaude', '> What are the constraints of the types for events?\r\n\r\nThey\'re circuit values, i.e. `AsFieldElements<T>`. There aren\'t any size restrictions now, I wonder if there are size restrictions on events in the protocol? If yes, it would make sense to enforce those already on the client side.\r\n\r\n> Can you write the return type for fetchEvents -- it\'s a Promise right? Or does it work similarly to the state get where we prefetch so the actual method call doesn\'t have to be asynchronous? I think fetchEvents should be async and should be a Promise and we should error if you use this inside of a smart contract where the error message says something like, ""you probably want to use sequence events if your smart contract depends on recent events""\r\n\r\nThanks for bringing this up, yeah I thought it would be prefetched but now that you say it, I agree that it\'s a bad idea to expose this to the circuit since we won\'t be proving that these are in fact the events emitted to the account. With sequence events this will be possible, so it makes total sense to reserve the functionality of talking about them in the circuit to sequence events. @mrmr1993 tagging you because we talked about this but I assume you agree.\r\n\r\nSo, the new proposal is for `fetchEvents` to look like this:\r\n```ts\r\n// zkapp is an instance of `SmartContract`\r\nzkapp.fetchEvents(start: ???, end?: ???): Promise<{ type: string; event: AsFieldElements<any> }[]>\r\n```\r\nThe `address` I had before is actually not needed if it\'s a function on a `SmartContract` instance, which already has the address.\r\n\r\nI don\'t have a good suggestion for how to specify the `start` block, because I don\'t know enough about the blockchain side of things. Maybe it would be easiest to just go with the ""best chain"" by default, so we only have to worry about specifying a point in a linear history? And possibly expose other options for advanced developers?\r\n\r\nFor example, for sequence events, I thought that it would be nice if we would only need to pass in the sequence state (= a hash identifying a point in the history of sequence events), and snarkyjs would figure out the sequence events since this state on its own. @mrmr1993 would be interested in your thoughts on this as well.'), ('mimoo', ""looks good! I have a few questions/comments:\r\n\r\n* what is the limit in terms of events/transaction?\r\n* why limit an event to a single field element? It'd be nice if it was a different type that can be encoded/decoded as field elements\r\n* why limit the query to some blocks? In Ethereum the API for events is so flexible (you can retrieve ALL events for a smart contract) that you can sort of use it as an append-only array to be consumed from outside the smart contract. So for example, imagine that you want to create a number of cities, associated to some metadata, in your dapp. The first thing you'd do in your smart contract is that you'd reach for a dictionary/hashmap. But that's impractical to query from outside the smart contract if you're trying to build the list of all cities (at least, Ethereum doesn't offer a way to do so easily). A solution is to just emit an event every time you create a city, so that a dapp/client can simply ask for all the events and construct the list from it.""), ('mitschabaude', ""> why limit an event to a single field element? It'd be nice if it was a different type that can be encoded/decoded as field elements\r\n\r\nit's not limited to a single field element! should've picked a different example :P it can be any `CircuitValue` for example\r\n\r\n> why limit the query to some blocks?  In Ethereum the API for events is so flexible (you can retrieve ALL events for a smart contract) that you can sort of use it as an append-only array to be consumed from outside the smart contract.\r\n\r\ncool! I guess we could make `fromStateHash` default to the initial state hash to make it easier to use it that way?\r\n\r\nEDIT: ah sorry I thought this was on the sequence events RFC. applies to this one as well though, we could default to the full list of events\r\n"")]"
247,Recursion / Proof Composition,jasongitmail,closed,,[]
246,Expose circuit digest,jasongitmail,closed,,"[('mitschabaude', 'done!')]"
240,Finish unimplemented preconditions,mitschabaude,closed,"This is a left-over from https://github.com/o1-labs/snarkyjs/pull/207, which was already big enough in scope

A couple of preconditions are not implemented yet for various reasons. Tasks:
* [ ] Parse the fetch result of various ""hashes"", which have a base58-like enconding, into `Field`
* [ ] Add some missing fields to the `LocalBlockchain`
* [ ] Nice-to-have: enable to set network state for local blockchain, so that network preconditions can be tested locally",[]
239,Update SnarkyJS README -- add contribution section,jasongitmail,closed,,"[('jasongitmail', 'Would be good to try to give it a quick pass before SnarkyJS Week with anything you think is important, and maybe create an issue to finish this fully later. We can primarily guide them to the docs too--if we want to prevent duplication. \n\nBut might be good to have enough that prospective contributors could understand how to get started contributing, code standards, etc.')]"
238,Create Github releases with Actions,mitschabaude,closed,,"[('mitschabaude', 'done')]"
236,Support other parties in a proof transaction,mitschabaude,closed,"At the moment, things like `Party.createSigned` don't work in proof transactions. This should be the first step in the direction of fully figuring out the fully general parties construction approach",[]
234,Add memo field when creating a transaction,jasongitmail,closed,,[]
233,[Tokens RFC] - Research desired functionality to expose,MartinMinkov,closed,"**Description**

Before implementing token functionality in SnarkyJS, it is important that we align on what we intended to expose and how it works. Some pre-homework to this task is to do a quick survey of existing token implementations in other chains. Following that, this issue has been broken into 3 steps.

1. Examine protocol code to see what functionalities are exposed with tokens
2. Interview a select number of protocol and product engineers to agree on interfaces that should be exposed in SnarkyJS

- [x] - Brandon
- [x] - Gregor
- [x] - Matthew
- [x] - Izaak

3. Finalize RFC","[('MartinMinkov', '# Tokens RFC\r\n## Overview\r\nCustom tokens are supported at a protocol level, and we wish to bring that functionality to SnarkyJS. Custom tokens are denoted by a token identifier which is used to distinguish between different tokens and a token account. A token account is similar to a regular account, but its balance is stored in the chosen custom token. One may use the same public key for multiple token accounts for different custom tokens.\r\n\r\nIn addition to token accounts, there is a notion of a token owner account. The token owner account is the owner of a custom token and supervises the behavior of accounts whose balance is stored in that custom token. They are the only account that can provide certain invariants on a custom token before the supervised accounts are updated. The token owner must be included in the Party\'s transaction layout of a custom token transaction for the update to be authorized.\r\n\r\nToken owner accounts are created by specifying a public key and a token identifier. For the purposes of most token owner accounts, using the default, MINA token identifier can be used to derive a new custom token identifier.  \r\n\r\nIn this RFC, we propose a bare-bones API for SnarkyJS to support creating token accounts and transacting in custom tokens. \r\n\r\n**Note**: Tokens cannot be used to pay for fees or be used in stake delegations.\r\n\r\n## Creating Token Accounts\r\nGiven an existing account, a new token account is created by simply receiving a payment denoted in a custom token. When such a transaction occurs, the protocol will create a token account for the public key receiving the new custom token.\r\n\r\nWhen one wants to create a new custom token, it must be derived from an existing account and an existing token identifier. If an existing public key is specified in deriving a new custom token, that public key will be the token owner. The native MINA token identifier can be used when setting an existing token identifier. In this model, developers will want their zkApp to be the token owner of their custom token to automate any authorization for other users to interact.\r\n\r\nTo derive a new custom token identifier from a public key and an existing token identifier, we can expose a function that will accept a public key and token identifier and spit out a new custom token identifier. This new custom token identifier can be used by the specified public key to mint new tokens.\r\n\r\n```ts\r\nimport { createNewTokenId } from ""snarkyjs"";\r\n\r\n// Create a new token identifier\r\nconst newToken = createNewTokenId({\r\n    owner: PrivateKey.random().toPublicKey(),\r\n    tokenId: Token.defaultTokenId, // This can be optional\r\n});\r\n\r\n// New token will be encoded as a base58 field element\r\nconsole.log(newToken);\r\n```\r\n\r\nOne thing to note about `createNewTokenId` is that it\'s _derived_ from the owner and the token identifier. This means that no transaction is needed to broadcast to create a new token and can be recomputed from the public key and token identifier each time since it is a deterministic process.\r\n\r\n\r\n## Transferring tokens\r\nTo support an easy way for zkApps to send transactions to other accounts, we should expose a function that abstracts the details of creating a Parties transaction manually for balance changes. Such a function could look like this:\r\n\r\n```ts\r\nclass TransferExample extends SmartContract {\r\n    ...\r\n    @method sendTokens(recieverAddress: PublicKey) {\r\n        // Create a Party structure for the receiever\r\n        let receiverParty = Party.createUnsigned(recieverAddress);\r\n        // Inside a zkApp smart contract method, send to the \'receiverAddress\'\r\n        this.transfer({\r\n            to: receiverParty,\r\n            amount: 100_000,\r\n        })\r\n    }\r\n}\r\n\r\n...\r\nlet zkapp = new TransferExample(zkappAddress);\r\n// Create a transaction specifying a transfer\r\ntxn = await Local.transaction(feePayer, () => {\r\n    zkapp.sendTokens(privilegedKey);\r\n    zkapp.sign(zkappKey);\r\n});\r\nawait tx.send();\r\n```\r\n\r\nThis `transfer` function would create a Parties transaction that specifies the zkApp as the sender and the receiver address for an amount of `100_000`. The Party\'s transaction output would contain the fee payer, the parties involved in transferring, and an optional memo.\r\n\r\n## Minting/Burning Tokens\r\nThe token owner account has permission to mint/burn from any account that holds a balance for its custom token. Given that the token owner must be the one to authorize such transactions, the token owner must be specified in the Party\'s structure when it\'s sent to the protocol layer. To enable minting/burning, we can simply reuse the `this.transfer` function in the following way:\r\n\r\n```ts\r\n// ... code as before\r\nlet customToken = createNewTokenId({\r\n    address: this.address,\r\n    tokenId: defaultMinaTokenId(),\r\n});\r\n\r\n// This will mint 100,000 tokens to the receiverParty address\r\nthis.transfer({\r\n    to: receiverParty,\r\n    amount: 100_000, // To burn, we simply negate this value\r\n    tokenId: customToken, // Will default to the default MINA ID if not used\r\n});\r\n\r\n```\r\n\r\nThis `transfer` call instead mints `100_000` new custom tokens for the `receieverParty`. To burn tokens for the `receiverParty`, we simply have to negate the amount that will be deducted from the custom token. \r\n\r\n**Note**: If the token owner zkApp attempts to burn more tokens than what the balance is, the transaction will fail.\r\n\r\nLet\'s assume that account `A` has received a custom token and wants to send that custom token to another account `B`. The zkApp token owner account could expose a method that handles the transfer between the two accounts to handle the authorization needed. The following code is an attempt to give an illustration to how this looks:\r\n\r\n```ts\r\n@method sendCustomTokens(senderAddress: PublicKey, recieverAddress: PublicKey) {\r\n    let senderParty = Party.createUnsigned(senderAddress);\r\n    let receiverParty = Party.createUnsigned(recieverAddress);\r\n\r\n\t// Derive a custom token ID that is owned by this operating zkApp\r\n    let customToken = createNewTokenId({\r\n        address: this.address,\r\n        tokenId: defaultMinaTokenId()\r\n    })\r\n    this.transfer({\r\n        to: receiverParty,\r\n        from: senderParty,\r\n        amount: 100_000,\r\n        tokenId: customToken\r\n    })\r\n}\r\n```\r\n\r\n## Asserting\r\nOne can ensure certain preconditions on their custom token transfers by adding `assert` methods inside their smart contract method like they could regularly. It will be up to the zkApp developer to define what kind of limitations or restrictions their custom token should behave under. One such example could look like:\r\n\r\n```ts\r\n@method mintIfNonceIsTen(recieverAddress: PublicKey) {\r\n    let receiverParty = Party.createUnsigned(recieverAddress);\r\n    receiverParty.account.nonce.assertEquals(new UInt32(10));\r\n    receiverParty.body.incrementNonce = Bool(true);\r\n    let customToken = createNewTokenId({\r\n        address: this.address,\r\n        tokenID: defaultMinaTokenId()\r\n    })\r\n    this.transfer({\r\n        to: receiverParty,\r\n        amount: 100_000,\r\n        tokenId: customToken\r\n    })\r\n}\r\n```\r\n\r\nThis sort of approach is easily extensible to whatever type of functionality you want to enable for your custom token transfers.\r\n\r\n## Open Questions\r\n- Currently, proving a transaction does not work within SnarkyJS. Does this pose a problem in any way?\r\n- This RFC proposes some ""must-haves"" for supporting tokens in SnarkyJS. Is there anything missing that is a ""must-have"" that has been missed?\r\n\r\n## TODO List\r\n[] - Implement `this.transfer` API for MINA and custom tokens\r\n[] - Implement a function to derive a custom token identifier\r\n[] - Implement API that provides helpers for custom tokens\r\n\t- Get balance of a specified token\r\n\t- Get the token owner of an existing token identifier\r\n\t- Get/set token symbol for a custom token\r\n\t- Other such helpers that are not captured here\r\n[] - Create unit tests which confirm that\r\n\t- Balances are updated correctly after using `this.transfer` with MINA tokens and custom tokens\r\n\t- Minting/Burning behaves correctly \r\n\t- Using preconditions on a zkApp token owner successfully applies preconditions when interacting with a custom token\r\n'), ('bkase', 'Nit: free functions are too hard to discover via intellisense we should export something more discoverable\r\n\r\nthis is great! We should include a discussion around which parts of erc20 and erc777 we are explicitly supporting or choosing not to support and why. From a skim, i think we should build an abstraction that fires relevant erc777 events automatically for you and maybe have this on by default to maximize interoperability for clients'), ('MartinMinkov', '# Updated API\r\nAfter some internal discussions, we have decided we want to compare/contrast different styles of APIs to understand what would be most ergonomic for users of SnarkyJS. Therefore, the core feature set is unchanged, but instead, we are proposing a different ""wrapper"" to interact with tokens.\r\n\r\n## Tokens namespace in SnarkyJS\r\nThere was a discussion about creating a namespace for tokens inside SnarkyJS to abstract out some of these functions so that they are not ""free functions"" by themselves. In addition, putting tokens inside a namespace inside SnarkyJS will allow for a better IntelliSense/discoverability experience for zkApp developers, as ""free functions"" will be somewhat hard to find with IntelliSense. The following code shows the potential differences:\r\n\r\n```ts\r\n// Old proposal\r\nimport { createNewTokenId, getOwner, getAccounts, getBalance } from ""snarkyjs"";\r\nconst newToken = createNewTokenId({...});\r\nconst owner = getOwner(newToken); // Gets the account ID that owns the specified token\r\nconst accounts = getAccounts(newToken); // Find all accounts for a specified token\r\nconst balance = getBalance({\r\n  address,\r\n  tokenId,\r\n}); // Get balance of a specified account denoted in the custom token ID\r\n\r\n// New Proposal\r\nimport { Token } from ""snarkyjs"";\r\nconst newToken = Token.createNewTokenId({});\r\n\r\n// Extra methods to be added in the namespace, maybe this makes sense to live in the Ledger namespace instead?\r\nconst owner = Token.getOwner(newToken); // Gets the account ID that owns the specified token\r\nconst accounts = Token.getAccounts(newToken); // Find all accounts for a specified token\r\nconst balance = Token.getBalance({\r\n  address,\r\n  tokenId,\r\n}); // Get balance of a specified account denoted in the custom token ID\r\n```\r\n\r\nWith the new proposal, users can type `Tokens.` in their code editor, and IntelliSense will show potential functions to use. This will be clearer for developers checking out the API instead of referencing ""free functions"" that are exported.\r\n\r\nAnother option is instead of using functions, we adopt a class-based approach for using tokens. The following code shows potential differences:\r\n```ts\r\nimport { Token } from ""snarkyjs"";\r\n\r\nconst newToken = new Token({...});\r\nconst id = newToken.id;\r\nconst ownerAddress = newToken.owner;\r\n\r\n// The following methods should be static because different token ids and addresses should be allowed to query\r\nconst owner = Token.getOwner(newToken);\r\nconst accounts = Token.getAccounts(newToken);\r\nconst balance = Token.getBalance({\r\n  address,\r\n  tokenId,\r\n});\r\n```\r\n\r\n## Splitting up `this.transfer` \r\nAfter reviewing some POC code interacting with tokens, it was brought up that `this.transfer` for a zkApp is overloaded in terms of responsibilities. Currently, `this.transfer` will handle transferring between a zkApp and a specified party, transferring between two separate parties, minting, and burning of tokens. Instead of having `this.transfer` accomplish all this, we can separate out these functions for ease of use. \r\n\r\nFirstly, we can attach a `this.token` property to zkApps. When we call `this.token`, it will return an object containing a set of functions to handle interacting with tokens plugin to the zkApp nicely. These functions will be a split-up version of `this.transfer` for better decoupling of responsibilities. \r\n\r\nThe set of functions could look something like this:\r\n```ts\r\n// Return an object with a set of functions for minting, burning, and sending tokens\r\nthis.token();\r\n\r\n// Get the token id for this given zkApp (assuming the MINA default)\r\nthis.token().id();\r\n\r\n// Get the token id for this given zkApp specifiying another token to derive from\r\nthis.token(""some-other-token-id"").id();\r\n\r\n// Mint tokens to a specified Party address\r\nthis.token().mint({\r\n  address: somePublicAddress,\r\n  amount: 100_000,\r\n});\r\n\r\n// Burn tokens of a specified Party address\r\nthis.token().burn({\r\n  address: somePublicAddress,\r\n  amount: 100_000,\r\n});\r\n\r\n// Send tokens to a specified Party address with the zkApp being the sender\r\nthis.token().transfer({\r\n  to: somePublicAddress,\r\n  amount: 100_000,\r\n  tokenId: ""custom-token-id"", // Will default to the MINA token id if nothing is specified\r\n});\r\n\r\n// Send tokens to a specified Party address with the `someOtherAddress` being the sender\r\nthis.token().transfer({\r\n  to: somePublicAddress,\r\n  from: someOtherAddress, // This defaults to `this.address` if not specified\r\n  amount: 100_000,\r\n  tokenId: ""custom-token-id"", // Will default to the MINA token id if nothing is specified\r\n});\r\n\r\n```\r\n\r\n## Renaming\r\nOne issue that was brought up was the naming of this function. Perhaps we can come up with a better name than `createNewTokenId` as this is a pretty loaded name for a function. Ideas such as `deriveTokenId` and `tokenId` were suggested, but nothing was concretely decided. This is still a point of discussion but can easily be changed, so implementation is not halted by this issue.\r\n\r\nAdditionally, the property of `tokenId` in `createNewTokenId` was not as clear as we wanted. Because tokens are derived from another existing token, perhaps it would be helpful to rename `tokenId` to something like `parentTokenId`. The code could look like:\r\n\r\n```ts\r\n// Old way\r\nlet customToken = createNewTokenId({\r\n  address: this.address,\r\n  tokenId: defaultMinaTokenId(),\r\n});\r\n\r\n// Using `deriveTokenId` name\r\nlet customToken = deriveTokenId({\r\n  address: this.address,\r\n  tokenId: defaultMinaTokenId(),\r\n});\r\n\r\n// Using `tokenId` name\r\nlet customToken = tokenId({\r\n  address: this.address,\r\n  tokenId: defaultMinaTokenId(),\r\n});\r\n\r\n// Change with `parentTokenId`\r\nlet customToken = createNewTokenId({\r\n  address: this.address,\r\n  parentTokenId: defaultMinaTokenId(),\r\n});\r\n\r\n```\r\n\r\n## Adding Useful Preconditions for Developers\r\nAnother issue that was brought up was adding an API that zkApp developers could use that adds common precondition patterns for tokens. The thought was that writing preconditions for every zkApp could become tedious, so abstracting out some common preconditions would be helpful for developers. This is a great idea but needs to be thought out more as there have been no strong recommendations on what to add. This could be added later once we understand how zkApp developers use preconditions since this is hard to predict given the current ecosystem. Some initial ideas are:\r\n1. Ensure there is a max amount of a current token being minted\r\n2. Ensure that given some on-chain state, do something in tokens as a response\r\n3. ...\r\n\r\nOne area where we can draw motivation is how Solidity developers use `require` in their smart contracts. If we can find high-level patterns useful across a different set of smart contracts, we could also apply that to SnarkyJS.\r\n\r\n## Adding Events \r\nOne feature that would be nice for users is the option for Events with tokens in SnarkyJS. For example, [Ethereum ERC 777](https://docs.openzeppelin.com/contracts/2.x/api/token/erc777#IERC777) supports several different events, most notably being:\r\n1. Sent(...)\r\n2. Minted(...)\r\n3. Burned(...)\r\n\r\nEvents are still yet to be added in SnarkyJS, so this feature will have to wait until they are added. However, once added, we can scope out adding Events for the 3 events listed above.\r\n\r\n## Open Items\r\n[] - Decide on the particular naming we want to adopt\r\n[] - Decide on the type of API we want to support (e.g., class-based, functional based?)\r\n[] - Explore potential options for preconditions API for token use cases\r\n[] - Decide what sorts of events we want to support for tokens. However, this might be better handled by the zkApp developer.'), ('mitschabaude', 'Very nice! Some notes:\r\n\r\n> this.token().id();\r\n\r\nI think `id` doesn\'t have to be a function here, could be `this.token().id`\r\n\r\n> this.token().transfer({\r\n  to: somePublicAddress,\r\n  amount: 100_000,\r\n  tokenId: ""custom-token-id"", // Will default to the MINA token id if nothing is specified\r\n});\r\n\r\nI don\'t think we should be able to pass in a token id here, and it also shouldn\'t default to the MINA token. That\'s confusing if `token()` is an object that already refers to some *specific* token id. Instead, `this.token().transfer` should always use the token id derived from `this.address`.\r\n\r\nAlso, I think this method should require the `from` field\r\n\r\nTo send MINA, I think we should have the following API, separate from the token namespace:\r\n\r\n```ts\r\nthis.send({to: someAdress, amount: 10e9 }); // send MINA from this SmartContract\r\n\r\nlet party = Party.createSigned(privateKey); // create party from a private key\r\nparty.send({ to: someAdress, amount: 10e9 }); // send MINA from the party\'s account\r\n```\r\nthe `send` method could take an additional argument, `tokenId`, to send a custom token. however, I imagine that a more convenient / typical pattern to send a custom token would be to do it directly inside a method on the token owner account with `this.token().transfer(..)`, not in a SmartContract that is called by that token owner contract.\r\n\r\nwith the `send` API, a smart contract would do this to receive MINA:\r\n```ts\r\nParty.createSigned(privateKey).send({ to: this.address, amount: 10e9 })\r\n```\r\n\r\na shortcut for that could be:\r\n\r\n```ts\r\nthis.receive({ from: privateKey, amount: 10e9 });\r\n```\r\n'), ('MartinMinkov', "">  I don't think we should be able to pass in a token id here, and it also shouldn't default to the MINA token. That's confusing if token() is an object that already refers to some specific token id. Instead, this.token().transfer should always use the token id derived from this.address.\r\nAlso, I think this method should require the from field\r\n\r\n> To send MINA, I think we should have the following API, separate from the token namespace\r\nThe send method could take an additional argument, tokenId, to send a custom token. however, I imagine that a more convenient / typical pattern to send a custom token would be to do it directly inside a method on the token owner account with this.token().transfer(..), not in a SmartContract that is called by that token owner contract.\r\n\r\n\r\n\r\nGot it! So we will have two API calls here.\r\n\r\n```ts\r\n// Sends MINA\r\nthis.send({to: someAdress, amount: 10e9 }); \r\n\r\n// Sends custom token derived from `this.address` and the MINA token identifier\r\nthis.transfer({\r\n  to: someAddress,\r\n  from: this.address,\r\n  amount: 10e9\r\n})\r\n```\r\nDid I get this correct? In addition to `this.send()` we will also have `party.send()`""), ('mitschabaude', 'yes, except that it should be `this.token().transfer(..)` instead of `this.transfer(..)`. so I propose to not have `this.transfer` at all (but *if* we have it, it should have similar semantics to `this.send` / `this.receive`, i.e. defaulting to the MINA token, while anything on `this.token(..)` has the token that\'s derived from `this.address` and the optional parent token)\r\n\r\nI don\'t have strong feelings about what to call `send` and what to call `transfer`. if anything, `transfer` feels like a ""generalization"" of send & receive and so makes sense on an API that takes both a `to` and a `from` field'), ('jasongitmail', ""I like where this has come / is going!\r\n\r\n> > this.token().id();\r\n> \r\n> I think id doesn't have to be a function here, could be this.token().id\r\n\r\nI agree `this.token().id` is more intuitive and readable, but should we be concerned with the potential for a dev to misuse this and attempt to set the value via `this.token().id = 'abc';`? @mitschabaude \r\n\r\nI don't have a strong opinion either way, just want to be sure we've recognize this as a potential failure case and are ok with it.\r\n\r\n> To send MINA, I think we should have the following API, separate from the token namespace:\r\n> \r\n> ```js\r\n> this.send({to: someAdress, amount: 10e9 }); // send MINA from this SmartContract\r\n> \r\n> let party = Party.createSigned(privateKey); // create party from a private key\r\n> party.send({ to: someAdress, amount: 10e9 }); // send MINA from the party's account\r\n> ```\r\n\r\n+1\r\n\r\n```js\r\n// send MINA\r\nthis.send({to: someAdress, amount: 10e9 }); \r\n\r\n// Sends custom token derived from `this.address` and the MINA token identifier\r\nthis.token().send({\r\n  // from: this.address, // make default, if not provided?\r\n  to: someAddress,\r\n  amount: 10e9\r\n});\r\n```\r\n- It seems more intuitive to use the same word (`send` or `transfer`) for when sending either Mina or custom tokens. \r\n- Is the `from` property necessary for the latter? We could default to `this.address` and it'd feel intuitive and mirror `this.send()`\r\n\r\n""), ('bkase', ""I think it's too unintuitive to default `from` to `this.address` for either tokens or normal Mina, I think this really hurts understandability -- also devs can write their own helper function if they're annoyed at having to write out the from explicitly.\r\n\r\nI agree with Jason, shouldn't we stick to the same name? (transfer is best I think)""), ('jasongitmail', ""> I think it's too unintuitive to default from to this.address for either tokens or normal Mina, I think this really hurts understandability \r\n\r\nI'm fine to start with it being required too. It's easy to make something optional later, harder to go from optional to required.""), ('MartinMinkov', '# Testing\r\n\r\nTo ensure that the SnarkyJS implementation of tokens is sound, there should some sort of testing story that exists. Currently, there is no integration infrastructure in the CI workflow, so we will ignore that part of the testing story for now. This leaves us with unit tests to ensure that the tokens implementation is working correctly.\r\n\r\nWe can add a new test file in the SnarkyJS repo which holds all the unit tests needed for tokens. The unit tests should confirm the following behaviors:\r\n\r\n1. A zkApp can derive a custom token successfully\r\n2. A zkApp can mint tokens for an existing account in the ledger\r\n3. A zkApp can burn tokens for an existing account, given the appropriate authorization\r\n4. A zkApp can send tokens from its own balance to another existing account\r\n5. A zkApp can facilitate an account sending tokens to another account, given the appropriate authorization\r\n6. Some basic preconditions are set around token minting/burning/sending and the transaction logic follows those preconditions\r\n7. A zkApp can facilitate minting, burning, and sending custom tokens in a single zkApp method\r\n8. ...\r\n\r\nThese unit tests can be run when the main branch is updated in the SnarkyJS repo. This will also ensure that any new changes to the SnarkyJS repo will behave up to spec.'), ('jasongitmail', 'Implemented')]"
232,"When Berkeley Testnet is live, update all QANet references to Testnet",jasongitmail,closed,Such as in the deployment section,"[('mitschabaude', 'done by https://github.com/o1-labs/snarkyjs/pull/588')]"
227,Remove spin lock in web version,mitschabaude,open,"as a follow-up to MinaProtocol/mina#10454, refactor to wait for worker asynchronously

* change `worker_run.js` / `overrideBindings` to return promises instead of doing `wait_until_non_zero`
* needs a message-answering mechanism for the worker, so that `overrideBindings` can detect when to resolve the promise
* needs to refactor the relevant methods in `bindings.js` to detect if they got a promise back from `plonk_wasm`, and if yes, use `.then` to do subsequent operations",[]
226,Web version proving fails because it uses `Atomics.wait` on the main thread,mitschabaude,closed,"same issue as documented here: https://github.com/WebAssembly/threads/issues/174
needs to be fixed by refactoring to wait for worker asynchronously, which was planned anyway as a follow-up to https://github.com/MinaProtocol/mina/pull/10454, and hopefully should be fairly easy thanks to that work",[]
224,Hammer home that you can't pull out the JS values of variables in a circuit,mitschabaude,open,"I'm increasingly of the opinion that this is the number 1 rule about how (not) to write circuits, that we have to make extremely obvious to developers:
**Don't ever read out the JavaScript value of a Field (Bool, CircuitValue, ...) inside a circuit**
It subsumes all the other gotchas like if-statements, branching using errors, etc but in a more precise way. An example for reading out the JS value is doing `field.toString()`. It's a frequent gotcha that people try to use the value of a Field / Bool to determine what constraints to add to the circuit. Example: an if-statement that depends on the value of a `Bool` --
```ts
if (bool.toBoolean()) {
  ...
}
```

It might be good to know that reading the value of variables like this will throw an error if you're compiling the smart contract. That's because they're variables - they don't have a value attached to them at compile time. `.toBoolean()` is supposed to be used on constants / outside the circuit. Because usage on variables would throw during `compile`, there isn't currently the risk that these contracts get deployed. However, since compiling of smart contracts is relatively new and takes long, many developers write large amounts of code before actually trying to compile. So in this case we should take measures to provide this feedback earlier, and also make it clearer what causes the error.

See this discord thread for more context:
From here https://discord.com/channels/484437221055922177/915745847692636181/981662842161877052
until here https://discord.com/channels/484437221055922177/915745847692636181/981822004346904606

I see two immediate action items which could become their own issues:

* Rewrite all the different error messages when you're trying to do things like `field.toString()`, `bool.toBoolean()`, `field.toBigInt()`, `field.toConstant()` during compile. These error messages should all be very clear, and refer to the common theme that reading values of variables can't be possible
* Add linter rules for all of these methods, that tell you they can't be done inside a circuit. IMO, these rules should replace the existing rules about if statements and errors, because those are not very precise (we actually use lots of if-statements and errors in our code base, which is confusing people).

Other items TBD:
* It would be very nice to have a version of `Circuit.runAndCheck()` which also quickly runs the circuit, but in an environment that behaves like `compile`. The current `runAndCheck` behaves like `prove`, where values of variables are available, and thus doesn't help preventing this gotcha. If we had this, we could use it in more places, e.g. as a sanity check when running a method in a transaction block, to catch errors early.
* Should we separate the classes of variables and constants? E.g. `Field.Variable` vs `Field`? Or `Field` vs `Field.Constant`? This would make the distinction so much clearer. Then we could establish this rule simply by, say, not having a `.toString()` method on `Field.Variable`. This would be a big project that has implications across the code base.
* There is currently the `Circuit.asProver(() => {...})` feature, which lets you read values from variables without error because the asProver callback is not run during compile. However, when we mentioned this during our first workshop, people got confused and started to write their circuit completely inside asProver blocks! Maybe we should just rename it to `runOutsideCircuit(() => {...})`. If we move to separate types for variables, they could have a method like `fieldVariable.toStringOutsideCircuit(s => {...})` which gives you the string in a callback which isn't run during compile.","[('bkase', ""> It would be very nice to have a version of Circuit.runAndCheck() which also quickly runs the circuit, but in an environment that behaves like compile. The current runAndCheck behaves like prove, where values of variables are available, and thus doesn't help preventing this gotcha. If we had this, we could use it in more places, e.g. as a sanity check when running a method in a transaction block, to catch errors early.\r\n\r\nThere is a way to do this via OCaml (at least there was with a past version of the underlying proof-system). I don't think it would be too much effort to expose this to SnarkyJS, and this is a really good idea.\r\n\r\n> Should we separate the classes of variables and constants? E.g. Field.Variable vs Field? Or Field vs Field.Constant? This would make the distinction so much clearer. Then we could establish this rule simply by, say, not having a .toString() method on Field.Variable. This would be a big project that has implications across the code base.\r\n\r\nI think it's certain that the current design of the API isn't working and we should explore more drastic changes like this. Now is the time to do it. Before there are too many zkApps in the wild. This is one potential approach; I think the design space is big and we should brainstorm a bit before implementing this.""), ('MartinMinkov', ""> Rewrite all the different error messages when you're trying to do things like field.toString(), bool.toBoolean(), field.toBigInt(), field.toConstant() during compile. These error messages should all be very clear, and refer to the common theme that reading values of variables can't be possible\r\n\r\nTo me, this sounds like the right approach, I really like it! I don't think it's good enough to rely on developer experience to catch these themselves, there should be a safeguard in place that SnarkyJS can catch and warn. Totally agree about changing the linter to accomplish this as well.\r\n\r\n> Should we separate the classes of variables and constants? E.g. Field.Variable vs Field? Or Field vs Field.Constant? This would make the distinction so much clearer. Then we could establish this rule simply by, say, not having a .toString() method on Field.Variable. This would be a big project that has implications across the code base.\r\n\r\nI'm not sure what the implications are across the code base but I really like this idea! I'm really in favour of having a more verbose API given the complexity of zk programming.\r\n\r\n> It would be very nice to have a version of Circuit.runAndCheck() which also quickly runs the circuit, but in an environment that behaves like compile. The current runAndCheck behaves like prove, where values of variables are available, and thus doesn't help preventing this gotcha. If we had this, we could use it in more places, e.g. as a sanity check when running a method in a transaction block, to catch errors early.\r\n\r\nThis is great too! If this was available, could we build tooling inside the zkapp-cli to make debugging circuits as easy as running a command?""), ('mitschabaude', ""> This is great too! If this was available, could we build tooling inside the zkapp-cli to make debugging circuits as easy as running a command?\r\n\r\nYeah that's a neat idea! I imagine we could capture *most* errors that would occur during compiling and proving in a quick-to-run command. `zk check` maybe?""), ('mitschabaude', 'partially addressed by https://github.com/o1-labs/snarkyjs/pull/998')]"
221,Create a smart contract that can give us a feel for real-world performance & test in a browser,jasongitmail,closed,,"[('mitschabaude', 'we should look at different circuit sizes and get a feel for how performance scales with that'), ('mitschabaude', 'investigate overhead added by JS and Ocaml parts vs time spent in Wasm'), ('jasongitmail', ""Gregor built a medium size example. We'll test again after the perf improvements are merged.""), ('jasongitmail', 'Gregor did this with Sudoku which Matthew calculated was medium size circuit\n')]"
219,[Leaderboard] - Manual QA of Google Sheets,MartinMinkov,closed,,[]
218,[Leaderboard] - Deploy to kubernetes as a cronjob,MartinMinkov,closed,,[]
217,[Leaderboard] - Add tests,MartinMinkov,closed,,[]
216,[Leaderboard] - Implement Challenges,MartinMinkov,closed,,[]
215,[Leaderboard] - Setup connection to Postgres database,MartinMinkov,closed,,[]
214,[Leaderboard] - Setup Google Sheets API,MartinMinkov,closed,,[]
213,Testnet Leaderboard,jasongitmail,closed,,[]
212,Int64 - Adding past `2^64` does not cause an overflow error.,MartinMinkov,closed,"**Description**
When adding past the max value for `Int64`, using `2^64`, there is no error thrown and returns `-28948022309329048855892746252171976963363056481941560715936230020276258078721`

```ts
import { Int64, Field, isReady, shutdown } from 'snarkyjs';
await isReady;

const value = Field(((1n << 64n) - 1n).toString());
const x = new Int64(value).add(new Int64(Field.one)).toString();
console.log(x); // -28948022309329048855892746252171976963363056481941560715936230020276258078721

await shutdown();

```","[('mitschabaude', 'Already fixed :D')]"
211,Int64 - `Int64(Field.one).neg()` just wraps around the max Field value,MartinMinkov,closed,"**Description**
When calling `.neg()` on `Int64(Field.one)`, it returns `28948022309329048855892746252171976963363056481941560715954676764349967630336`. 

Is this correct behavior?

```ts
import { Int64, Field, isReady, shutdown } from 'snarkyjs';
await isReady;

const x = new Int64(Field.one).neg();
console.log(x.value.toString()); // 28948022309329048855892746252171976963363056481941560715954676764349967630336

await shutdown();
```","[('mitschabaude', ""This was correct in the old representation, however, it's outdated, the PR that I merged today changed the Int64 representation from one to two field elements, and the failing tests are all fixed (in this case, I changed the test to check that toString gives '-1')"")]"
210,Group - Group.fromJSON always returns null,MartinMinkov,closed,"**Description**

In the `snarky.d.ts` TS file, the `Group` class has a method on it called `fromJSON`. [See here](https://github.com/o1-labs/snarkyjs/blob/a72606a293c7630025699fd6417659a67f9e70b8/src/snarky.d.ts#L624)

When this function is called with any type of `JSONValue`, `null` is always returned

**Reproduce:**
The following code reproduces this error:
```ts
import { Group, isReady, shutdown } from 'snarkyjs';

await isReady;

// Different enumerations of `JSONValue`
const a = Group.fromJSON(1);
const b = Group.fromJSON(true);
const c = Group.fromJSON('1');
const d = Group.fromJSON([]);
const e = Group.fromJSON([1]);
const f = Group.fromJSON([1, 1]);
console.log(a);
console.log(b);
console.log(c);
console.log(d);
console.log(e);
console.log(f);

await shutdown();
```

","[('mitschabaude', 'I guess the method should throw an error on these inputs. The proper json representation is `{x: string, y: string}`, where the string represents a Field. I also think we should stop accepting other types than string in Field.fromJSON, there should always be only one valid json representation, namely the same that toJSON returns ')]"
209,Group - Group.endoScale is not a function,MartinMinkov,closed,"**Description**

In the `snarky.d.ts` TS file, the `Group` class has a method on it called `endoScale`. [See here](https://github.com/o1-labs/snarkyjs/blob/a72606a293c7630025699fd6417659a67f9e70b8/src/snarky.d.ts#L593)

When this function is called, the following error is returned:

```file:///tmp/endo-test/build/src/index.js:3
const x = new Group(1, 1).endoScale(Scalar.random());
                          ^

TypeError: (intermediate value).endoScale is not a function
    at file:///tmp/endo-test/build/src/index.js:3:27
```

**Reproduce:**
The following code reproduces this error:
```
import { Group, Scalar, isReady, shutdown } from 'snarkyjs';

await isReady;

const x = new Group(1, 1).endoScale(Scalar.random());
console.log(x);

await shutdown();
```

","[('mitschabaude', ""I think the short term fix is to remove that function. It's commented out in the ocaml code, don't know why"")]"
205,Not always set a balance precondition when using currentAccount.balance,mitschabaude,closed,"In most cases, it's just the balanceChange that needs to be constrained, so setting balance as a precondition is often unnecessary and adds fragility.

It would be nice to create a special data type for the balance that detects if its actual value is needed: https://github.com/o1-labs/snarkyjs/issues/179#issuecomment-1137555685
","[('mitschabaude', 'closing, as I think after additional discussion in the linked issue, this is overkill')]"
204,Improve doc comments for /src/lib/encoding.ts,jackryanservia,closed,,[]
203,Improve doc comments for /src/lib/encryption.ts,jackryanservia,closed,,[]
202,Improve doc comments for /src/lib/fetch.ts,jackryanservia,closed,,[]
201,Improve doc comments for /src/lib/party.ts,jackryanservia,closed,,[]
200,Improve doc comments for /src/lib/zkapp.ts,jackryanservia,closed,,[]
199,Improve doc comments for /src/lib/mina.ts,jackryanservia,closed,,[]
198,Improve doc comments for /src/lib/int.ts,jackryanservia,closed,,[]
197,Improve doc comments for /src/lib/circuit_value.ts,jackryanservia,closed,,[]
196,Improve doc comments for /src/lib/signature.ts,jackryanservia,closed,,[]
195,Improve doc comments for /src/snarky/addons.js,jackryanservia,closed,,[]
194,Improve doc comments for /src/snarky.d.ts,jackryanservia,closed,,[]
193,Document how to include 3rd party NPM libraries in your smart contract project,jasongitmail,closed,"Easy issue. Just a short paragraph documenting it to explain how to include them and to clarify that 3rd party libraries can be used with SnarkyJS.

Include info box encouraging others to label their projects a certain way on NPM for better discovery? To discuss.

","[('jasongitmail', ""Arg same repo. Closing because tracking on MinaProtocol/docs repo but can't transfer issue to their org"")]"
192,Add sequence events docs,jasongitmail,closed,,"[('jasongitmail', 'Closed b/c moved to docs repo')]"
191,Add events docs,jasongitmail,closed,,"[('jasongitmail', 'Closed b/c moved to docs repo')]"
189,Document how to include 3rd party NPM libraries in your smart contract,jasongitmail,closed,"Easy issue. Just a short paragraph documenting it to explain how to include them and to clarify that 3rd party libraries can be used with SnarkyJS.

Include info box encouraging others to label their projects a certain way on NPM for better discovery? To discuss.","[('jasongitmail', ""Closing because moving to MinaProtocol/docs, but can't transfer to their Github org"")]"
188,Create example of using `.wait()` for keeping track of inclusion in a block,jasongitmail,closed,"And likely add to docs--to discuss.
",[]
187,Track account updates locally when creating multiple transactions,jasongitmail,open,,[]
186,Finish remaining fields of party update,jasongitmail,closed,"- [ ] Set timing
- [ ] Set delegate
- [ ] Set zkApp URI
- [ ] Set votingFor
","[('mitschabaude', ""also, have a nice API for these like\n* `this.account.zkappUri.set('http://...')`\n* `this.account.timing.set(..)`"")]"
185,"Support interactions between 2 smart contracts (i.e. composability, call stack)",jasongitmail,closed,,[]
184,Add Merkle Tree support,jasongitmail,closed,,"[('jasongitmail', 'Support for this exists under the experimental import')]"
183,Tokens support in SnarkyJS,jasongitmail,closed,,"[('jasongitmail', '1. Research desired functionality to expose\n2. Draft RFC for token API design\n3. Implement and test')]"
182,Make compatible with performance optimizations for non-recursive proof generation,jasongitmail,closed,,"[('mitschabaude', ""removed the estimate of 2 days since we're also tracking it with https://github.com/MinaProtocol/mina/issues/10716, don't want to double-count""), ('mitschabaude', 'Merged! https://github.com/MinaProtocol/mina/pull/11053')]"
181,SnarkyJS Berkeley Testnet,jasongitmail,closed,,"[('mitschabaude', ""@jasongitmail some issues that should also be in this epic: #247, #236, #141, #271, https://github.com/MinaProtocol/mina/issues/11389, #275\nI don't think #62 belongs here""), ('mitschabaude', 'also needs #300'), ('mitschabaude', 'seems that all issues in this epic are closed!')]"
180,Fix setting timestamp precondition,mitschabaude,closed,,[]
179,Account / network precondition RFC,mitschabaude,closed,"# Precondition RFC

If users want to add preconditions on the account or protocol state, these will most often relate to the _current_ on-chain state of these fields. A very intuitive model is to let users just ""use"" the current state -- for example, let them access the ""current account balance"". The mental model is that this balance is a variable (not a constant!) that depends on the current chain. It can be implemented by fetching the current balance from the chain, using it in the prover as the value for the variable, and adding a precondition which fixes the balance to exactly this value. If we wouldn't add the precondition, then the balance would be unconstrained, which would be against the intuition that we prove a computation which uses the current balance as input.

Therefore, I think a good default is to just let users access the balance (and other fields) as the property of some object, and behind the scenes add the necessary precondition. We propose the following API to achieve that:

```ts
// inside method
let balance = this.currentAccount.balance; // automagically adds a precondition
balance.assertLte(100e9); // this method can only be called if current balance <= 100 MINA
```

Note that to use this API intuitively, one doesn't need to understand the concept of a precondition at all. It's enough to be aware of the `this.currentAccount` property. The returned `balance` is a plain `UInt64` variable; the added precondition stays completely hidden. Similarly, we propose to have a `this.currentProtocolState` property which exposes protocol state preconditions. On other parties, we would have corresponding `party.currentX` properties.

However, advanced users may want to declare arbitrary preconditions. For example, in the above example, it makes sense to actually _not_ use the current balance, but just to add a precondition directly. We propose the following API:

```ts
Party.assertBetween(this.accountPrecondition.balance, 0, 100e9);
```

This works for any party, not just the `this` party. It mutates `this.accountPrecondition.balance`, which _is_ the precondition (represented as an object `{lower: UInt64, upper: UInt64}`.

The last example achieves the same as the first one -- it constrains the balance to be less than 100 MINA -- but without the fragility that the current balance needs to stay unchanged until the transaction is accepted. However, to use an API like this, you do have to understand the concept of a precondition. That's why it's OK to use more jargon (""precondition""), and make this a bit less discoverable (have to use `Party`), and let it not do any magic. Similar to `this.accountPrecondition`, we propose to expose `this.protocolStatePrecondition`, which would just be shortcuts to access `party.body.accountPrecondition` and `party.body.protocolStatePrecondition`.

In addition to `Party.assertBetween`, there is also `Party.assertEquals` (already implemented), and we could likewise add `Party.assertBelow` and `Party.assertAbove`.

Finally, you may want to _reference the current state_ when declaring an arbitrary precondition. For example, possibly you want to restrict the nonce to an interval of the form `[currentNonce, currentNonce + tolerance]`. Or you may want to restrict it to be exactly `currentNonce + 2`, because you already know that there'll be 2 earlier transactions which increment the same nonce. For this final use case, we propose the following API:

```ts
Party.assertEquals(this.accountPrecondition.nonce, this.currentAccount.nonce.add(2));
```

This is the precisely same API as before, just making use of `this.currentAccount`. The logic would be that any explicitly set precondition would override any magically inserted precondition. So, in this case, nonce == currentNonce would be overriden to nonce == currentNonce + 2.

## TODO list
* [ ] Implement the `this.current*` API and, for other parties, `party.current*`.
* [ ] Implement `this.*Precondition` and `party.*Precondition`.
* [x] Implement `Party.assertBetween`, `Party.assertEquals`
* [ ] Fetch all account preconditions from chain
* [ ] Fetch all protocol state preconditions from chain
* [ ] Create unit-tests which confirm that 
  - setting/fetching all preconditions is possible
  - set preconditions show up in the JSON transaction","[('jasongitmail', ""Thanks Gregor.\r\n\r\n1. On the naming: \r\n```\r\nthis.accountPrecondition\r\nthis.protocolStatePrecondition\r\n```\r\nGiven they're both state, how about this?\r\n```\r\nthis.accountPrecondition\r\nthis.protocolPrecondition\r\n```\r\nAnd we landed on `network precondition` during the earlier naming project, so maybe this?: \r\n```\r\nthis.accountPrecondition\r\nthis.networkPrecondition\r\n```\r\n2.  `The logic would be that any explicitly set precondition would override any magically inserted precondition. ` This makes sense, to allow overriding the magic if it exists. +1\r\n\r\n3. `Party.assertBetween(this.accountPrecondition.balance, 0, 100e9);` This feels unusual to me. \r\n\r\nAlternatively for naming, would it be possible to do something like `this.preconditions.account.balance.assertBetween(0, 100e9)` b/c it provides hierarchy in the naming or `this.accountPrecondition.balance.assertBetween(0, 100e9)`?  \r\n\r\n  Preference for the first one b/c, although it feels long, it provides hierarchy and intellisense code suggestions would guide them to know what options are available at each depth of the hierarchy as they type out `this.preconditions.account.balance`.\r\n""), ('mitschabaude', 'Thanks for the feedback @jasongitmail!\r\n\r\nMy argument for `accountPrecondition` and `protocolStatePrecondition` is that these are the same names used in the OCaml code, the graphql API, the JSON structure, the written spec [here](https://o1-labs.github.io/snapps-txns-reference-impl/target/doc/snapps_txn_reference_impl/party/struct.PartyBody.html), and probably a number of other places. I feel that naming _consistency_ is more important than choosing the ""ideal"" names (which is rather subjective). For example, a user exploring the graphql API at https://proxy.berkeley.minaexplorer.com/graphql should find the exact same field names as a user autocompleting the JS type. If `protocolStatePrecondition` in one place is suddenly called `networkPrecondition` in another place, it\'s confusing. \r\n\r\nCurrently, this consistency is achieved by autogenerating the TS types from OCaml code. Here is the autogenerated `Party` type: https://github.com/o1-labs/snarkyjs/blob/cba3f5b5e4ac6f1fdca894d97ceb11d15e875608/src/snarky/gen/parties.ts#L356\r\nAny special cases would require overriding this and make the implementation dirtier, which is another reason for me to not want it.\r\n\r\nThat doesn\'t mean that we can never add any shortcuts / alternate ways to access things in snarkyjs. But I\'m against naming tweaks like `preconditions.account` or `protocolPrecondition` that break consistency without meaningfully adding to the API.'), ('bkase', 'This is great!\r\n\r\nI agree with both @mitschabaude and @jasongitmail . Specifically, we should use the a preconditions namespace with account and network subfields _and_ change the json, graphql, the spec, and the ocaml structure to match it! While choosing names is subjective, I think there are good arguments for using the precondition namespace and referring to the protocol ones as `network` (I’ll happily enumerate them if necessary). This was an oversight when reviewing the transaction structure 😓 and highlights why it’s good to be doing these sorts of tasks before the hardfork and these structures can no longer change (so we can keep the consistency).\r\n\r\nI can try and knock out these name changes today so it hopefully won’t slow any work down.'), ('bkase', 'Additionally, I think we need to be careful with the automatic constraint; for example, this one is would make contract interaction trivially Denial-of-service-able via MEV (front-run the transaction by sending dust to the account). A safer constraint to insert would be a `>=` on the balance (then only an owner of the account can break the contract). However, inserting this constraint may be unintuitive. Off the top of my head, I don’t have a great suggestion for what to do here, but I’ll think more about it today.'), ('mitschabaude', ""Nice @bkase, yeah I'm perfectly fine with name changes when they happen across the project! 👌🏻 \r\n\r\nRegarding the other discussion -- should we have `this.accountPrecondition.balance.assertBetween(0, 100e9)`? This feels much better to me bc the name is consistent, there is just a method `assertBetween` that's added to the original (autogenerated) type.\r\n\r\nPersonally, I'm a huge fan of separating data and functions and using plain JS objects for data.. so that an `accountPrecondition` would just always be a plain object conforming to the autogenerated type:\r\nhttps://github.com/o1-labs/snarkyjs/blob/cba3f5b5e4ac6f1fdca894d97ceb11d15e875608/src/snarky/gen/parties.ts#L486 \r\n\r\nThe benefit IMHO is that this makes creating these objects much nicer:\r\n```ts\r\nlet balance = { lower: UInt64.from(0), upper: UInt64.from(100e9) };\r\nlet accountPrecondition: AccountPrecondition = {\r\n  balance,\r\n  nonce,\r\n  receiptChainHash, // we have autocomplete for the property names!\r\n  delegate,  // order of properties doesn't matter!\r\n  state,\r\n  sequenceState,\r\n  provedState\r\n};\r\n```\r\nTypescript feedback is wonderful when passing objects like these around.\r\n\r\nIf, on the other hand, accountPrecondition and balance have to be a custom classes with some methods on it, we are faced with less purity / more boilerplate when creating them, and it gets more error-prone, and all the classes have to be imported:\r\n```ts\r\nlet balance = new Interval(UInt64.from(0), UInt64.from(100e9)); // have to import `Interval`to do this :(\r\nlet accountPrecondition = new AccountPrecondition(  // have to import `AccountPrecondition` to do this :(\r\n  balance,\r\n  nonce, // no nice autocomplete for the names here :(\r\n  delegate, // wait.. which came first again? delegate or receiptChainHash? :(\r\n  receiptChainHash, \r\n  state,\r\n  sequenceState,\r\n  provedState\r\n);\r\n```\r\n\r\nOk, so that's my argument for the `Party.assertBetween` thing, but I know that just having to type `.` to find methods is a _very_ nice thing about classes :D So I'm open to the discussion here!""), ('bkase', 'Finally, I think even advanced APIs should be discoverable via intellisense . I agree with you that it’s not ideal from a code organizational standpoint, but it’s one of those things where we should always to optimize for dev usability.\r\n\r\nIn this case, discoverability trumps the `new` boilerplate imo. But the constructor should definitely take a JavaScript object as a parameter so we get autocompletion of fields (and anytime a constructor or any function takes more than a handful of arguments this is a good practice)'), ('mrmr1993', ""Generally I'm in favour of the original proposal, with the proposed tweaks. One note:\r\n\r\n> Or you may want to restrict it to be exactly `currentNonce + 2`, because you already know that there'll be 2 earlier transactions which increment the same nonce. For this final use case, we propose the following API:\r\n\r\nIdeally we should be tracking the new state of the accounts part-way through transactions, so that updates from prior parties will be successful. I would expect that we should construct e.g.\r\n```\r\nbefore: app_state[0] = 4\r\nconstruct party 1: {precondition: {app_state: [new Field(4)]}, update: {app_state: [new Field(5)]}}\r\nconstruct party 2: {precondition: {app_state: [new Field(5)]}, update: {app_state: [new Field(6)]}}\r\n```\r\nif both `party 1` and `party 2` were to call `this.currentAccount.app_state = this.currentAccount.app_state.add(1)`""), ('mitschabaude', ""Agreed @mrmr1993, we should do that! It's tracked here: https://github.com/o1-labs/snarkyjs/issues/114\r\nI think it's just going to be part of a later PR, to keep scope small""), ('mrmr1993', ""I guess one other thing worth calling out: it would be nice if `balance` was 'special', so that it only gets constrained if you care about its actual value or some concrete bounds. For example,\r\n```js\r\nlet balance = this.currentAccount.balance; /* has type WeakBalance */;\r\nlet balance_value = balance.value(); /* has type Balance, adds equality precondition */\r\nbalance.assertLt(foo); /* adds/refines upper bound */\r\nbalance.assertGt(bat); /* adds/refines lower bound */\r\nthis.currentAccount.balance = this.currentAccount.balance.add(1); /* doesn't add precondition, only sets delta */\r\n```\r\n(assuming this is practical to implement). This removes a potential foot-gun where users are likely to add preconditions where none were necessary or intended.\r\n\r\nBonus points if anything that would accept a `Balance` also accepts and detects a `WeakBalance`, calling `value()` to get the actual `Balance`, but I'm not familiar enough with the API to know how feasible this is.""), ('mitschabaude', ""That's very interesting @mrmr1993! I guess this is only possible for balance, right - because that's the only field where we send the delta in the transaction and not the full new value? I agree it would be cool, but it's a bit involved and the impact not huge because it's only for balance -- so I'll save it for later as an enhancement: https://github.com/o1-labs/snarkyjs/issues/205\r\n\r\nI do think all of what you wrote is feasible""), ('45930', '> Note that to use this API intuitively, one doesn\'t need to understand the concept of a precondition at all\r\n\r\n> The last example achieves the same as the first one -- it constrains the balance to be less than 100 MINA -- but without the fragility that the current balance needs to stay unchanged until the transaction is accepted\r\n\r\nThis sounds like giving the developer a false sense of security.  An invisible precondition that will cause a transaction to fail if balance has changed (or network block height, epoch, account nonce, etc..) when all the developer means to have asserted is that the balance was less than 100 is way more confusing imo than figuring out that you need to call `assertBetween`.  Being aware of `this.currentAccount` and `Field.assertLte` sounds very similar to being aware of `this.accountPrecondition.balance` and `Party.assertBetween`.  I\'ll grant that the words ""precondition"" and ""party"" hit a little different.  I think I\'m something like the type of dev you\'re targeting with this, and for me, I find 2 different ways to do the same thing, one objectively worse but ""easier"", to be more confusing than one proper way to do it, well-documented.\r\n\r\n> Finally, you may want to reference the current state when declaring an arbitrary precondition.\r\n\r\nThis is more compelling to me.  The ergonomics of making a trade at the current price +- slippage, or submitting a transaction only valid in the current epoch are way nicer than getting explicit user input.'), ('mitschabaude', ""@qcomps That's an interesting take. But maybe the example was not ideal to make the case for an invisible precondition (I chose it to make the case for also having explicit preconditions).\r\n\r\nLet's imagine that we would expose the current balance, but not add a precondition automatically, so we would just give the user an unconstrained variable which happens to have the correct value in it. This feels like a footgun as well - how many users would understand that this variable can be _anything_ and still make the proof succeed?\r\n\r\nIf users don't do the right thing to add a precondition themselves, their smart contract could become open to attack. To me this seems worse than having a few transactions fail.\r\n\r\nSo, to me the only alternative to having an easy way to access current state, and adding strict preconditions by default, is to make a less ergonomic API that makes it very obvious that you get something that's unconstrained.\r\n\r\nAn example for such a less ergonomic API that actually already exists would be the following: we just have a method `fetchAccount(publicKey)`, which returns an account, which has a balance on it that is a constant `UInt64`. Then, we could have documentation that shows that you can do this fetch outside the method and pass the balance to the method as a parameter. Here, it would be very clear for everyone that anything can be passed in! And then the example could go on to show how to explicitly add a precondition.\r\n\r\nWould you prefer this latter way of doing it?""), ('jasongitmail', 'Great discsussion!  \r\n\r\n> I find 2 different ways to do the same thing, one objectively worse but ""easier"", to be more confusing than one proper way to do it, well-documented.\r\n\r\n> This is more compelling to me. The ergonomics of making a trade at the current price +- slippage, or submitting a transaction only valid in the current epoch are way nicer than getting explicit user input.\r\n\r\n@qcomps  +1 from a dev experience perspective \r\n\r\n> If users don\'t do the right thing to add a precondition themselves, their smart contract could become open to attack. To me this seems worse than having a few transactions fail.\r\n\r\n@mitschabaude Also really important.\r\n\r\nLet\'s keep discussing this. Maybe the compromise position to use the magic precondition only for asserting an exact balance, to prevent any foot guns and default to safety. Then others are manual and we document this as an exception. Are there any other footguns where a default precondition could be useful for safety @mitschabaude ?'), ('45930', '> Let\'s imagine that we would expose the current balance, but not add a precondition automatically, so we would just give the user an unconstrained variable which happens to have the correct value in it. This feels like a footgun as well - how many users would understand that this variable can be anything and still make the proof succeed?\r\n\r\nI definitely agree that malicious behavior succeeding is worse than unintentionally wrong behavior failing.  What is an example of worst case though?  If I write `const balance = this.account.balance; transfer(balance, caller)`, I pretty clearly want to transfer my whole balance.  Would your example `balance.assertLte(100e9)`successfully (and wrongly) prove that 200e9 is less than 100e9 without setting the precondition?  Or is the issue that you can prove it, and then at verification time it might not be true, but it will still pass?\r\n\r\nRegardless, the same people who would shoot themselves in the foot with this will also not read through this thread and will just see transactions failing.  If possible it would be preferable to fail this before deploy.  Maybe `allowUnconstrainedValues: false` could be a config value in the deploy pipeline or something like that (not mutually exclusive of this proposal).  \r\n\r\n> we just have a method fetchAccount(publicKey), which returns an account, which has a balance on it... you can do this fetch outside the method and pass the balance to the method as a parameter.\r\n\r\nWould this actually constrain account balance or just some input UInt that ought to be account balance?  I definitely prefer being able to ""use"" account.balance...  I guess the main thing I\'d prefer is to fail a lot earlier if used improperly, rather than secretly adding something the dev didn\'t write.'), ('mitschabaude', '> Would this actually constrain account balance or just some input UInt that ought to be account balance?\r\n\r\nIt wouldn\'t constrain the account balance. It\'s the behavior you were arguing for, that we shouldn\'t constrain the balance automatically, it just makes it more obvious that it\'s not doing so.\r\n\r\n> Would your example balance.assertLte(100e9)successfully (and wrongly) prove that 200e9 is less than 100e9 without setting the precondition?\r\n\r\nThe issue is that `balance` would not be not linked to the actual balance. You could set it to `0` by changing one line of code. Then you would successfully prove that 0 is lower than 100e9, while the account balance could still happily be 200e9.\r\n\r\n>  If I write const balance = this.account.balance; transfer(balance, caller), I pretty clearly want to transfer my whole balance.\r\n\r\nOk, say you write\r\n\r\n```ts\r\nconst tenPercentOfMyBalance = this.account.balance.div(10);\r\ntransfer(tenPercentOfMyBalance, caller);\r\n```\r\nThen you clearly want to transfer 10% of your balance. However, if `this.account.balance` can be anything, a malicious actor could set it to 10x your balance, and successfully pull out all your money.\r\n\r\nIMO, if we give users a field that says ""this.account.balance"", we owe them that it\'s actually constrained to their balance.\r\n\r\nBy the way, just to make this explicit, balance is just an example in this whole thread. The same discussion applies to other account fields like state, nonce, sequenceState, provedState etc, and protocol state fields like blockchainLength, timestamp, totalCurrency etc.\r\n\r\nWe already have a magical API for on-chain state. We allow users to write\r\n\r\n```ts\r\nlet x = this.x.get();\r\nthis.x.set(x.add(1));\r\n```\r\nThis should mean the following: It sets your new state to +1 the old state. If `x` can be anything, it would allow users to set the new state to anything. The snark would be worthless. We have to fix `x` to the current state, IMO -- or force users to explicitly add a precondition for `x` themselves.\r\n\r\n>  I definitely prefer being able to ""use"" account.balance... I guess the main thing I\'d prefer is to fail a lot earlier if used improperly, rather than secretly adding something the dev didn\'t write.\r\n\r\nThis is great feedback - errors instead of magic. I\'ve been thinking about a new proposal which moves in that direction. Will write more soon'), ('mitschabaude', ""# Precondition RFC, version 2\r\n\r\nIn light of the discussion so far, I propose an alternate API, which forces users to add preconditions themselves instead of doing it secretly. The new proposal also does away with magic property access which secretly runs logic, and instead strives to be boring and explicit, while being also fairly simple and discoverable.\r\n\r\nWe consolidate account / network preconditions under a single field, `this.account` and `this.network`. Using account / network fields looks like this:\r\n\r\n```ts\r\nlet myBalance = this.account.balance.get();\r\n// should be equal to my actual balance\r\nthis.account.balance.assertEquals(myBalance);\r\n// ... doing arbitrary computations with the balance\r\n\r\nlet chainLength = this.network.blockchainLength.get();\r\n// should be not more than the current length + 5\r\nthis.network.blockchainLength.assertBetween(chainLength, chainLength.add(5));\r\n```\r\n\r\n`this.account.balance.get()` does the following: It fetches the balance from chain and creates a variable with that value in it. It does NOT link it to the current balance in the snark circuit. Instead, explicit `assertEquals` or `assertBetween` is necessary to create that link.\r\n\r\nTo make this not a footgun, we throw an error if the user doesn't add any explicit precondition on the field. The error is thrown when compiling, proving, or running the smart contract method in any other way. Example:\r\n\r\n```ts\r\n@method payout(caller: PublicKey) {\r\n  let balance = this.account.balance.get();\r\n  this.transfer(balance.div(10), caller); // tentative API to send money from the zkapp account\r\n}\r\n// ...\r\n\r\nMyContract.compile(zkappAddress); // throws an error!\r\n```\r\n\r\nRunning this would throw:\r\n\r\n```\r\nError: You used `this.account.balance.get()` without adding a precondition that links it to the actual balance.\r\nConsider adding this line to your code:\r\nthis.account.balance.assertEquals(this.account.balance.get());\r\nYou can also add more flexible preconditions with `this.account.balance.assertBetween`.\r\n    at /home/gregor/my-zkapp/node_modules/snarkyjs/dist/server/index.js:5039:145\r\n    ...\r\n```\r\n\r\nThe developer would hopefully read the error message and modify their code like this .. which would fix the error, and teach them about preconditions at the same time.\r\n\r\n```ts\r\n@method payout(caller: PublicKey) {\r\n  let balance = this.account.balance.get();\r\n  this.account.balance.assertEquals(balance);\r\n  this.transfer(balance.div(10), caller); // tentative API to send money from the zkapp account\r\n}\r\n```\r\n\r\n### Closing thoughts\r\n\r\nDoing away with the magic property access on `account.balance`, and using explicit `account.balance.get()` instead, enables us to add even more methods to the same property. Thus, we can have the preconditions like `assertEquals()` right next to `get()`. I find this somewhat preferable than to have an additional `this.preconditions.account` + the magic accessors on `this.account`.\r\n\r\nNote that I also changed `this.currentAccount` to `this.account`, which for me also makes more sense than before, if everything is consolidated on this one field.\r\n\r\nI think now that @mrmr1993's concern, about not constraining the balance when it doesn't have to be, is sufficiently addressed by having very visible methods like `transfer` or `send` / `receive`, which you would typically just use by putting in some amount that doesn't refer to the current balance. Only in cases like above (where delta is really computed from the current balance) would you even stumble over the error and use a precondition. To make it harder to hit those cases, we probably should NOT have a `balance.set()` method, just `balance.addInPlace()` and `balance.subInPlace()` which we already have.""), ('45930', 'As for me, I quite like version 2!'), ('jasongitmail', 'Love it. Intuitive API, errors catch footguns, and no unexpected magic. This is great.\r\n\r\n> Note that I also changed `this.currentAccount` to `this.account`, \r\n\r\n+1  '), ('bkase', 'This is great, I love this!'), ('imeckler', 'This is nice -- thanks for writing this up Gregor!')]"
177,Add Field primitive tests,ymekuria,closed,,[]
176,Add Field primitive tests,ymekuria,closed,,"[('Trivo25', 'Can this be closed? https://github.com/o1-labs/snarkyjs/blob/main/src/lib/field.test.ts'), ('mitschabaude', 'tested enough for now, closing')]"
174,Test Failures (Int.ts) - rangeCheckHelper,MartinMinkov,closed,"This issue is a tracker for all the test cases in `int.test.ts` that throws the `rangeCheckHelper`. Every test case that runs into this error has been replicated in this PR to make it easier to debug the different places `rangeCheckHelper` is throwing.

These bugs are surfaced from https://github.com/o1-labs/snarkyjs/pull/164

**UInt64**

`assertLt`
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""1<2=true"", () => {
  expect(() => {
    Circuit.runAndCheck(() => {
      const x = Circuit.witness(UInt64, () => new UInt64(Field.one));
      const y = Circuit.witness(UInt64, () => new UInt64(Field(2)));
      x.assertLt(y);
    });
  }).not.toThrow();
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it.skip(""1000<100000=true"", () => {
  expect(() => {
    Circuit.runAndCheck(() => {
      const x = Circuit.witness(UInt64, () => new UInt64(Field(1000)));
      const y = Circuit.witness(UInt64, () => new UInt64(Field(100000)));
      x.assertLt(y);
    });
  }).not.toThrow();
});

```

assertGt
```ts
it.skip(""2>1=true"", () => {
  expect(() => {
    Circuit.runAndCheck(() => {
      const x = Circuit.witness(UInt64, () => new UInt64(Field(2)));
      const y = Circuit.witness(UInt64, () => new UInt64(Field.one));
      x.assertGt(y);
    });
  }).not.toThrow();
});

```

lt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""1<2=true"", () => {
  expect(new UInt64(Field.one).lt(new UInt64(Field(2)))).toEqual(Bool(true));
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it.skip(""1000<100000=true"", () => {
  expect(new UInt64(Field(1000)).lt(new UInt64(Field(100000)))).toEqual(
    Bool(true)
  );
});

```

lte
```ts
it.skip(""1000<=100000=true"", () => {
  expect(new UInt64(Field(1000)).lte(new UInt64(Field(100000)))).toEqual(
    Bool(true)
  );
});

```
gt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
        it.skip('2>1=true', () => {
          expect(new UInt64(Field(2)).gt(new UInt64(Field.one))).toEqual(
            Bool(true)
          );
        });
        
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
        it.skip('1>2=false', () => {
          expect(new UInt64(Field.one).lt(new UInt64(Field(2)))).toEqual(
            Bool(false)
          );
        });
        
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
        it.skip('100000>1000=true', () => {
          expect(new UInt64(Field(100000)).gt(new UInt64(Field(1000)))).toEqual(
            Bool(true)
          );
        });
        
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
        it('100000>1000=true', () => {
          expect(
            new UInt64(Field(100000)).assertGt(new UInt64(Field(1000)))
          ).not.toThrow();
        });
```

**UInt32**

assertLt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
        it.skip('1000<100000=true', () => {
          expect(() => {
            Circuit.runAndCheck(() => {
              const x = Circuit.witness(UInt32, () => new UInt32(Field(1000)));
              const y = Circuit.witness(
                UInt32,
                () => new UInt32(Field(100000))
              );
              x.assertLt(y);
            });
          }).not.toThrow();
```

assertGt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""2>1=true"", () => {
  expect(() => {
    Circuit.runAndCheck(() => {
      const x = Circuit.witness(UInt32, () => new UInt32(Field(2)));
      const y = Circuit.witness(UInt32, () => new UInt32(Field.one));
      x.assertGt(y);
    });
  }).not.toThrow();
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""100000>1000=true"", () => {
  expect(() => {
    Circuit.runAndCheck(() => {
      const x = Circuit.witness(UInt32, () => new UInt32(Field(100000)));
      const y = Circuit.witness(UInt32, () => new UInt32(Field(1000)));
      x.assertGt(y);
    });
  }).not.toThrow();
});

```

lt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""1<2=true"", () => {
  expect(new UInt32(Field.one).lt(new UInt32(Field(2)))).toEqual(Bool(true));
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it.skip(""1000<100000=true"", () => {
  expect(new UInt32(Field(1000)).lt(new UInt32(Field(100000)))).toEqual(
    Bool(true)
  );
});

```

lte
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it.skip(""1000<=100000=true"", () => {
  expect(new UInt32(Field(1000)).lte(new UInt32(Field(100000)))).toEqual(
    Bool(true)
  );
});
```

gt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""2>1=true"", () => {
  expect(new UInt32(Field(2)).gt(new UInt32(Field.one))).toEqual(Bool(true));
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it.skip(""1>2=false"", () => {
  expect(new UInt32(Field.one).lt(new UInt32(Field(2)))).toEqual(Bool(false));
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it.skip(""100000>1000=true"", () => {
  expect(new UInt32(Field(100000)).gt(new UInt32(Field(1000)))).toEqual(
    Bool(true)
  );
});
```

assertGt
```ts
// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967630336 to fit in 64 bits
it(""2>1=true"", () => {
  expect(new UInt32(Field(2)).assertGt(new UInt32(Field.one))).not.toThrow();
});

// rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967531337 to fit in 64 bits
it(""100000>1000=true"", () => {
  expect(
    new UInt32(Field(100000)).assertGt(new UInt32(Field(1000)))
  ).not.toThrow();
});
```",[]
170,"Don't fail on method execution in ""test"" mode",mitschabaude,closed,"this fails if `currentTransaction.fetchMode === 'test'`, because a dummy account is returned, so that `x` is zero, which makes the assertion fail:
```ts
class SimpleZkapp extends SmartContract {
  @state(Field) x = State<Field>();

  deploy(args: DeployArgs) {
    super.deploy(args);
    this.x.set(initialState);
  }

  @method update(y: Field) {
    let x = this.x.get();
    x.assertGt(0);
    Circuit.asProver(() => {
      console.log('current x: ', x.toString());
    });
    y.assertGt(0);
    this.x.set(x.add(y));
  }
}
```

The ideal solution would be to let `assertGt` know that it shouldn't throw an error in this situation.

The second-best solution is to try-catch the error and give users an escape hatch to deliberately fetch the correct account first before executing","[('mitschabaude', 'added workaround, the ideal solutions seems lower prio'), ('mitschabaude', 'this would be much easier if we had `assertEquals` defined in JS'), ('mitschabaude', 'done a while ago')]"
169,[Testing] Scalar & Group,MartinMinkov,closed,,[]
168,Framework for testing SmartContracts,mitschabaude,open,"TODOs: Create a proposal / PRD for how this could look like
",[]
167,Add Bool primitive tests,ymekuria,closed,,[]
165,Document release process,mitschabaude,closed,,"[('mitschabaude', 'done, see wiki')]"
178,SnarkyJS doc comments improvements (in code),jackryanservia,closed,,"[('bkase', 'TODO: Break this up by file/module')]"
163,Identify and triage test and release details for all product projects,bkase,closed,"SnarkyJS
zkapp in Mina/SnarkyJS connective tissue
zkapp-cli
Proof of Alpha + any full zkapp projects
Faucet
Docs Website
Eslint SnarkyJS Plugin
zkApps cross-product e2e testing
zkApps Holistic Release Checklist","[('mitschabaude', 'done')]"
162,Make unit tests live next to the code,mitschabaude,closed,Find a good testing framework to enable this,"[('mitschabaude', 'we at least have a workaround to test internal stuff now, so I remove this from the sprint as it might never be done'), ('mitschabaude', ""as alluded to in the last comment, the main blocker (using internal exports in tests) is solved and we didn't see the need to pursue co-locating of tests and code further than that, it's fine if they are separate files"")]"
161,Brainstorm snarkyjs examples,mitschabaude,closed,,"[('jasongitmail', 'This looks like something that can be closed. Feel free to reopen if needed')]"
160,[Unit Testing] - Int.ts,MartinMinkov,closed,Write unit tests to test all classes/methods in `int.ts`,"[('MartinMinkov', 'Tracked with https://github.com/o1-labs/snarkyjs/pull/164')]"
159,Write snarkyjs README,mitschabaude,closed,,"[('jasongitmail', 'dupe')]"
157,Confirm full end to end user experience from zkApp > wallet > chain,jasongitmail,closed,And update related docs,[]
156,Print constraint system,mitschabaude,closed,,"[('mitschabaude', 'dupe')]"
153,Spring cleaning,jasongitmail,closed,,[]
151,Test the web version of snarkyjs in CI,mitschabaude,closed,"using puppeteer
","[('jasongitmail', 'I.e. Create an MVP integration test in a real web browser. Use the Add smart contract. Please loop in Serhii'), ('mitschabaude', 'with puppeteer!'), ('shimkiv', 'Picking up https://github.com/o1-labs/snarkyjs/issues/407'), ('shimkiv', '@mitschabaude can we close it in favour of #407 / #411 ?')]"
150,"Expose an API to verify proof transactions locally, add proofsEnabled option",mitschabaude,closed,"This should work exactly as it does in the Mina node:
* Recover a `verify` function from the base58 verification key
* Compute the transaction statement on a JSON transaction
* run verify to see if the proof is valid

We should also add a `proofsEnabled` option to the local blockchain intf, which determines the following behavior:
* whether deploy requires a verification key (i.e., whether we need to `compile`)
* whether a dummy proof is inserted automatically by `transaction.send` in place of `lazy-proof`s
* whether `transaction.send()` performs the proof validation implemented as part of this issue
",[]
148,Decryption does not work on larger data,45930,closed,"```
import { Mina, shutdown, Field, isReady, Group, Encryption, Encoding } from 'snarkyjs';
await isReady;

const Local = Mina.LocalBlockchain();
const accounts = Local.testAccounts;

const publicKey = accounts[0].publicKey
const privKey = accounts[0].privateKey

// 31 characters
const str = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
const enc = Encryption.encrypt(Encoding.Bijective.Fp.fromString(str), publicKey);
const dec = Encoding.Bijective.Fp.toString(
  Encryption.decrypt({ publicKey: enc.publicKey, cipherText: enc.cipherText }, privKey)
)

console.log(str, dec);

// 32 characters
const str2 = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
const enc2 = Encryption.encrypt(Encoding.Bijective.Fp.fromString(str2), publicKey);
const dec2 = Encoding.Bijective.Fp.toString(
  Encryption.decrypt({ publicKey: enc2.publicKey, cipherText: enc2.cipherText }, privKey)
)

console.log(str2, dec2);

```

```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
{
  value: [
    0,
    Uint8Array(32) [
      102, 92, 220,   3,  16,   2, 240, 179,
      193, 23,  86, 127, 163, 113,  64, 166,
      158, 23, 219,  96, 111, 140, 156, 221,
       38, 47, 166,  45, 138,  15,  81,  43
    ]
  ]
}
{
  value: [
    0,
    Uint8Array(32) [
      220, 233, 121, 141, 246,  21, 249,
      133, 109, 226, 138,  77, 186, 187,
      207, 148,  79, 161, 209, 246, 104,
      202, 161, 168,  42, 104, 246,  31,
       22, 255,  30,  54
    ]
  ]
}
/Projects/todolist/node_modules/.pnpm/snarkyjs@0.3.1/node_modules/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:3100
      `)],Gb=[0,[2,0,[11,w0("": Got mismatched lengths, ""),[4,0,0,0,[11,w0("" != ""),[4,0,0,0,0]]]]],w0(""%s: Got mismatched lengths, %d != %d"")],zp=[0,[11,w0(""Scalar.""),[2,0,[11,w0("" can only be called on non-witness values.""),0]]],w0(""Scalar.%s can only be called on non-witness values."")],O2=[0,w0(""src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml""),593,21],Su=[0,w0(""src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml""),581,34],X4=[11,w0("" to fit in ""),[4,0,0,0,[11,w0("" bits""),0]]],Q8=[0,0],Pb=[0,w0(""src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml""),410,33],Cp=[0,[11,w0(""Value ""),[2,0,[11,w0("" did not fit in ""),[4,0,0,0,[11,w0("" bits""),0]]]]],w0(""Value %s did not fit in %d bits"")],Du=[0,[11,w0(""Expected array of length ""),[4,0,0,0,0]],w0(""Expected array of length %d"")],Th=[0,[11,w0(""array_get_exn: index=""),[4,0,0,0,[11,w0("", length=""),[4,0,0,0,0]]]],w0(""array_get_exn: index=%d, length=%d"")],Uk=[0,[11,w0('Type ""'),[2,0,[11,w0('"" cannot be converted to a boolean'),0]]],w0('Type ""%s"" cannot be converted to a boolean')],Qy=[0,[11,w0('Type ""'),[2,0,[11,w0('"" cannot be converted to a field element'),0]]],w0('Type ""%s"" cannot be converted to a field element')],G3=[0,w0(""ofField"")],K$=[0,w0(""hash""),w0(""spongeSqueeze""),w0(""spongeCreate""),w0(""spongeAbsorb"")],Hk=[0,w0(""spongeSqueeze""),w0(""spongeCreate""),w0(""spongeAbsorb""),w0(""hash"")];function MS(Ln){var V1=F0(Ln);return Cz[1].log(V1)}function yg(Ln){return Cz[1].log(Ln)}function M3(Ln){var V1=F0(Ln),Ta=new X5[32](V1);return Me(X5[34],Ta)}function Vq(Ln){return _0(w8[232],M3,Ln)}function YC(Ln){return Ln}function u1(Ln){return Ln}function QC(Ln){var V1=x0(typeof Ln);if(se(V1,x3)){if(se(V1,Gs)){if(se(V1,Nl)){if(se(V1,O3))return M3(_0(w8[244],Qy,V1));var Ta=x0(Ln);try{var sf=0;if(2<=O0(Ta)){var T2=yt(Ta,0);if(_0(Xw[8],T2,48)){var E4=yt(Ta,1),vl=Me(Xw[5],E4);if(_0(Xw[8],vl,120)){var D4=_0(Bc[3][17][23],0,Ta),Td=Me(Bc[3][19],D4);sf=1}}}if(!sf)var Td=Me(Zi[4][9][1][40],Ta);var r9=Me(Zi[4][9][7],Td);return r9}catch($q){if($q=Be($q),$q[1]===W9[7]){var Zh=$q[2];return M3(Zh)}throw $q}}var xy=X5[50][1].Array.isArray(Ln)|0;if(xy)return Ln;var _w=function($q){return M3(Vn)};return _0(X5[6][8],Ln.value,_w)}if(Me(sk[16],Ln)){var GS=Ln|0;if(0<=GS)return Me(Zi[4][9][17],GS);var Aq=Me(Zi[4][9][17],-GS|0);return Me(Zi[4][9][12],Aq)}return M3(Q1)}var UC=Ln|0;return UC?Zi[4][9][18]:Zi[4][9][19]}var Dq=De(V6),$1=Dq(I0(QC));function Yw(Ln){var V1=x0(typeof QC);if(se(V1,Gf))return new $1(Ln);var Ta=X5[50][1].Array,sf=Ta.isArray(QC)|0;return sf?new $1(Ln):Ln}var Xk=[0,YC,u1,QC,$1,$1,Yw],W5=Xk[4],Pj=Xk[5];function LM(Ln){if(Ln[0]===0){var V1=Ln[1];return[0,_0(Zi[4][9][1][26],Zi[4][9][1][17],V1)]}return 0}function AD(Ln){return Ln}function $C(Ln){return Ln}function D_(Ln){return Ln}function RE(Ln){var V1=x0(typeof Ln);if(se(V1,_i)){if(se(V1,yc))return M3(_0(w8[244],Uk,V1));var Ta=X5[50][1].Array,sf=Ta.isArray(Ln)|0;if(sf)return Ln;var T2=function(vl){return M3(So)};return _0(X5[6][8],Ln.value,T2)}var E4=Ln|0;return Me(Zi[4][8][13],E4)}var Lc=[0,AD,$C,D_,RE],$V=De(Xn),Xj=$V(I0(Lc[4]));function B8(Ln){var V1=new X5[14];return V1.push(Ln),V1}function yC(Ln,V1,Ta){if(Ta[0]===0){var sf=Ta[1];return Me(V1,sf)}return Me(Ln,Ta)}function I$(Ln,V1,Ta,sf){if(Ta[0]===0&&sf[0]===0){var T2=sf[1],E4=Ta[1];return _0(V1,E4,T2)}return _0(Ln,Ta,sf)}function Qp(Ln,V1){function Ta(T2){return M3(E0(w8[244],Th,V1,Ln.length))}var sf=_0(X5[16],Ln,V1);return _0(X5[6][8],sf,Ta)}function Im(Ln,V1){var Ta=_0(w8[93],Ln.length,V1);return Ta&&M3(_0(w8[244],Du,V1))}function UB(Ln,V1,Ta){var sf=Ln.prototype;return sf[F0(V1)]=L0(Ta)}function yV(Ln,V1,Ta){var sf=Ln.prototype,T2=De(Iu),E4=T2(I0(Ta));return sf[F0(V1)]=E4}function Gi(Ln){var V1=Me(Xk[1],Ln);return new Pj(V1)}function WB(Ln){return Ln.value}function wV(Ln){return Gi(Me(Zi[4][9][7],Ln))}function WA(Ln,V1){return UB(W5,Ln,V1)}function wC(Ln){if(Ln[0]===0)var V1=Ln[1],Ta=V1;else var Ta=Me(Zi[4][10][3],Ln);return F0(Me(Zi[4][9][1][41],Ta))}function VP(Ln,V1){return WA(Ln,function(Ta){return Gi(Me(V1,Ta.value))})}function KP(Ln,V1){return WA(Ln,function(Ta,sf){var T2=Me(Xk[3],sf);return Gi(_0(V1,Ta.value,T2))})}function BD(Ln,V1){var Ta=_0(Zi[4][9][1][20],Ln,V1);return Me(Zi[4][9][7],Ta)}var YV=Zi[4][9][13];function MC(Ln,V1){return I$(YV,BD,Ln,V1)}function GR(Ln,V1){var Ta=_0(Zi[4][9][1][39],Ln,V1);return Me(Zi[4][9][7],Ta)}var S_=Zi[4][9][22];function Tn(Ln,V1){return I$(S_,GR,Ln,V1)}function $c(Ln){var V1=Me(Zi[4][9][1][24],Ln);return Me(Zi[4][9][7],V1)}var Ca=Zi[4][9][25];function Si(Ln){return yC(Ca,$c,Ln)}KP(An,Zi[4][9][11]),KP(L_,MC),KP(Qi,Tn),KP(M4,Zi[4][9][20]),VP(Ql,Zi[4][9][12]),VP(C8,Zi[4][9][23]),VP(y5,Zi[4][9][21]),VP(u4,Si),WA(N2,function(Ln){return wC(Ln.value)}),WA(Qs,function(Ln){return 1}),WA(P3,function(Ln){return B8(Ln)});var w2=Zi[4][9][2]-2|0;function Oi(Ln){var V1=Ln[2],Ta=Ln[1];return WA(Ta,function(sf,T2){var E4=Me(Xk[3],T2);return E0(V1,w2,sf.value,E4)})}function Mu(Ln){var V1=Ln[2],Ta=Ln[1];return WA(Ta,function(sf,T2){var E4=Me(Xk[3],T2),vl=Me(V1,E0(Zi[4][9][33],w2,sf.value,E4)),D4=Me(Lc[1],vl);return new Xj(D4)})}var Hs=0,$3=[0,[0,Fi,function(Ln){var V1=Ln[1];return Me(Zi[4][8][4],V1)}],Hs],y6=[0,[0,Co,function(Ln){var V1=Ln[2];return Me(Zi[4][8][4],V1)}],$3],Ox=[0,[0,$f,function(Ln){var V1=Ln[2];return V1}],y6],zv=[0,[0,Kc,function(Ln){var V1=Ln[1];return V1}],Ox],G9=Mx[8];(function(Ln){return _0(G9,Ln,Mu)})(zv),_0(Mx[8],[0,[0,x2,Zi[4][9][40][3]],[0,[0,Lu,Zi[4][9][40][1]],[0,[0,Q2,Zi[4][9][40][4]],[0,[0,zf,Zi[4][9][40][2]],0]]]],Oi),WA(v5,function(Ln,V1){try{var Ta=Me(Xk[3],V1),sf=_0(Zi[4][9][40][6],Ln.value,Ta);return sf}catch{return yg(Ln),yg(Me(Xk[6],V1)),M3(Ws),0}}),WA(Ns,function(Ln){var V1=_0(Zi[4][5][1],0,Ln.value);return _0(Zi[4][16],0,V1)}),WA(w5,function(Ln){var V1=_0(Zi[4][9][27],Ln.value,Zi[4][9][19]),Ta=Me(Lc[1],V1);return new Xj(Ta)}),yV(W5,H5,function(Ln,V1){function Ta(D4){return Zi[4][9][2]}var sf=_0(X5[6][8],V1,Ta);function T2(D4,Td){var r9=new X5[14];function Zh(xy){var _w=Me(D4,xy),GS=Me(Lc[1],_w),Aq=new Xj(GS);return r9.push(Aq),0}return _0(Mx[8],Td,Zh),r9}var E4=Ln.value;function vl(D4){var Td=Me(Zi[4][9][1][42],D4),r9=_0(Mx[55],Td,sf),Zh=r9[2],xy=r9[1];function _w(Aq){return Aq}if(_0(Mx[12],Zh,_w)){var GS=Me(Zi[4][9][1][41],D4);M3(E0(w8[244],Cp,GS,sf))}return T2(Zi[4][8][13],xy)}return yC(function(D4){var Td=_0(Zi[4][9][32],D4,sf);return T2(function(r9){return r9},Td)},vl,E4)}),WA(zs,function(Ln,V1){var Ta=Me(Xk[3],V1),sf=_0(Zi[4][9][27],Ln.value,Ta),T2=Me(Lc[1],sf);return new Xj(T2)});function Yp(Ln,V1){var Ta=I0(function(sf){return Gi(Me(V1,Me(Xk[3],sf)))});return W5[F0(Ln)]=Ta}function _k(Ln,V1){var Ta=I0(function(sf,T2){var E4=Me(Xk[3],T2);return Gi(_0(V1,Me(Xk[3],sf),E4))});return W5[F0(Ln)]=Ta}W5.one=Gi(Zi[4][9][18]),W5.zero=Gi(Zi[4][9][19]),W5.random=I0(function(Ln){var V1=Me(Zi[4][9][1][29],0);return Gi(Me(Zi[4][9][7],V1))}),_k(Lo,Zi[4][9][11]),_k($u,MC),_k(s4,Zi[4][9][20]),_k(K8,Tn),Yp(C6,Zi[4][9][12]),Yp(G4,Zi[4][9][23]),Yp(Cu,Zi[4][9][21]),Yp(y8,Si),W5.toString=I0(function(Ln){return wC(Me(Xk[3],Ln))}),W5.sizeInFields=I0(function(Ln){return 1}),W5.toFields=I0(function(Ln){var V1=Me(Xk[6],Ln);return V1.toFields()}),W5.ofFields=I0(function(Ln){return Im(Ln,1),Qp(Ln,0)}),W5.assertEqual=I0(function(Ln,V1){var Ta=Me(Xk[3],V1),sf=Me(Xk[3],Ln);return _0(Zi[4][9][40][6],sf,Ta)}),W5.assertBoolean=I0(function(Ln){var V1=Me(Xk[3],Ln),Ta=_0(Zi[4][5][1],0,V1);return _0(Zi[4][16],0,Ta)}),W5.isZero=I0(function(Ln){var V1=Zi[4][9][19],Ta=Me(Xk[3],Ln),sf=_0(Zi[4][9][27],Ta,V1),T2=Me(Lc[1],sf);return new Xj(T2)}),W5.ofBits=I0(function(Ln){try{var V1=function(Td){var r9=Me(Lc[4],Td);if(r9[0]===0){var Zh=r9[1];return _0(Zi[4][9][1][26],Zi[4][9][1][17],Zh)}return Me(w8[6],Hu)},Ta=_0(sv[48],B0(Ln),V1),sf=Me(sv[29],Ta),T2=Me(Zi[4][9][1][43],sf),E4=Gi(Me(Zi[4][9][7],T2));return E4}catch{var vl=function(r9){var Zh=Lc[4];function xy(GS){throw[0,Al,Pb]}var _w=_0(X5[16],Ln,r9);return E0(X5[6][7],_w,xy,Zh)},D4=_0(Mx[113],Ln.length,vl);return Gi(Me(Zi[4][9][16],D4))}});var Vg=De(y7);W5.toBits=Vg(I0(Xk[6])),W5.equal=I0(function(Ln,V1){var Ta=Me(Xk[3],V1),sf=Me(Xk[3],Ln),T2=_0(Zi[4][9][27],sf,Ta),E4=Me(Lc[1],T2);return new Xj(E4)});function Vw(Ln,V1){return W5[F0(Ln)]=I0(V1)}var Lw=Zi[4],Sx=Me(T5[5],[0,Lw[2],Lw[3],Lw[4],Lw[5],Lw[6],Lw[7],Lw[8],Lw[9],Lw[10],Lw[11],Lw[12],Lw[13],Lw[14],Lw[15],Lw[16],Lw[17],Lw[18],Lw[19],Lw[20],Lw[21],Lw[22],Lw[23],Lw[24],Lw[25],Lw[26],Lw[27],Lw[28],Lw[29],Lw[30],Lw[31],Lw[32],Lw[33],Lw[34],Lw[35],Lw[36],Lw[37],Lw[38],Lw[39],Lw[40],Lw[41],Lw[42],Lw[43],Lw[44],Lw[45],Lw[46],Lw[47],Lw[48]]);WA(Bb,function(Ln){return Gi(Me(Sx,Ln.value))}),WA(Av,function(Ln,V1){var Ta=Ln.value;if(Ta[0]===0){var sf=Ta[1],T2=Me(Zi[4][4][1],sf),E4=Zi[4][9][2]-1|0;if(!(E4<V1))for(var vl=V1;;){if(_0(Zi[4][4][2],T2,vl)){var D4=[0,[11,Ai,[24,Q8,function(_w,GS){var Aq=Me(Zi[4][9][1][7],GS);return _0(Jx[13],0,Aq)},X4]],Xf];M3(E0(w8[244],D4,sf,V1))}var Td=vl+1|0;if(E4!==vl){var vl=Td;continue}break}return Ln}var r9=Zi[4],Zh=E0(N7[2],[0,V1],[0,r9[2],r9[3],r9[4],r9[5],r9[6],r9[7],r9[8],r9[9],r9[10],r9[11],r9[12],r9[13],r9[14],r9[15],r9[16],r9[17],r9[18],r9[19],r9[20],r9[21],r9[22],r9[23],r9[24],r9[25],r9[26],r9[27],r9[28],r9[29],r9[30],r9[31],r9[32],r9[33],r9[34],r9[35],r9[36],r9[37],r9[38],r9[39],r9[40],r9[41],r9[42],r9[43],r9[44],r9[45],r9[46],r9[47],r9[48]],[0,Ta]),xy=Zh[3];return Gi(xy)}),WA(us,function(Ln){var V1=Ln.value;return V1[0]===0?X5[7]:X5[8]}),WA(Bd,function(Ln){var V1=Ln.value;if(V1[0]===0)var Ta=V1[1],sf=Ta;else var sf=Me(Zi[4][10][3],V1);return Gi(Me(Zi[4][9][7],sf))}),WA(Fp,function(Ln){return Ln.toString()}),Vw(Bm,function(Ln){return Ln.toJSON()}),Vw(P$,function(Ln){function V1(Aq){var UC=Me(Xk[1],Aq),$q=new Pj(UC);return Me(X5[5][2],$q)}var Ta=x0(typeof Ln);if(se(Ta,tf)){if(se(Ta,Z2)){if(se(Ta,No))return X5[5][1];var sf=x0(Ln);try{var T2=0;if(_0(w8[91],O0(sf),1)){var E4=yt(sf,0);if(_0(sd[41],E4,48)){var vl=yt(sf,1),D4=Me(sd[9],vl);if(_0(sd[41],D4,120)){var Td=_0(Bc[3][17][23],0,sf),r9=Me(Bc[3][19],Td);T2=1}}}if(!T2)var r9=Me(Zi[4][9][1][40],sf);var Zh=V1(Me(Zi[4][9][7],r9));return Zh}catch(Aq){if(Aq=Be(Aq),Aq[1]===W9[7])return X5[5][1];throw Aq}}if(Me(sk[16],Ln)){var xy=Me(Bu[33],Ln);return V1(Me(Zi[4][9][17],xy))}return X5[5][1]}var _w=Ln|0,GS=_w?Zi[4][9][18]:Zi[4][9][19];return V1(GS)});var Xl=Zi[4][8][16];function Kv(Ln,V1){if(Ln[0]===0&&V1[0]===0){var Ta=V1[1],sf=Ln[1],T2=_0(Zi[4][9][1][26],sf,Ta);return Me(Zi[4][8][13],T2)}return _0(Xl,Ln,V1)}function T$(Ln){var V1=Me(Lc[1],Ln);return new Xj(V1)}function Em(Ln,V1){return UB(Xj,Ln,V1)}function Hl(Ln,V1){return Em(Ln,function(Ta){return T$(Me(V1,Ta.value))})}function Up(Ln,V1){return Em(Ln,function(Ta,sf){var T2=Me(Lc[4],sf);return T$(_0(V1,Ta.value,T2))})}Em(sp,function(Ln){var V1=Me(Xk[1],Ln.value);return new Pj(V1)}),Hl(A3,Zi[4][8][4]),Up(U4,Zi[4][8][6]),Up(D3,Zi[4][8][8]),Em(s7,function(Ln,V1){var Ta=Me(Lc[4],V1);return _0(Zi[4][8][19][1],Ln.value,Ta)}),Up(J7,Kv),Em(vy,function(Ln){var V1=Ln.value;if(V1[0]===0){var Ta=V1[1];return!!_0(Zi[4][9][1][26],Zi[4][9][1][17],Ta)}try{var sf=!!_0(Zi[4][10][4],Zi[4][8][14],Ln.value);return sf}catch{return M3(Af)}}),Em(zm,function(Ln){return 1}),Em(Dd,function(Ln){var V1=Ln.value;if(V1[0]===0)var Ta=V1[1],sf=Ta;else var sf=Me(Zi[4][10][3],V1);return Me(Me(Zi[4][9][1][26],Zi[4][9][1][17]),sf)?Es:Au}),Em(Ay,function(Ln){var V1=new X5[14],Ta=Ln.toField();return V1.push(Ta),V1});function Yk(Ln,V1){return Xj[F0(Ln)]=I0(V1)}function Nq(Ln,V1){return Yk(Ln,function(Ta){return T$(Me(V1,Me(Lc[4],Ta)))})}function SC(Ln,V1){return Yk(Ln,function(Ta,sf){var T2=Me(Lc[4],sf);return T$(_0(V1,Me(Lc[4],Ta),T2))})}Yk(Od,function(Ln){var V1=Me(Lc[4],Ln),Ta=Me(Xk[1],V1);return new Pj(Ta)});var vB=[0,0,0,0];function SA(Ln,V1){if(!vB[1]){var Ta=Me(yu[16],G3),sf=_0(yu[3],Ta,K3),T2=_0(yu[7],Ta,Yu),E4=function(D4){var Td=D4[1+sf];return Me(Td[2],Td[1])};E0(yu[10],Ta,T2,E4);var vl=function(D4){var Td=_0(yu[24],0,Ta);return Td[1+sf]=D4,Td};Me(yu[17],Ta),vB[1]=vl}return Me(vB[1],[0,Ln,V1])}function zA(Ln,V1){var Ta=Me(Xk[3],V1),sf=Me(Zi[4][8][18][1],Ta),T2=Me(Lc[1],sf);return new Xj(T2)}Xj.Unsafe=function(Ln,V1){return{ofField:L0(Ln)}}(zA,SA),Nq(Rl,Zi[4][8][4]),SC(Yl,Zi[4][8][6]),SC(Zd,Zi[4][8][8]),Yk(N$,function(Ln,V1){var Ta=Me(Lc[4],V1),sf=Me(Lc[4],Ln);return _0(Zi[4][8][19][1],sf,Ta)}),SC(Cb,Kv),Yk(Qd,function(Ln){function V1(E4){var vl=Lc[4];function D4(r9){throw[0,Al,Su]}var Td=_0(X5[16],Ln,E4);return E0(X5[6][7],Td,D4,vl)}var Ta=_0(Mx[113],Ln.length,V1),sf=Me(Zi[4][9][10],Ta),T2=Me(Xk[1],sf);return new Pj(T2)}),Yk(Ym,function(Ln){return 1}),Yk(Eh,function(Ln){var V1=Me(Lc[4],Ln),Ta=Me(Xk[1],V1);return B8(new Pj(Ta))}),Yk(Dy,function(Ln){if(_0(w8[90],Ln.length,1)){var V1=function(T2){return T$(Me(Zi[4][8][18][1],T2.value))},Ta=function(T2){throw[0,Al,O2]},sf=_0(X5[16],Ln,0);return E0(X5[6][7],sf,Ta,V1)}return M3(Ro)}),Yk(ug,function(Ln){var V1=_0(Zi[4][5][1],0,Ln.value);return _0(Zi[4][16],0,V1)}),Em(Jg,function(Ln){return Ln.toBoolean()}),Yk(Mg,function(Ln){return Ln.toJSON()}),Yk(Xu,function(Ln){var V1=x0(typeof Ln);if(se(V1,Sc))return X5[5][1];var Ta=Me(Lc[3],Ln),sf=new Xj(Ta);return Me(X5[5][2],sf)});var DP=De(P4),Jq=DP(I0(Xk[6]));function xB(Ln){return Ln}function uE(Ln){var V1=Me(Xk[3],Ln.y);return[0,Me(Xk[3],Ln.x),V1]}function vM(Ln){return Ln}function wP(Ln){if(Ln instanceof Jq)return Ln;var V1=Ln.y,Ta=Ln.x;return new Jq(Ta,V1)}var Iw=[0,Jq,xB,uE,vM,wP],YA=Iw[1];function xM(Ln,V1){var Ta=Gi(V1),sf=Me(Xk[2],Ta),T2=Gi(Ln),E4=Me(Xk[2],T2);return new YA(E4,sf)}var MV=T6[4],JD=Me(SS[2][11][1],[0,MV[49],MV[25],MV[53],MV[52],MV[54],MV[55],MV[47],MV[45],MV[20]]);function zN(Ln){function V1(Ta){function sf(r9){if(r9[0]===0){var Zh=r9[1];return _0(Zi[4][9][1][26],Zi[4][9][1][17],Zh)}return Me(Ta,X5[6][1])}var T2=_0(sv[48],Ln,sf),E4=Me(sv[29],T2),vl=[0,Me(T6[4][51],E4)],D4=T6[4],Td=E0(SS[2][13],[0,D4[49],D4[25],D4[53],D4[52],D4[54],D4[55],D4[47],D4[45],D4[20]],JD,vl);return Me(X5[6][2],Td)}return Me(w8[247],V1)}var LL=De(M7),UM=LL(I0(zN));function UL(Ln){var V1=T6[4],Ta=E0(SS[2][12],[0,V1[49],V1[25],V1[53],V1[52],V1[54],V1[55],V1[47],V1[45],V1[20]],JD,Ln),sf=Ta[1],T2=Zi[4][8][13],E4=Me(T6[4][50],sf);return _0(sv[84],E4,T2)}function ZU(Ln){var V1=UL(Ln);return new UM(V1,Ln)}var uq=Zi[4][9][2];function WP(Ln,V1){return UB(UM,Ln,V1)}function sq(Ln,V1){return UM[F0(Ln)]=I0(V1)}function FT(Ln,V1){function Ta(sf){return M3(_0(w8[244],zp,Ln))}return _0(X5[6][8],V1,Ta)}function IV(Ln,V1){return WP(Ln,function(Ta){var sf=Me(V1,FT(Ln,Ta.constantValue)),T2=UL(sf);return new UM(T2,sf)})}function FC(Ln,V1){function Ta(sf){return FT(Ln,sf)}return WP(Ln,function(sf,T2){var E4=Ta(T2.constantValue),vl=_0(V1,Ta(sf.constantValue),E4),D4=UL(vl);return new UM(D4,vl)})}IV(Fd,T6[4][25]),FC(S9,T6[4][21]),FC(Jp,T6[4][23]),FC(Ed,T6[4][22]),FC(Ng,T6[4][24]),WP(xd,function(Ln){function V1(Ta){var sf=Me(Xk[1],Ta);return new Pj(sf)}return $0(_0(sv[48],Ln.value,V1))}),sq(Kp,function(Ln){return Ln.toFields()}),sq(O$,function(Ln){return uq}),sq(Ag,function(Ln){function V1(sf){return Me(Zi[4][8][18][1],sf.value)}var Ta=_0(sv[48],B0(Ln),V1);return new UM(Ta)}),sq(X7,function(Ln){var V1=Me(T6[4][32],0),Ta=UL(V1);return new UM(Ta,V1)}),sq(Q5,function(Ln){function V1(sf){var T2=Me(Lc[2],sf);return Me(Lc[4],T2)}var Ta=_0(sv[48],B0(Ln),V1);return new UM(Ta)}),WP(s9,function(Ln){function V1(T2){return T2}function Ta(T2){function E4(D4){return M3(Xc)}var vl=zN(Ln.value);return _0(X5[6][8],vl,E4)}var sf=E0(X5[6][7],Ln.constantValue,Ta,V1);return F0(Me(Zi[5][8][1][41],sf))}),sq(v7,function(Ln){return Ln.toJSON()}),sq(U9,function(Ln){function V1(Aq){var UC=UL(Aq),$q=new UM(UC,Aq);return Me(X5[5][2],$q)}var Ta=x0(typeof Ln);if(se(Ta,Of)){if(se(Ta,Ui)){if(se(Ta,_c))return X5[5][1];var sf=x0(Ln);try{var T2=yt(sf,0),E4=0;if(_0(sd[41],T2,48)){var vl=yt(sf,1),D4=Me(sd[9],vl);if(_0(sd[41],D4,120)){var Td=_0(Bc[4][17][23],0,sf),r9=Me(Bc[4][19],Td);E4=1}}if(!E4)var r9=Me(Zi[5][8][1][40],sf);var Zh=V1(r9);return Zh}catch(Aq){if(Aq=Be(Aq),Aq[1]===W9[7])return X5[5][1];throw Aq}}if(Me(sk[16],Ln)){var xy=Me(Bu[33],Ln);return V1(Me(T6[4][20],xy))}return X5[5][1]}var _w=Ln|0,GS=_w?T6[4][45]:T6[4][46];return V1(GS)});function FS(Ln){var V1=Ln[2],Ta=Ln[1],sf=Me(Xk[1],V1),T2=Me(Xk[1],Ta);return new YA(T2,sf)}function VN(Ln,V1){return UB(Jq,Ln,V1)}function CN(Ln,V1){return Jq[F0(Ln)]=V1}function Rj(Ln,V1){return CN(Ln,I0(V1))}function AM(Ln){var V1=Ln[2],Ta=Ln[1],sf=Me(Zi[4][9][7],V1);return FS([0,Me(Zi[4][9][7],Ta),sf])}VN(Hd,function(Ln,V1){var Ta=Me(Iw[3],V1),sf=Me(Iw[4],Ln),T2=Me(Iw[3],sf),E4=T2[1];if(E4[0]===0){var vl=T2[2];if(vl[0]===0){var D4=Ta[1];if(D4[0]===0){var Td=Ta[2];if(Td[0]===0){var r9=Td[1],Zh=D4[1],xy=vl[1],_w=E4[1];return AM(_0(t8[10][1][3][30],[0,_w,xy],[0,Zh,r9]))}}}}return FS(E0(t8[11][2],0,T2,Ta))}),VN(zd,function(Ln){var V1=Me(Iw[4],Ln),Ta=Me(Iw[3],V1);return FS(Me(t8[10][30],Ta))}),VN(Kb,function(Ln,V1){var Ta=Me(Iw[5],V1),sf=Ta.neg();return Ln.add(sf)}),VN(wx,function(Ln,V1){var Ta=Me(Iw[4],Ln),sf=Me(Iw[3],Ta),T2=Me(X5[6][10],V1.constantValue),E4=sf[1];if(E4[0]===0){var vl=sf[2];if(vl[0]===0&&T2){var D4=T2[1],Td=vl[1],r9=E4[1];return AM(_0(t8[10][1][3][27],[0,r9,Td],D4))}}var Zh=Me(sv[40],V1.value);Me(sv[82],Zh);var xy=Me(Iw[4],Ln),_w=Me(Iw[3],xy);return FS(_0(t8[11][5],_w,[0,Zh]))}),VN(Ev,function(Ln,V1){var Ta=Me(Iw[4],Ln),sf=Me(Iw[3],Ta),T2=sf[2],E4=sf[1],vl=Me(Iw[3],V1),D4=vl[2],Td=vl[1];return _0(Zi[4][9][40][6],E4,Td),_0(Zi[4][9][40][6],T2,D4)}),VN(Cv,function(Ln,V1){var Ta=Me(Iw[4],Ln),sf=Me(Iw[3],Ta),T2=sf[2],E4=sf[1],vl=Me(Iw[3],V1),D4=vl[2],Td=vl[1],r9=[0,_0(Zi[4][9][27],T2,D4),0],Zh=[0,_0(Zi[4][9][27],E4,Td),r9],xy=Me(Zi[4][8][11],Zh),_w=Me(Lc[1],xy);return new Xj(_w)}),CN(L6,FS(t8[10][31])),Rj(v9,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.add(V1)}),Rj(w7,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.sub(V1)}),Rj(xx,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.sub(V1)}),Rj(Mv,function(Ln){var V1=Me(Iw[5],Ln);return V1.neg()}),Rj(Sp,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.scale(V1)}),Rj(H$,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.assertEquals(V1)}),Rj(Oh,function(Ln,V1){var Ta=Me(Iw[5],Ln);return Ta.equals(V1)}),VN(Wy,function(Ln){var V1=B8(Ln.x),Ta=Ln.y;return V1.push(Ta),V1}),Rj(ty,function(Ln){return Ln.toFields()}),Rj(v$,function(Ln){Im(Ln,2);var V1=Qp(Ln,1),Ta=Me(Xk[2],V1),sf=Qp(Ln,0),T2=Me(Xk[2],sf);return new YA(T2,Ta)}),Rj($g,function(Ln){return 2}),Rj(Ks,function(Ln){return Me(t8[10][7],[0,Ln.x.value,Ln.y.value])}),VN(Kg,function(Ln){var V1=Ln.y,Ta=W5.toJSON(V1),sf=Ln.x,T2=W5.toJSON(sf);return{x:T2,y:Ta}}),Rj(Bg,function(Ln){return Ln.toJSON()}),Rj(uh,function(Ln){function V1(T2){function E4(D4){return W5.fromJSON(D4)}function vl(D4){return X5[5][1]}return E0(X5[6][7],Ln[F0(T2)],vl,E4)}function Ta(T2){function E4(D4){var Td=Me(Xk[2],D4),r9=Me(Xk[2],T2);return new YA(r9,Td)}var vl=V1(Vo);return _0(X5[5][3],vl,E4)}var sf=V1(R1);return _0(X5[5][4],sf,Ta)});function XC(Ln,V1){var Ta=Ln.length-1|0,sf=0;if(!(Ta<0))for(var T2=sf;;){Me(V1,Qp(Ln,T2));var E4=T2+1|0;if(Ta!==T2){var T2=E4;continue}break}return 0}function Lj(Ln,V1,Ta){var sf=Ln.length-1|0,T2=0;if(!(sf<0))for(var E4=T2;;){var vl=Qp(V1,E4);_0(Ta,Qp(Ln,E4),vl);var D4=E4+1|0;if(sf!==E4){var E4=D4;continue}break}return 0}function zE(Ln,V1){var Ta=new X5[14];return XC(Ln,function(sf){var T2=Me(V1,sf);return Ta.push(T2),0}),Ta}function yL(Ln,V1,Ta){var sf=new X5[14];return Lj(Ln,V1,function(T2,E4){var vl=_0(Ta,T2,E4);return sf.push(vl),0}),sf}var V9=t8[8][1],Hz=Me(t6[11],[0,[0,V9[5][19]],V9[7],V9[8],V9[6]]),M$=E$[1],vq=Me(t6[4],[0,[0,M$[4][45]],M$[5],M$[6],M$[1],M$[2],M$[3]]),Rp=Me(t6[11],vq),zk=_0(A_[5],Zi[4][9][7],Zi[4][9][1][40]),LS=_0(t6[1][9],t6[1][19],zk),QS=_0(t6[1][9],t6[1][19],Zi[4][9][1][40]);function zC(Ln){if(Ln[0]===0){var V1=Ln[1];return V1}return Me(Zi[4][10][3],Ln)}var Xp=[0,0,0,0];function ED(Ln,V1,Ta,sf,T2){if(!Xp[1]){var E4=Me(yu[16],K$),vl=_0(yu[3],E4,P2),D4=_0(yu[8],E4,Hk),Td=D4[1],r9=D4[2],Zh=D4[3],xy=D4[4],_w=function(Rr){var tn=Rr[1+vl];return Me(tn[2],tn[1])},GS=function(Rr){var tn=Rr[1+vl];return Me(tn[3],tn[1])},Aq=function(Rr){var tn=Rr[1+vl];return Me(tn[4],tn[1])},UC=[0,xy,function(Rr){var tn=Rr[1+vl];return Me(tn[5],tn[1])},r9,Aq,Zh,GS,Td,_w];_0(yu[11],E4,UC);var $q=function(Rr){var tn=_0(yu[24],0,E4);return tn[1+vl]=Rr,tn};Me(yu[17],E4),Xp[1]=$q}return Me(Xp[1],[0,Ln,T2,sf,Ta,V1])}function IT(Ln,V1){if(V1[0]===0){var Ta=V1[1];return Gi(Me(Hz[3],Ta))}var sf=V1[1],T2=Me(Rp[3],sf);return Gi(Me(Zi[4][9][7],T2))}function TD(Ln,V1,Ta){if(V1[0]===0){var sf=V1[1];return _0(Hz[2],sf,Ta.value)}var T2=V1[1],E4=zC(Ta.value);return _0(Rp[2],T2,E4)}function KD(Ln,V1){return Me(Zi[4][44],0)?[0,_0(Hz[1],0,LS)]:[1,_0(Rp[1],0,QS)]}function ML(Ln,V1){var Ta=_0(sv[48],B0(V1),WB);try{var sf=_0(Y6[9][5],0,Ta),T2=sf}catch{var E4=_0(sv[48],Ta,zC),vl=_0(Y6[6],0,E4),T2=Me(Zi[4][9][7],vl)}return Gi(T2)}var sR=function(Ln,V1,Ta,sf,T2){return{hash:L0(Ln),spongeCreate:L0(V1),spongeAbsorb:L0(Ta),spongeSqueeze:L0(sf)}}(ML,KD,TD,IT,ED),AT=De(Jh),tl=De(Gl),V$=De(Bx);function BT(Ln,V1,Ta){return _0(w8[93],V1.length,Ta.length)?M3(H0(w8[244],Gb,Ln,V1.length,Ta.length)):0}function Mt(Ln,V1,Ta,sf,T2){var E4=V1+Ta|0,vl=1+E4|0,D4=_0(w8[91],V1,0)?It(w8[244],H6,Ln,E4,V1,Ta):H0(w8[244],S2,Ln,E4,Ta),Td=It(w8[232],De,Ov,D4,vl,E4);return Td(I0(sf),I0(T2))}function RV(Ln,V1,Ta){return BT(Qu,V1,Ta),yL(V1,Ta,function(sf,T2){var E4=E0(Zi[4][9][34],Ln,sf.value,T2.value),vl=Me(Xk[1],E4);return new Pj(vl)})}function AS(Ln,V1){var Ta=De(yo);return Ta(Ln,V1)|0}function GN(Ln){var V1=X5[50][1].Object;return V1.keys(Ln)}function D1(Ln,V1){var Ta=x0(V1),sf=se(Ta,Ht)&&se(Ta,Sa)&&se(Ta,Zf)?se(Ta,y2)?(se(Ta,Ru),0):1:0;return sf?0:M3(E0(w8[244],Q3,Ta,Ln))}function Wf(Ln){var V1=X5[50][1].Array,Ta=V1.isArray(Ln);if(D1(T1,typeof Ln),Ta){var sf=zE(Ln,Wf);return sf.flat()}var T2=Ln.constructor,E4=Me(X5[6][10],T2);if(E4){var vl=E4[1],D4=function(GS){var Aq=F0(GS);return vl.hasOwnProperty(Aq)|0},Td=D4(te),r9=Td&&D4(Mr);if(r9)return vl.toFields(Ln);var Zh=function(GS){return Wf(Ln[GS])},xy=GN(Ln),_w=zE(xy.sort(),Zh);return _w.flat()}return M3(Rc)}function uu(Ln,V1){BT(Nr,Ln,V1);var Ta=Ln.length-1|0,sf=0;if(!(Ta<0))for(var T2=sf;;){var E4=Qp(V1,T2).value,vl=Qp(Ln,T2).value;_0(Zi[4][9][40][6],vl,E4);var D4=T2+1|0;if(Ta!==T2){var T2=D4;continue}break}return 0}function to(Ln,V1){var Ta=Wf(V1);return uu(Wf(Ln),Ta)}function Cx(Ln,V1,Ta){var sf=Ln.toFields(Ta);return uu(Ln.toFields(V1),sf)}var Tm=Mt(x4,0,2,Cx,to);function tu(Ln,V1){BT(_a,Ln,V1);function Ta(vl){var D4=Qp(V1,vl).value,Td=Qp(Ln,vl).value;return _0(Zi[4][9][27],Td,D4)}var sf=_0(sv[36],Ln.length,Ta),T2=Me(Zi[4][8][20][2],sf),E4=Me(Lc[1],T2);return new Xj(E4)}function s6(Ln,V1){var Ta=Wf(V1);return tu(Wf(Ln),Ta)}function t3(Ln,V1,Ta){var sf=Ln.toFields(Ta);return tu(Ln.toFields(V1),sf)}var H3=Mt(Jv,0,2,t3,s6);function W7(Ln,V1,Ta,sf){var T2=Me(Lc[4],Ln);if(T2[0]===0){var E4=T2[1];return _0(Zi[4][9][1][26],Zi[4][9][1][17],E4)?Ta:sf}var vl=V1.toFields(Ta),D4=V1.toFields(sf),Td=RV(T2,vl,D4);return V1.ofFields(Td)}function s8(Ln,V1,Ta){D1($r,typeof V1),D1(E_,typeof Ta);var sf=X5[50][1].Array,T2=sf.isArray(V1),E4=X5[50][1].Array,vl=E4.isArray(Ta);if(T2){if(vl)return yL(V1,Ta,function(Vc,Hc){return s8(Ln,Vc,Hc)})}else if(!vl){var D4=V1.constructor,Td=Ta.constructor;1-AS(D4,Td)&&M3(uc);var r9=Me(X5[6][10],Td),Zh=Me(X5[6][10],D4);if(Zh){if(r9){var xy=Zh[1],_w=function(Vc){var Hc=F0(Vc);return xy.hasOwnProperty(Hc)|0},GS=_w(Bi),Aq=GS&&_w(Br);if(Aq)return W7(Ln,xy,V1,Ta);var UC=GN(V1),$q=UC.sort(),Rr=GN(Ta),tn=Rr.sort(),_1=x0(tn.join("", "")),P1=x0($q.join("", ""));BT(E0(w8[244],Ff,P1,_1),$q,tn),Lj($q,tn,function(Vc,Hc){var Vi=1-AS(Vc,Hc);return Vi&&M3(wc)});var C_=new xy;return XC($q,function(Vc){return C_[Vc]=s8(Ln,V1[Vc],Ta[Vc])}),C_}}else if(!r9)return M3(Ri);throw[0,Al,Ja]}return M3(Ma)}var wd=Mt(Z3,1,2,W7,s8);function Kl(Ln){function V1(UC,$q){var Rr=B0(Ln.toFields($q)),tn=sv[48];return _0(tn,Rr,function(_1){return Me(UC,_1.value)})}function Ta(UC,$q){function Rr(_1){var P1=Me(UC,_1),C_=Me(Xk[1],P1);return new Pj(C_)}var tn=$0(_0(sv[48],$q,Rr));return Ln.ofFields(tn)}var sf=Zi[4][9][7];function T2(UC){return Ta(sf,UC)}function E4(UC){var $q=Me(Zi[4][9][8],UC);return H0(vb[49],0,0,0,$q)}function vl(UC){return V1(E4,UC)}var D4=Zi[4][9][41],Td=Ln.sizeInFields(),r9=_0(Zi[4][7][7],Td,D4),Zh=E0(Zi[4][7][9],r9,vl,T2),xy=Zi[4][7][10];function _w(UC){return UC}function GS(UC){return V1(_w,UC)}function Aq(UC){return UC}return E0(xy,Zh,GS,function(UC){return Ta(Aq,UC)})}function O8(Ln,V1){var Ta=Kl(Ln),sf=[0,function(E4){return V1()}],T2=E0(Zi[4][25],0,sf,Ta);return Me(X5[6][5],Ln.check)&&Ln.check(T2),T2}var Og=[0],Mk=X5[50][1].Promise;function US(Ln){var V1=I0(function(Ta){return Ta(Ln)});return new Mk(V1)}function xq(Ln,V1){var Ta=I0(function(sf){return Me(V1,sf)});return Ln.then(Ta)}var YP=[0,US,xq];function IP(Ln){function V1(Ta,sf,T2){var E4=I0(function(D4){return H0(vb[49],0,0,0,Ta)}),vl=O8(Ln.snarkyWitnessTyp,E4);return Ln.snarkyMain(vl,sf)}return[0,V1,[0,Kl(Ln.snarkyPublicTyp),0]]}function _A(Ln){var V1=IP(Ln),Ta=V1[2],sf=V1[1];function T2(D4){return _0(sf,0,D4)}var E4=_0(Zi[4][32],Ta,T2),vl=Me(Zi[4][49][5],E4);return new AT(vl)}function $B(Ln,V1,Ta,sf){var T2=IP(Ln),E4=T2[2],vl=T2[1],D4=Me(Zi[4][49][2],sf),Td=Me(vl,[0,V1]);function r9(xy){var _w=xy[2],GS=xy[1];return H0(Op[9][32],0,D4,GS,_w)}var Zh=H0(Zi[4][35],r9,E4,Td,Ta);return new V$(Zh)}var tw=De(S3);function sg(Ln,V1){var Ta=Ln.sizeInFields(),sf=_e(V1,Ta);function T2(D4,Td){var r9=new X5[14],Zh=V1-1|0,xy=0;if(!(Zh<0))for(var _w=xy;;){var GS=new X5[14],Aq=_e(_w,Ta),UC=Ta-1|0,$q=0;if(!(UC<0))for(var Rr=$q;;){var tn=Qp(Td,Aq+Rr|0);GS.push(tn);var _1=Rr+1|0;if(UC!==Rr){var Rr=_1;continue}break}var P1=Ln.ofFields(GS);r9.push(P1);var C_=_w+1|0;if(Zh!==_w){var _w=C_;continue}break}return r9}function E4(D4,Td){var r9=new X5[14],Zh=Td.length-1|0,xy=0;if(!(Zh<0))for(var _w=xy;;){var GS=Qp(Td,_w),Aq=Ln.toFields(GS),UC=Aq.length-1|0,$q=0;if(!(UC<0))for(var Rr=$q;;){var tn=Qp(Aq,Rr);r9.push(tn);var _1=Rr+1|0;if(UC!==Rr){var Rr=_1;continue}break}var P1=_w+1|0;if(Zh!==_w){var _w=P1;continue}break}return r9}function vl(D4){return sf}return{sizeInFields:L0(vl),toFields:L0(E4),ofFields:L0(T2)}}var GP=Me(Zi[4][38],YP);tw.runAndCheck=I0(function(Ln){function V1(sf){var T2=Ln();function E4(vl,D4){return vl()}return _0(YP[2],T2,E4)}var Ta=Me(GP[1],V1);return _0(YP[2],Ta,Hx[36])}),tw.runAndCheckSync=I0(function(Ln){function V1(sf){return Ln}var Ta=Me(Zi[4][37],V1);return Me(Hx[36],Ta)}),tw.asProver=I0(function(Ln){function V1(Ta){return Ln()}return Me(Zi[4][20],V1)}),tw.witness=I0(O8),tw.array=I0(sg),tw.generateKeypair=L0(function(Ln){return _A(Ln)}),tw.prove=L0(function(Ln,V1,Ta,sf){return $B(Ln,V1,Ta,sf.value)}),tw.verify=function(Ln,V1,Ta){return V1.verify(Ln,Ta)},tw.assertEqual=Tm,tw.equal=H3,tw.toFields=I0(Wf),tw.inProver=I0(function(Ln){return!!Me(Zi[4][43],0)}),tw.inCheckedComputation=I0(function(Ln){return!!Me(Zi[4][44],0)}),tw[w0(""if"")]=wd,tw.getVerificationKey=function(Ln){return new tl(Ln)};var _j=[0,BT,Mt,RV,AS,GN,D1,Wf,Tm,H3,W7,s8,wd,Kl,O8,Og,YP,IP,_A,$B,tw];function SP(Ln,V1){return UB(AT,Ln,V1)}SP(Bv,function(Ln){var V1=Me(Zi[4][49][1],Ln.value);return new tl(V1)});function DA(Ln,V1){return UB(tl,Ln,V1)}V$.ofString=I0(function(Ln){var V1=x0(Ln),Ta=Op[9],sf=_0(M9[10],[0,Ta[16],Ta[17],Ta[18],Ta[19],Ta[20],Ta[21],Ta[22],Ta[23]],V1);return new V$(sf)}),DA(W8,function(Ln,V1,Ta){var sf=Me(T6[3][42][1],0);function T2(E4){var vl=E4.value;if(vl[0]===0){var D4=vl[1];return _0(T6[3][42][3],sf,D4)}return M3(Xe)}return XC(Me(_j[7],V1),T2),!!H0(Op[9][36],0,Ta.value,Ln.value,sf)});function XS(Ln,V1){return UB(V$,Ln,V1)}XS(t9,function(Ln){var V1=Op[9];return F0(_0(M9[11],[0,V1[16],V1[17],V1[18],V1[19],V1[20],V1[21],V1[22],V1[23]],Ln.value))}),V$.ofString=I0(function(Ln){var V1=x0(Ln),Ta=Op[9],sf=_0(M9[10],[0,Ta[16],Ta[17],Ta[18],Ta[19],Ta[20],Ta[21],Ta[22],Ta[23]],V1);return new V$(sf)}),XS(yp,function(Ln,V1,Ta){return V1.verify(Ta,Ln)});function Dw(Ln){var V1=Ln[2],Ta=Ln[1];return[0,Ta,V1]}function VV(Ln){var V1=Ln[2],Ta=Ln[1],sf=zC(V1);return[0,zC(Ta),sf]}function PN(Ln){var V1=Ln[2],Ta=Ln[1],sf=Gi(V1),T2=Gi(Ta);return{transaction:T2,atParty:sf}}function sO(Ln){return[0,Ln.transaction.value,Ln.atParty.value]}function vR(Ln){var V1=Ln[2],Ta=Ln[1],sf=Me(Zi[4][9][7],V1);return PN([0,Me(Zi[4][9][7],Ta),sf])}var HR=[0,Dw,vR],sE=[0,Dw,VV,PN,sO,HR];function vO(Ln){var V1=Ln[2],Ta=Ln[1];return[0,Ta,[0,V1,0]]}function TR(Ln){var V1=Ln[2],Ta=V1[1],sf=Ln[1];return[0,sf,Ta]}var uU=It(Zi[4][7][11],[0,Zi[4][9][41],[0,Zi[4][9][41],0]],vO,TR,vO,TR),QU=E0(Zi[4][7][9],t8[10][9],Bc[6][16],Bc[6][17]);function HN(Ln){var V1=Zi[4][9][41],Ta=[0,function(r9){return Me(Zi[4][9][1][16],3)}],sf=E0(Zi[4][25],0,Ta,V1),T2=[0,function(r9){return Bc[6][11]}],E4=E0(Zi[4][25],0,T2,QU),vl=Me(u6[10],sf),D4=Zi[4];E0(N7[2],R5,[0,D4[2],D4[3],D4[4],D4[5],D4[6],D4[7],D4[8],D4[9],D4[10],D4[11],D4[12],D4[13],D4[14],D4[15],D4[16],D4[17],D4[18],D4[19],D4[20],D4[21],D4[22],D4[23],D4[24],D4[25],D4[26],D4[27],D4[28],D4[29],D4[30],D4[31],D4[32],D4[33],D4[34],D4[35],D4[36],D4[37],D4[38],D4[39],D4[40],D4[41],D4[42],D4[43],D4[44],D4[45],D4[46],D4[47],D4[48]],vl),E0(t8[11][9],E4,[0,sf],5);var Td=Me(u6[10],sf);return E0(Qm[15][6],va,E4,Td),0}function vz(Ln){var V1=Ln[2],Ta=Ln[1];function sf(E4,vl){return 0}function T2(E4,vl){return HN(0),Me(V1,Me(sE[3],vl)),0}return[0,x0(Ta),0,T2,sf]}function RT(Ln){function V1(Ta,sf){return V4}return[0,Pn,[0,Ln,[0,Ln,0]],function(Ta,sf){HN(0);var T2=Zi[4][9][41],E4=[0,function(Td){return Zi[4][9][1][18]}],vl=E0(Zi[4][25],0,E4,T2),D4=_0(Zi[4][9][35],vl,Zi[4][9][18]);return _0(Zi[4][9][40][6],vl,D4),[0,Zi[4][8][1],[0,Zi[4][8][1],0]]},V1]}var Iz=Me(Qc[18][1],wo[3]),MD=[0,[0,Ol[7][1]],[0,[0,Ol[10][1]],[0,[0,Ol[11][1]],[0,[0,Ol[12][1]],[0,[0,Ol[13][1]],[0,[0,Ol[14][1]],[0,[0,Ol[15][1]],[0,[0,Ol[16][1]],[0,[0,Ol[17][1]],[0,[0,Ol[18][1]],[0,[0,Ol[19][1]],[0,[0,Ol[20][1]],[0,[0,Ol[21][1]],[0,[0,Ol[22][1]],[0,[0,Ol[23][1]],[0,[0,Ol[24][1]],[0,[0,Ol[25][1]],[0,[0,Ol[26][1]],[0,[0,Ol[27][1]],[0,[0,Ol[28][1]],[0,[0,Ol[29][1]],0]]]]]]]]]]]]]]]]]]]]];function JF(Ln){return _0(Mx[31],MD,Ln)}function YD(Ln){var V1=Me(sv[29],B0(Ln)),Ta=Me(Mx[6],V1)+1|0;function sf(tn){var _1=[0,RT(tn),0],P1=_0(Mx[69],V1,vz);return _0(w8[145],P1,_1)}var T2=JF(Ta),E4=Me(wp[5][12],0),vl=[0,0,0,0,0,Os,0,Me(wp[5][12],0),0,E4,0],D4=Ol[11],Td=sr(wo[11],0,0,0,[0,sE[1]],[0,sE[5][1]],uU,T2,[0,D4[3],D4[1],D4[2]],Df,vl,sf),r9=Td[4],Zh=Td[3],xy=Td[1];function _w(tn){if(tn){var _1=tn[2],P1=tn[1],C_=_w(_1),Vc=function(Hc){var Vi=Me(sE[4],Hc),Us=Me(sE[2],Vi);return V0.deferred_to_promise(E0(P1,0,0,Us))};return[0,Vc,C_]}return 0}function GS(tn,_1){var P1=Me(sE[4],tn),C_=Me(sE[2],P1);return V0.deferred_to_promise(Me(Zh[4],[0,[0,C_,_1],0]))}function Aq(tn){var _1=Zh[1],P1=V0.caml_obj_tag(_1),C_=P1===250?_1[1]:P1===246?Me(zb[2],_1):_1,Vc=Me(wo[1][3],C_);return new tl(Vc)}function UC(tn){var _1=Me(wo[10][1][17],xy);return F0(Me(wo[10][1][10],_1))}var $q=_w(r9),Rr=$0(Me(sv[47],$q));return{provers:Rr,verify:GS,getVerificationKeyArtifact:UC,getVerificationKey:Aq}}function LW(Ln){var V1=Me(wo[10][2][2],Ln),Ta=Xx[11][5];return F0(H0(Ta,0,0,0,V1))}var IG={compile:YD,proofToString:LW},zW=[0],zY=[0],JI=De(y$);function Tz(Ln,V1){return _0(A$[37],Ln[1][2],V1)}function KI(Ln,V1){return _0(A$[37],Ln[1][3],V1)}function $X(Ln,V1,Ta){var sf=Ln[1],T2=sf[3],E4=E0(A$[31],Ln[1][2],V1,Ta);return Ln[1]=[0,sf[1],E4,T2],0}function UW(Ln){var V1=Ln[1][1],Ta=Ln[1];return Ln[1]=[0,V1+1|0,Ta[2],Ta[3]],V1}function YI(Ln,V1){var Ta=KI(Ln,V1);if(Ta)var sf=Ta[1],T2=Tz(Ln,sf),E4=[0,-242540874,H0(vb[49],0,0,0,T2),sf];else{var vl=UW(Ln),D4=_0(A7[48],V1,F3[4][45]),Td=[0,D4[1],D4[2],D4[3],D4[4],D4[5],D4[6],D4[7],D4[8],D4[9],D4[10],U7,D4[12],D4[13]],r9=Ln[1],Zh=E0(A$[31],Ln[1][3],V1,vl);Ln[1]=[0,r9[1],r9[2],Zh],$X(Ln,vl,Td);var E4=[0,795952288,Td,vl]}return[0,E4]}function GA(Ln,V1,Ta){var sf=KI(Ln,V1);if(sf){var T2=[0,[11,E2,[24,Jc,function(Td,r9){var Zh=Me(Uo[6],r9);return _0(Jx[13],0,Zh)},y_]],Zo];return _0(Hx[42],T2,V1)}var E4=UW(Ln),vl=Ln[1],D4=E0(A$[31],Ln[1][3],V1,E4);return Ln[1]=[0,vl[1],vl[2],D4],$X(Ln,E4,Ta),s2}function WM(Ln,V1){function Ta(D4){return _0(A$[37],Ln[1][3],D4)}var sf=_0(Mx[116],V1,Ta),T2=Ln[1],E4=E0(Mx[9],V1,Ln[1][3],A$[40]),vl=E0(Mx[9],sf,Ln[1][2],A$[40]);return Ln[1]=[0,T2[1],vl,E4],0}function $M(Ln){return Zi[4][9][1][18]}function sU(Ln,V1){return[0,[0,0,Y7[120][4],Uo[35][4]]]}function ZG(Ln,V1){return Me(V1,sU(Ln,0))}function Pz(Ln){return[0,Ln[1]]}function TA(Ln,V1){return Ln[1]=V1[1],0}var ZB=[0,Tz,KI,$X,YI,GA,WM,$M,ZG,sU,Pz,TA],ZT=Me(t2[8],ZB);function S7(Ln,V1,Ta){var sf=E0(ZB[5],Ln,V1,Ta);return Me(Hx[36],sf)}var Bw=Me(Zi[4][9][1][40],_5),Cc=Me(Zi[4][9][7],Bw),Ls=Me(Zi[4][9][1][40],Z5),B$=Me(Zi[4][9][7],Ls),By={value:Gi(Zi[4][9][19])},tz={value:Gi(Cc)},Qk={value:Gi(B$)},$s={lower:By,upper:tz},R4={lower:By,upper:Qk};function X3(Ln){var V1=Ln.value;if(V1[0]===0){var Ta=V1[1];return Ta}return Me(Zi[4][10][3],V1)}function I8(Ln){var V1=X3(Ln.g.y),Ta=Me(Zi[4][4][1],V1),sf=_0(Zi[4][4][2],Ta,0);return[0,X3(Ln.g.x),sf]}function Db(Ln){function V1(sf){return sf}function Ta(sf){return Me(w8[6],wf)}return E0(X5[6][7],Ln.s.constantValue,Ta,V1)}function zx(Ln){var V1=X3(Ln.value),Ta=Me(Zi[4][9][1][41],V1);return Me(wp[4][16],Ta)}function xb(Ln){var V1=X3(Ln.value),Ta=Me(Zi[4][9][1][41],V1);return Me(wp[5][14],Ta)}function LC(Ln){var V1=X3(Ln.uint64Value()),Ta=Me(Zi[4][9][1][41],V1),sf=Me(wp[5][14],Ta),T2=Me(wp[5][28],sf),E4=Me($6[11],T2)?1:0,vl=Me($6[40],T2),D4=Me(wp[5][27],vl);return[0,Me(F3[3][52],D4),E4]}function Eg(Ln){return Ln.toBoolean()|0}function Wg(Ln,V1){var Ta=V1.check;return Ta.toBoolean()|0?[0,Me(Ln,V1.value)]:0}function Lq(Ln,V1){var Ta=Me(Ln,V1.upper);return[0,Me(Ln,V1.lower),Ta]}function LE(Ln){var V1=A_[5],Ta=Ln.epochLength,sf=[0,Lq(_0(V1,X2[57],zx),Ta)],T2=Wg(X3,Ln.lockCheckpoint),E4=Wg(X3,Ln.startCheckpoint),vl=Wg(X3,Ln.seed),D4=Ln.ledger.totalCurrency,Td=[0,Lq(_0(V1,F3[3][52],xb),D4)];return[0,[0,Wg(X3,Ln.ledger.hash),Td],vl,E4,T2,sf]}function JN(Ln){var V1=A_[5],Ta=LE(Ln.nextEpochData),sf=LE(Ln.stakingEpochData),T2=Ln.globalSlotSinceGenesis,E4=[0,Lq(_0(V1,v1[57],zx),T2)],vl=Ln.globalSlotSinceHardFork,D4=[0,Lq(_0(V1,v1[57],zx),vl)],Td=Ln.totalCurrency,r9=[0,Lq(_0(V1,F3[3][52],xb),Td)],Zh=Ln.minWindowDensity,xy=[0,Lq(_0(V1,X2[57],zx),Zh)],_w=Ln.blockchainLength,GS=[0,Lq(_0(V1,X2[57],zx),_w)];return[0,Wg(X3,Ln.snarkedLedgerHash),0,GS,xy,0,r9,D4,E4,sf,Ta]}function xO(Ln,V1){var Ta=V1.set;return Ta.toBoolean()|0?[0,Me(Ln,V1.value)]:0}function LT(Ln){var V1=x0(Ln),Ta=Me(wo[10][1][12],V1);return[0,Ta,Me(Z8[14],Ta)]}function DN(Ln){var V1=Eg(Ln.constant),Ta=Eg(Ln.signatureNecessary),sf=Eg(Ln.signatureSufficient);return V1?sf?0:4:Ta?sf?3:Me(w8[6],u2):sf?1:2}function TJ(Ln){var V1=DN(Ln.setVotingFor),Ta=DN(Ln.incrementNonce),sf=DN(Ln.setTokenSymbol),T2=DN(Ln.editSequenceState),E4=DN(Ln.setZkappUri),vl=DN(Ln.setVerificationKey),D4=DN(Ln.setPermissions),Td=DN(Ln.setDelegate),r9=DN(Ln.receive),Zh=DN(Ln.send);return[0,DN(Ln.editState),Zh,r9,Td,D4,vl,E4,T2,sf,Ta,V1]}function TH(Ln){var V1=xO(TJ,Ln.permissions),Ta=xO(LT,Ln.verificationKey),sf=0,T2=0,E4=0,vl=0,D4=xO(I8,Ln.delegate);function Td(r9){return xO(X3,Qp(Ln.appState,r9))}return[0,_0(C3[12],Ol[17][1],Td),D4,Ta,V1,vl,E4,T2,sf]}function wG(Ln){var V1=Wb[38],Ta=Eg(Ln.useFullCommitment),sf=Ln.accountPrecondition,T2=x0(sf.kind);if(se(T2,Ci))if(se(T2,Mi))if(se(T2,Ea))var E4=E0(w8[222],Fn,T2,0);else var vl=zx(sf.value),E4=[1,Me(Vx[55],vl)];else var D4=sf.value,Td=D4.provedState,r9=Wg(function(Kx){return Kx.toBoolean()|0},Td),Zh=Wg(X3,D4.sequenceState),xy=function(Kx){return Wg(X3,Qp(D4.state,Kx))},_w=_0(C3[12],Ol[17][1],xy),GS=Wg(I8,D4.delegate),Aq=Wg(X3,D4.receiptChainHash),UC=D4.nonce,$q=[0,Lq(_0(A_[5],Vx[55],zx),UC)],Rr=D4.balance,E4=[0,[0,[0,Lq(_0(A_[5],F3[4][54],xb),Rr)],$q,Aq,GS,_w,Zh,r9]];else var E4=0;var tn=JN(Ln.protocolState),_1=Ln.depth,P1=X3(Ln.callData);function C_(Kx){return _0(sv[48],B0(Kx),X3)}var Vc=_0(sv[48],B0(Ln.sequenceEvents),C_),Hc=Me(sv[29],Vc);function Vi(Kx){return _0(sv[48],B0(Kx),X3)}var Us=_0(sv[48],B0(Ln.events),Vi),K4=Me(sv[29],Us),Cl=Eg(Ln.incrementNonce),_l=LC(Ln.delta),E8=TH(Ln.update),G8=X3(Ln.tokenId),V7=Me(Wb[6],G8);return[0,I8(Ln.publicKey),V7,E8,_l,Cl,K4,Hc,P1,_1,tn,E4,Ta,V1]}function NG(Ln){var V1=zx(Ln.accountPrecondition),Ta=Me(Vx[55],V1),sf=JN(Ln.protocolState);function T2(GS){return _0(sv[48],B0(GS),X3)}var E4=_0(sv[48],B0(Ln.sequenceEvents),T2),vl=Me(sv[29],E4);function D4(GS){return _0(sv[48],B0(GS),X3)}var Td=_0(sv[48],B0(Ln.events),D4),r9=Me(sv[29],Td),Zh=LC(Ln.delta)[1],xy=Me(F3[3][71],Zh),_w=TH(Ln.update);return[0,I8(Ln.publicKey),_w,xy,r9,vl,sf,Ta]}function CY(Ln){var V1=x0(Ln.kind);if(se(V1,C0)){if(se(V1,Jf)){if(se(V1,_o))return E0(w8[222],Ms,V1,0);var Ta=zx(Ln.value);return[1,Me(Vx[55],Ta)]}var sf=Ln.value,T2=sf.provedState,E4=Wg(function(Aq){return Aq.toBoolean()|0},T2),vl=Wg(X3,sf.sequenceState),D4=function(Aq){return Wg(X3,Qp(sf.state,Aq))},Td=_0(C3[12],Ol[17][1],D4),r9=Wg(I8,sf.delegate),Zh=Wg(X3,sf.receiptChainHash),xy=sf.nonce,_w=[0,Lq(_0(A_[5],Vx[55],zx),xy)],GS=sf.balance;return[0,[0,[0,Lq(_0(A_[5],F3[4][54],xb),GS)],_w,Zh,r9,Td,vl,E4]]}return 0}function xR(Ln){return wG(Ln.body)}function PY(Ln){return NG(Ln.body)}function GQ(Ln){var V1=x0(Ln);return Me(Wb[7],V1)}function HQ(Ln){var V1=x0(Ln.kind);if(se(V1,v_)){if(se(V1,C2)){if(se(V1,x_))return E0(w8[222],On,V1,0);var Ta=Ln.value,sf=x0(Ta);return[1,Me(Di[12],sf)]}var T2=x0(Ln.value),E4=H0(Xx[11][42],0,0,0,T2),vl=Me(wo[10][2][3],E4);if(vl[0]===0){var D4=vl[1];return[0,D4]}var Td=vl[1];return Me(w8[6],Td)}return 0}function AY(Ln){var V1=x0(Ln.kind);if(se(V1,Fu)){if(se(V1,Mc))return E0(w8[222],H_,V1,0);var Ta=Ln.value,sf=x0(Ta);return Me(Di[12],sf)}return Di[13]}function RX(Ln){var V1=Ac[14],Ta=B0(Ln.otherParties),sf=sv[48],T2=_0(sf,Ta,function(xy){var _w=HQ(xy.authorization);return[0,wG(xy.body),_w]}),E4=Me(sv[29],T2);function vl(xy){return xy[1][9]}var D4=_0(K7[3][15],vl,E4);function Td(xy){return Me(K7[3][3][1][13],xy)}var r9=_0(K7[3][24],Td,D4),Zh=AY(Ln.feePayer.authorization);return[0,[0,PY(Ln.feePayer),Zh],r9,V1]}function ae0(Ln){var V1=Wb[38],Ta=I8(Ln);return _0(Uo[7],Ta,V1)}var WW=Me(Ol[2],Ol[17][1]);function g00(Ln){return Ln.value}function k00(Ln){return Ln.value}function KZ(Ln){var V1=X3(Ln.g.y),Ta=Me(Zi[4][4][1],V1),sf=_0(Zi[4][4][2],Ta,0),T2=Me(Zi[4][8][13],sf);return[0,Ln.g.x.value,T2]}function LX(Ln){return[0,Zi[4][9][19],Zi[4][8][2]]}function WY(Ln){return Ln.value.value}function UX(Ln){return Ln.value.value}function VD(Ln){var V1=N3[15][3],Ta=Ln.uint64Value().value,sf=Me(F3[3][73][21][1],Ta);return _0(F3[3][69][26],sf,V1)}function QB(Ln,V1){var Ta=Me(Ln,V1.value);return _0(vc[8][14][7],V1.check.value,Ta)}function Dt0(Ln){return _0(vc[8][14][7],Zi[4][8][2],Ln)}function SZ(Ln,V1){var Ta=Me(Ln,V1.upper),sf=[0,Me(Ln,V1.lower),Ta];return Me(vc[8][14][6],sf)}function YZ(Ln,V1){var Ta=Me(Ln,V1);return Me(vc[8][14][6],[0,Ta,Ta])}function SI(Ln,V1){var Ta=Me(Ln,V1.value);return _0(vc[7][18][11],V1.set.value,Ta)}function ce0(Ln){return _0(vc[7][18][11],Zi[4][8][2],Ln)}function ft0(Ln){var V1=UX(Ln);return Me(F3[3][73][21][1],V1)}function Hn0(Ln){var V1=UX(Ln);return Me(F3[4][70][18][1],V1)}function fr0(Ln){var V1=WY(Ln);return Me(Vx[52][24][1],V1)}function I10(Ln){var V1=WY(Ln);return Me(v1[54][24][1],V1)}function Z10(Ln){return Me(Wb[41][5],Ln.value)}function Z9(Ln){var V1=X3(Ln);return Me(U6[14],V1)}function OG(Ln){var V1=A_[5],Ta=Ln.epochLength,sf=SZ(_0(V1,X2[54][24][1],WY),Ta),T2=Ln.lockCheckpoint,E4=QB(_0(V1,Il[12],X3),T2),vl=Ln.startCheckpoint,D4=QB(_0(V1,Il[12],X3),vl),Td=Ln.seed,r9=QB(_0(V1,V_[14],X3),Td),Zh=SZ(ft0,Ln.ledger.totalCurrency);return[0,[0,QB(Z9,Ln.ledger.hash),Zh],r9,D4,E4,sf]}function MH(Ln){var V1=A_[5],Ta=OG(Ln.nextEpochData),sf=OG(Ln.stakingEpochData),T2=SZ(I10,Ln.globalSlotSinceGenesis),E4=SZ(I10,Ln.globalSlotSinceHardFork),vl=SZ(ft0,Ln.totalCurrency),D4=Ln.minWindowDensity,Td=SZ(_0(V1,X2[54][24][1],WY),D4),r9=Ln.blockchainLength,Zh=SZ(_0(V1,X2[54][24][1],WY),r9),xy=Ln.timestamp,_w=SZ(_0(V1,Ef[47][9][1],UX),xy);return[0,QB(Z9,Ln.snarkedLedgerHash),_w,Zh,Td,0,vl,E4,T2,sf,Ta]}function ie0(Ln){var V1=LX(0),Ta=Dt0(Zi[4][8][2]),sf=Dt0(Zi[4][9][19]);function T2(r9){return Dt0(Zi[4][9][19])}var E4=_0(C3[12],Ol[17][1],T2),vl=Dt0(V1),D4=Dt0(Me(T3[2][47],Zi[4][9][19])),Td=SZ(fr0,$s);return[0,SZ(Hn0,R4),Td,D4,vl,E4,sf,Ta]}function JQ(Ln){var V1=x0(Ln.kind);if(se(V1,ts)){if(se(V1,si)){if(se(V1,Nf))return E0(w8[222],uf,V1,0);var Ta=Ln.value,sf=ie0(0),T2=sf[7],E4=sf[6],vl=sf[5],D4=sf[4],Td=sf[3],r9=YZ(fr0,Ta);return[0,sf[1],r9,Td,D4,vl,E4,T2]}var Zh=A_[5],xy=Ln.value,_w=QB(k00,xy.provedState),GS=QB(g00,xy.sequenceState),Aq=function(P1){return QB(g00,Qp(xy.state,P1))},UC=_0(C3[12],Ol[17][1],Aq),$q=QB(KZ,xy.delegate),Rr=xy.receiptChainHash,tn=QB(_0(Zh,T3[2][11],X3),Rr),_1=SZ(fr0,xy.nonce);return[0,SZ(Hn0,xy.balance),_1,tn,$q,UC,GS,_w]}return ie0(0)}function SV(Ln){var V1=Me(F3[3][73][21][1],Zi[4][9][19]),Ta=Me(v1[54][24][1],Zi[4][9][19]),sf=Me(F3[3][73][21][1],Zi[4][9][19]),T2=Me(v1[54][24][1],Zi[4][9][19]);return[0,Me(F3[4][70][18][1],Zi[4][9][19]),T2,sf,Ta,V1]}function yH(Ln){var V1=Z8[1][8],Ta=[0,function(E4){return 0}],sf=E0(Zi[4][25],0,Ta,V1);function T2(E4){var vl=_0(sv[48],B0(E4),g00);return _0(Z8[1][11],sf,vl),0}return _0(sv[19],B0(Ln),T2),sf}function IZ(Ln){var V1=Ln.update,Ta=SI(g00,V1.votingFor),sf=_0(vc[7][18][7],Il[47],Ta),T2=ce0(SV(0)),E4=ce0(Zi[4][9][19]);function vl(V7){return wa}var D4=Me(Zi[4][10][1][1],vl),Td=ce0(_0(Yf[7],Zi[4][9][19],D4)),r9=ce0(Me(Ts[14][2],Ts[17]));function Zh(V7){return[0,0,Zi[4][9][1][18]]}var xy=Me(Zi[4][10][1][1],Zh),_w=Me(Z8[15],0),GS=Me(Zi[4][9][7],_w),Aq=_0(Yf[7],GS,xy),UC=ce0([0,Zi[4][8][2],Aq]),$q=SI(KZ,V1.delegate);function Rr(V7){return SI(g00,Qp(V1.appState,V7))}var tn=[0,_0(C3[12],Ol[17][1],Rr),$q,UC,r9,Td,E4,T2,sf],_1=Me(Wb[41][2],Wb[38]),P1=Ln.useFullCommitment.value,C_=JQ(Ln.accountPrecondition),Vc=MH(Ln.protocolState);function Hc(V7){return Ln.depth}var Vi=Me(Zi[4][10][1][1],Hc),Us=Ln.callData.value,K4=yH(Ln.sequenceEvents),Cl=yH(Ln.events),_l=Ln.incrementNonce.value,E8=VD(Ln.delta),G8=Z10(Ln.tokenId);return[0,KZ(Ln.publicKey),G8,tn,E8,_l,Cl,K4,Us,Vi,Vc,C_,P1,_1]}function AQ(Ln){var V1=Ln.accountPrecondition.value,Ta=ie0(0),sf=Ta[7],T2=Ta[6],E4=Ta[5],vl=Ta[4],D4=Ta[3],Td=YZ(fr0,V1),r9=[0,Ta[1],Td,D4,vl,E4,T2,sf],Zh=Ln.update,xy=SI(g00,Zh.votingFor),_w=_0(vc[7][18][7],Il[47],xy),GS=ce0(SV(0)),Aq=ce0(Zi[4][9][19]);function UC($y){return Ti}var $q=Me(Zi[4][10][1][1],UC),Rr=ce0(_0(Yf[7],Zi[4][9][19],$q)),tn=ce0(Me(Ts[14][2],Ts[17]));function _1($y){return[0,0,Zi[4][9][1][18]]}var P1=Me(Zi[4][10][1][1],_1),C_=Me(Z8[15],0),Vc=Me(Zi[4][9][7],C_),Hc=_0(Yf[7],Vc,P1),Vi=ce0([0,Zi[4][8][2],Hc]),Us=SI(KZ,Zh.delegate);function K4($y){return SI(g00,Qp(Zh.appState,$y))}var Cl=[0,_0(C3[12],Ol[17][1],K4),Us,Vi,tn,Rr,Aq,GS,_w],_l=Me(Wb[41][2],Wb[38]),E8=Ln.useFullCommitment.value,G8=MH(Ln.protocolState);function V7($y){return Ln.depth}var Kx=Me(Zi[4][10][1][1],V7),Gy=Ln.callData.value,Nw=yH(Ln.sequenceEvents),Ck=yH(Ln.events),HS=Ln.incrementNonce.value,JS=VD(Ln.delta),Uw=Z10(Ln.tokenId);return[0,KZ(Ln.publicKey),Uw,Cl,JS,HS,Ck,Nw,Gy,Kx,G8,r9,E8,_l]}function BQ(Ln){return AQ(Ln.body)}function Uq(Ln){return IZ(Ln.body)}var KQ=[0,X3,g00,k00,KZ,LX,WY,UX,VD,QB,Dt0,SZ,YZ,SI,ce0,ft0,Hn0,fr0,I10,Z10,Z9,OG,MH,ie0,JQ,SV,yH,IZ,AQ,BQ,Uq];function wH(Ln){return Gi(Me(Zi[4][9][7],Ln))}function VH(Ln){var V1=Me(wp[4][17],Ln),Ta=wH(Me(Zi[4][9][1][40],V1));return{value:Ta}}function _00(Ln){var V1=Me(wp[5][15],Ln),Ta=wH(Me(Zi[4][9][1][40],V1));return{value:Ta}}function CE(Ln){var V1=new X5[14],Ta=Ln[12];if(Ta){var sf=Ta[1],T2=function(Zh){var xy=wH(Zh);return V1.push(xy),0};_0(C3[2],sf[1],T2)}else{var E4=WW-1|0,vl=0;if(!(E4<0))for(var D4=vl;;){var Td=wH(Zi[4][9][1][18]);V1.push(Td);var r9=D4+1|0;if(E4!==D4){var D4=r9;continue}break}}return V1}function Ob(Ln){var V1=Me(Wi[40],Ln),Ta=V1[2],sf=V1[1],T2=Me(Zi[4][9][7],Ta);return xM(Me(Zi[4][9][7],sf),T2)}function ZK(Ln){return ZU(Ln)}function XU(Ln){var V1=Ln[2],Ta=Ln[1],sf=ZU(V1),T2=wV(Ta);return{r:T2,s:sf}}function X8(Ln){var V1=CE(Ln),Ta={appState:V1},sf=VH(Me(Vx[54],Ln[6])),T2=_00(Me(F3[4][53],Ln[5])),E4=Ob(Ln[1]);return{publicKey:E4,balance:T2,nonce:sf,zkapp:Ta}}function D2(Ln,V1){var Ta=_0(vb[38],V1,Ln);return Me(X5[6][9],Ta)}var xz=[0,wH,VH,_00,CE,Ob,ZK,XU,X8,D2];function Ew(Ln){var V1=[1,Di[13]],Ta=[0,xR(Ln),V1],sf=Me(O_[25],Ta);return Gi(Me(Zi[4][9][7],sf))}function t$(Ln){var V1=Me(KQ[30],Ln);return Gi(Me(O_[26][1],V1))}function vF(Ln){var V1=JN(Ln),Ta=Me($l[8][16],V1);return Gi(Me(Zi[4][9][7],Ta))}function IA(Ln){var V1=Me(KQ[22],Ln);return Gi(Me($l[8][18][2],V1))}function TB(Ln){return Ln}function WS(Ln){return Ln}function BM(Ln){var V1=zC(Ln.value),Ta=Me(K7[35][5],V1);return Gi(Me(Zi[4][9][7],Ta))}function R9(Ln){var V1=Ln.value;return Gi(Me(K7[35][7][1],V1))}function VF(Ln,V1){var Ta=Ln[3],sf=Ln[2],T2=Ln[1],E4=Me(K7[37],Ln),vl=Me(O_[29],T2),D4=Me(K7[3][3][1][13],vl),Td=Me(Ac[31],Ta),r9=E0(K7[35][6],E4,Td,D4);if(V1)var Zh=V1[1],xy=Me(K7[3][16],sf),_w=_0(Mx[31],xy,Zh)[1][12];else var _w=1;return _w?r9:E4}function KF(Ln){var V1=x0(Ln),Ta=Xx[11][42],sf=H0(Ta,0,0,0,V1),T2=Me(K7[52],sf),E4=Me(K7[37],T2),vl=Me(O_[29],T2[1]),D4=Me(K7[3][3][1][13],vl),Td=Me(Ac[31],T2[3]),r9=E0(K7[35][6],E4,Td,D4),Zh=wV(r9),xy=wV(E4);return{commitment:xy,fullCommitment:Zh}}function Tb(Ln,V1){var Ta=x0(Ln),sf=Xx[11][42],T2=H0(sf,0,0,0,Ta),E4=Me(K7[52],T2),vl=_0(Mx[121],E4[2],V1),D4=Me(K7[3][22],vl),Td=VF(E4,[0,V1]);return Me(sE[5][2],[0,Td,D4])}function zI(Ln,V1){var Ta=zC(Ln.value),sf=Me($a[1][6],Ta),T2=Db(V1),E4=E0(Fa[4][6],0,T2,sf);return F0(Me(Di[10],E4))}function FG(Ln,V1,Ta){var sf=x0(Ln),T2=Xx[11][42],E4=H0(T2,0,0,0,sf),vl=Me(K7[52],E4),D4=VF(vl,Ta),Td=Me($a[1][6],D4),r9=Db(V1),Zh=E0(Fa[4][6],0,r9,Td);if(Ta)var xy=Ta[1],_w=vl[3],GS=vl[2],Aq=function(_1,P1){return _0(w8[90],_1,xy)?[0,P1[1],[1,Zh]]:P1},UC=_0(K7[3][19],Aq,GS),$q=[0,vl[1],UC,_w];else var $q=[0,[0,vl[1][1],Zh],vl[2],vl[3]];var Rr=Me(K7[51],$q),tn=Xx[11][5];return F0(H0(tn,0,0,0,Rr))}function zK(Ln,V1){return FG(Ln,V1,0)}function BE(Ln,V1,Ta){return FG(Ln,V1,[0,Ta])}function Ey(Ln){var V1=Ln[3],Ta=Ln[2],sf=Ln[1],T2=Me(K7[37],Ln),E4=Me(O_[29],sf),vl=Me(K7[3][3][1][13],E4),D4=Me(Ac[31],V1),Td=E0(K7[35][6],T2,D4,vl),r9=Wi[34][40];function Zh(GS,Aq,UC,$q){var Rr=Me(Wi[39],UC);if(Rr){var tn=Rr[1],_1=Me($a[1][6],$q),P1=Me(Bc[6][17],tn);if(H0(Fa[4][7],0,Aq,P1,_1))return 0;var C_=Me(r9,UC),Vc=E0(w8[244],To,GS,C_);return Me(w8[6],Vc)}var Hc=Me(r9,UC),Vi=E0(w8[244],G6,GS,Hc);return Me(w8[6],Vi)}Zh(La,sf[2],sf[1][1],Td);function xy(GS,Aq){var UC=Aq[1][12]?Td:T2,$q=Aq[2];if(typeof $q!=""number""&&$q[0]===1){var Rr=$q[1],tn=Aq[1][1];return Zh(_0(w8[244],W2,GS),Rr,tn,UC)}return 0}var _w=Me(K7[3][16],Ta);return _0(Mx[91],_w,xy)}function YF(Ln){var V1=I8(Ln);return F0(Me(Wi[34][40],V1))}function NA(Ln){var V1=x0(Ln),Ta=Me(Wi[34][41],V1);return Me(xz[5],Ta)}function w6(Ln){var V1=Db(Ln);return F0(Me(Gc[29],V1))}function IH(Ln){var V1=x0(Ln),Ta=Me(Gc[30],V1);return Me(xz[6],Ta)}function CW(Ln,V1,Ta){var sf=ae0(V1),T2=Me(wp[5][14],Ta),E4=Me(F3[4][54],T2),vl=_0(A7[48],sf,E4),D4=[0,vl[1],vl[2],vl[3],vl[4],vl[5],vl[6],vl[7],vl[8],vl[9],vl[10],U7,vl[12],vl[13]];return S7(Ln,sf,D4)}function DH(Ln){var V1=_0(ZB[9],20,0);return XC(Ln,function(Ta){var sf=x0(Ta.balance);return CW(V1,Ta.publicKey,sf)}),new JI(V1)}function QG(Ln,V1){var Ta=ae0(V1),sf=_0(ZB[2],Ln.value,Ta),T2=Me(ZB[1],Ln.value),E4=_0(vb[36],sf,T2);return _0(xz[9],xz[8],E4)}function uA(Ln,V1,Ta){var sf=x0(Ta);return CW(Ln.value,V1,sf)}var Mz=[0,[0,Zi[4][9][1][18],F3[3][43]],Zi[4][9][1][18],Zi[4][9][1][18],Zi[4][9][1][18],X2[39]],CI=[0,Zi[4][9][1][18],Ef[6],X2[39],X2[39],0,F3[3][43],v1[39],v1[39],Mz,Mz];function JR(Ln){var V1=Me(Eb[2][3],0);return Me(K7[48],V1)}function Qf(Ln){var V1=RX(Ln),Ta=JR(0),sf=Me(Me(Ze(Ta,852507308,382),Ta)[1],V1),T2=Xx[11][5];return F0(H0(T2,0,0,0,sf))}function Po(Ln,V1,Ta){Ey(V1);var sf=Ln.value,T2=Mp[3][17],E4=T2[10],vl=Me(F3[2][45],Ta),D4=H0(ZT[5],[0,T2[1],T2[2],T2[3],T2[4],T2[5],T2[6],T2[7],T2[8],vl,E4],CI,sf,V1),Td=Me(Hx[36],D4),r9=Td[1],Zh=r9[2],xy=r9[1],_w=Zh[2];if(_w[0]!==0){var GS=_w[1],Aq=Me(Bo[1][15][5],GS),UC=Xx[11][5];M3(H0(UC,0,0,0,Aq))}function $q(tn){var _1=tn[2];return _0(xz[9],xz[8],_1)}var Rr=_0(Mx[69],xy,$q);return $0(Me(sv[47],Rr))}function Y3(Ln,V1,Ta){var sf=x0(Ta);return Po(Ln,RX(V1),sf)}function z8(Ln,V1,Ta){var sf=x0(V1),T2=Xx[11][42],E4=H0(T2,0,0,0,sf),vl=Me(K7[52],E4);return Po(Ln,vl,x0(Ta))}function D$(Ln,V1){return JI[F0(Ln)]=I0(V1)}function sm(Ln,V1){return UB(JI,Ln,V1)}D$($x,DH),D$(Cd,Ew),D$(ud,vF),D$(u5,BM),D$(yl,t$),D$(H4,IA),D$(J5,R9),D$(Xv,KF),D$(x7,Tb),D$(Vb,zI),D$(Jd,zK),D$(E5,BE),D$(F9,YF),D$(so,NA),D$(Xo,w6),D$(A6,IH),sm(J4,QG),sm(Pv,uA),sm(vx,Y3),sm(vp,z8),D$(ss,Qf);function Ny(Ln){if(typeof Ln!=""number""){var V1=Ln[1];if(V1===848054398){var Ta=Ln[2],sf=_0(Mx[69],Ta,Ny),T2=_0(S8[24],W4,sf);return _0(w8[244],Wa,T2)}if(V1===963043957){var E4=Ln[2],vl=function(r9){var Zh=r9[2],xy=r9[1],_w=Ny(Zh),GS=Me(Wd[2],xy);return E0(w8[244],Kw,GS,_w)},D4=_0(Mx[69],E4,vl),Td=_0(S8[24],Kh,D4);return _0(w8[244],Ki,Td)}}return H0(Xx[11][5],0,0,0,Ln)}function Jz(Ln){var V1=RX(Ln),Ta=JR(0);return F0(Ny(Me(Me(Ze(Ta,852507308,384),Ta)[1],V1)))}D$(P5,Jz);var M1=[0,zW,zY,JI,U7,ZB,ZT,JI,S7,Cc,B$,By,tz,Qk,$s,R4,X3,I8,Db,zx,xb,LC,Eg,Wg,Lq,LE,JN,xO,LT,DN,TJ,TH,wG,NG,CY,xR,PY,GQ,HQ,AY,RX,ae0,WW,KQ,xz,Ew,t$,vF,IA,TB,WS,BM,R9,VF,KF,Tb,zI,FG,zK,BE,Ey,YF,NA,w6,IH,CW,DH,QG,uA,CI,JR,Qf,Po,Y3,z8];function Oo(Ln){return _0(X5[48],Y0,W5),_0(X5[48],xe,UM),_0(X5[48],Pr,Xj),_0(X5[48],xc,Jq),_0(X5[48],If,sR),_0(X5[48],G_,_j[20]),_0(X5[48],Tc,M1[3]),_0(X5[48],Ia,IG)}function Ys(Ln){var V1={Field:W5,Scalar:UM,Bool:Xj,Group:Jq,Poseidon:sR,Circuit:_j[20],Ledger:M1[3],Pickles:IG};return X5[50][1].__snarky=V1}var ws=[0,s3,Ug,MS,yg,M3,Vq,Xk,W5,Pj,LM,Lc,Xj,Xj,B8,yC,I$,Qp,Im,UB,yV,Gi,WB,wV,Jq,Iw,YA,xM,JD,zN,UM,UM,UM,UL,ZU,XC,Lj,zE,yL,Hz,Rp,LS,QS,zC,sR,AT,AT,tl,tl,V$,V$,_j,Dw,sE,uU,HN,vz,RT,tl,Iz,MD,JF,YD,LW,IG,M1,Oo,Ys];V0.caml_register_global(815,ws,""Snarky_js_bindings_lib"")}(function(){return this}()),function(Re){""use strict"";var V0=Re.jsoo_runtime;V0.caml_register_global(0,[0],""Node_backend"")}(function(){return this}()),function(Re){""use strict"";var V0=Re.jsoo_runtime;function Ze($0,B0){return $0.length==1?$0(B0):V0.caml_call_gen($0,[B0])}var De=V0.caml_get_global_data().Snarky_js_bindings_lib;Ze(De[67],0),Ze(De[66],0),V0.caml_register_global(1,[0],""Dune__exe__Snarky_js_node"")}(function(){return this}()),function(Re){""use strict"";var V0=Re.jsoo_runtime;function Ze(I0,L0){return I0.length==1?I0(L0):V0.caml_call_gen(I0,[L0])}var De=V0.caml_get_global_data(),$0=De.Stdlib;Ze($0[103],0);var B0=[0];V0.caml_register_global(1,B0,""Std_exit"")}(function(){return this}());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            

Error: assertEquals: not equal
```","[('45930', 'Additional logging:\r\n\r\n```\r\n...const enc = Encryption.encrypt(Encoding.Bijective.Fp.fromString(str), publicKey);\r\nconsole.log(enc)\r\n\r\n...const enc2 = Encryption.encrypt(Encoding.Bijective.Fp.fromString(str2), publicKey);\r\nconsole.log(enc2)\r\n```\r\n```\r\n{\r\n  publicKey: { x: { value: [Array] }, y: { value: [Array] } },\r\n  cipherText: [ { value: [Array] }, { value: [Array] } ]\r\n}\r\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\r\n{\r\n  publicKey: { x: { value: [Array] }, y: { value: [Array] } },\r\n  cipherText: [ { value: [Array] }, { value: [Array] }, { value: [Array] } ]\r\n}\r\n```'), ('45930', '```\r\nSystem:\r\n    OS: macOS Mojave 10.14.2\r\n    CPU: (4) x64 Intel(R) Core(TM) i5-8210Y CPU @ 1.60GHz\r\n  Binaries:\r\n    Node: 16.13.1 - ~/.nvm/versions/node/v16.13.1/bin/node\r\n    Yarn: 1.21.1 - /usr/local/bin/yarn\r\n    npm: 8.1.2 - ~/.nvm/versions/node/v16.13.1/bin/npm\r\n  npmPackages:\r\n    snarkyjs: ^0.3.1 => 0.3.1 \r\n  npmGlobalPackages:\r\n    zkapp-cli: Not Found\r\n\r\n```')]"
147,Passing > 1145 public inputs causes RangeError,themighty1,open,"This simple repro works with 1145, but not with 1146 elements
The error is
```

generating keypair...
/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:28740
      function symbol_bind(t,f){return caml_call2(_DU_,t,f)}
                                       ^

RangeError: Maximum call stack size exceeded
    at symbol_bind (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:28740:40)
    at caml_call2 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:24686:28)
    at all_unit (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:28772:18)
...
```
The code is
```

import {
    Field,
    Circuit,
    circuitMain,
    public_,
    isReady,
    CircuitValue,
    arrayProp,
  } from 'snarkyjs';
  
  // works with 1145 on my machine
   const count = 1146;

  class PublicInputs extends CircuitValue {
    @arrayProp(Field, count) fields: Field[];
  
    constructor(fields: Field[]) {
      super();
      this.fields = fields;
    }
  }

    class Main extends Circuit {
      @circuitMain
        static main(priv: Field, @public_ pub: PublicInputs) {
            // do something
      }
    }
      
  await isReady;
  
  const pub = new PublicInputs([...Array(count).fill(Field.one)]);

  console.log('generating keypair...');
  console.time('genKey');
  const kp = Main.generateKeypair();
  console.timeEnd('genKey');

  console.log('prove...');
  console.time('prove');
  const pi = Main.prove([Field.one], [pub], kp);
  console.timeEnd('prove');
  console.log('proof', pi);
  
  console.log('verify...');
  let ok = Main.verify([pub], kp.verificationKey(), pi);
  console.log('ok?', ok);
  
```

",[]
146,toBits<->ofBits causes Assert_failure,themighty1,closed,"I have a simple repro circuit where converting.toBits() and back with .ofBits() causes a failure:
```

import {
    Field,
    Circuit,
    circuitMain,
    public_,
    isReady,
  } from 'snarkyjs';
  
    class Main extends Circuit {
      @circuitMain
      static main(priv: Field, @public_ pub: Field) {
        const bits = priv.toBits();
        const field = Field.ofBits(bits);
        field.assertEquals(pub);
      }
    }
    
  await isReady;
  const one = Field.one;
  const kp = Main.generateKeypair();
  const pi = Main.prove([one], [one], kp);
  let ok = Main.verify([one], kp.verificationKey(), pi);
  
```

The error is:

```
node:internal/process/esm_loader:74
    internalBinding('errors').triggerUncaughtException(
                              ^
[
  0,
  [ 248, ai { t: 0, c: 'Assert_failure', l: 14 }, -10 ],
  [
    0,
    ai { t: 0, c: 'src/lib/snarky/src/base/snark0.ml', l: 33 },
    987,
    6
  ]
]
```
","[('mitschabaude', 'TODO: add this to a unit test')]"
145,Remove the `isSameAsFeePayer` option in `Party.createSigned`,mitschabaude,closed,,[]
144,Stack overflow when witness has 2048 elements,themighty1,open,"Hi, I was trying to prove pre-image of 1024 Field elements with this [gist](https://gist.github.com/themighty1/0254065bb7c9259751b648cfae99a015) and it worked fine.
However when I set the amount of Field elements to 2048 (on line 20), I get a stack oveflow error:

```
generating keypair...

node:internal/process/esm_loader:74
    internalBinding('errors').triggerUncaughtException(
                              ^
[
  0,
  [
    248,
    ai {
      t: 0,
      c: 'Snarky_backendless__Checked_runner.Runtime_error',
      l: 48
    },
    109
  ],
  ai {
    t: 0,
    c: 'Encountered an error while evaluating the checked computation:\n' +
      '  (""Stack overflow"")\n' +
      '\n' +
      'Label stack trace:\n' +
      '\n' +
      '\n' +
      '\n',
    l: 107
  },
  0,
  [ 248, ai { t: 0, c: 'Stack_overflow', l: 14 }, -8 ],
  ai { t: 9, c: '', l: 0 }
]

```

Is this something I'd have to work around by hashing chunks of 1024 elements? Or is it something that you could fix? Thanks.","[('mitschabaude', ""Love that your testing the boundaries! Let's ask someone who may know - @mrmr1993 @imeckler ideas?""), ('mitschabaude', ""Update: some quick initial poking into the issue didn't give any insight, will debug it later.\r\nI hope it's not too important for you to get it working @themighty1?""), ('themighty1', ""@mitschabaude , thanks a lot, no it's not a blocker for me, Im ok with hashing 1024-element chunks at a time."")]"
143,Proving hash pre-image with > 1 Field Element,themighty1,closed,"Hi, I was trying to modify ex00_preimage.ts to work with 2 Field elements.
Is > 1 Field element supported? I couldn't pass 2 elements to Main.Prove(), I was
getting an error:

```
node:internal/process/esm_loader:94
    internalBinding('errors').triggerUncaughtException(
                              ^
[
  0,
  [ 248, ai { t: 0, c: 'Js_of_ocaml__Js.Error', l: 21 }, 282 ],
  TypeError: typ.sizeInFields is not a function
      at /home/default2/Desktop/poseidon/snarkyjs/dist/server/index.js:741:50
      at Array.reduce (<anonymous>)
      at Object.sizeInFields (/home/default2/Desktop/poseidon/snarkyjs/dist/server/index.js:741:19)

```

Here's a minimal repro:

```
class Main extends Circuit {
  @circuitMain
  static main(preimage: Field[], @public_ hash: Field) {
    Poseidon.hash(preimage).assertEquals(hash);
  }
}

await isReady;
const kp = Main.generateKeypair();
const preimage = [Field.one, Field.one];
const hash = Poseidon.hash(preimage);
const pi = Main.prove(preimage, [hash], kp);
```

I would appreciate any pointers, thanks.","[('mitschabaude', ""To build complex private/public input shapes, you can extend `CircuitValue` and use the decorators `@prop` and `@arrayProp`:\r\n\r\n```ts\r\nawait isReady;\r\n\r\nclass TwoFields extends CircuitValue {\r\n  @arrayProp(Field, 2) fields: Field[];\r\n\r\n  constructor(fields: Field[]) {\r\n    super();\r\n    this.fields = fields;\r\n  }\r\n}\r\n\r\nclass Main extends Circuit {\r\n  @circuitMain\r\n  static main(preimage: TwoFields, @public_ hash: Field) {\r\n    Poseidon.hash(preimage.fields).assertEquals(hash);\r\n  }\r\n}\r\n\r\nconst kp = Main.generateKeypair();\r\nconst preimage = new TwoFields([Field.one, Field.one]);\r\nconst hash = Poseidon.hash(preimage.fields);\r\nconst pi = Main.prove([preimage], [hash], kp);\r\nlet ok = Main.verify([hash], kp.verificationKey(), pi);\r\nconsole.log('ok?', ok);\r\n```""), ('mitschabaude', 'we should probably have a helper for ""array of Fields / CircuitValues"" that doesn\'t require writing out the CircuitValue class')]"
141,Actually set the account precondition for on-chain state,mitschabaude,closed,,[]
139,Set up CI to ensure CLI examples & project template version match SnarkyJS version being published,jasongitmail,open,To prevent examples from falling out of date.,"[('mitschabaude', ""One idea to solve this would be: The examples live in snarkyjs and are tested in CI, and the CLI just copies them over from the snarkyjs version it has installed in node_modules. Not sure how brittle it is to explicitly rely on node_modules, maybe there's a better way. But this would also simplify iterating on these examples, which is currently super annoying, since in the CLI template directories, there is no linting and no simple way to just run something""), ('mitschabaude', 'Or maybe the cli should become a git submodule of snarkjys? Or of mina?')]"
138,[BUG]: Using minfied build options leads to a broken build,MartinMinkov,closed,"**Description**
When trying to build a release version of SnarkyJS and specifying minified options, the minified build seems to be broken. There is mention of 
```
Try calling \`await isReady\` before \`new ${t}()\``,pt=(t,e)=>`Cannot call static method because snarkyjs has not finished loading.
``` 
in the resulting `index.js` file that is created. This leads to weird and broken behavior when using SnarkyJS. 

**To build a minified version:**
1. Make sure you are on a branch that has the latest build deployed (`0.3.0`) -- branch `feature/deploy-txn`
2. Run `npm run build`
3. Run `NODE_ENV=production node --stack-trace-limit=100 src/build/buildNode.mjs --bindings=./dist/server/node_bindings/`

This results in the built SnarkyJS code having the error described above. It can be examined at `dist/server/index.js`

This leads to weird behavior when interacting with the `compile` and `deploy` methods. ","[('mitschabaude', 'Another data point: I tried the latest published snarkyjs (0.3.3) in a simple project with the simple_zkapp examples (which includes running `compile`), and everything works fine.\n\nMy new hypothesis is that in the zkapp cli, snarkyjs is loaded twice somehow, and for one of the versions, `await isReady` is not called. Or, something else is special in that environment that breaks it.'), ('mitschabaude', 'This is resolved - it had nothing to do with the minified build, after all, but with the fact that two instances of snarkyjs were present')]"
136,Make address a variable in zkapp circuits,mitschabaude,closed,"This will make the `compile` interface not depend on the address, which seems cleaner",[]
135,Make address a variable in zkapp circuits,mitschabaude,closed,"This will make the `compile` interface not depend on the address, which seems cleaner
",[]
134,Get rid of global variables for parties construction,mitschabaude,closed,"Currently we have `currentTransaction` and `mainContext`, global variables which record what is done to parties while running user code.

This creates some fragility: For example, right now, it is probably not safe to run multiple (async) provers concurrently.
This is why we have to stop developers with errors from doing so (https://github.com/o1-labs/snarkyjs/pull/123/commits/84a014996eaadf157dd7fc890b5e36fc51993f74).

Can we get rid of these global variables and have a more scoped way of keeping track of parties construction?
","[('mitschabaude', 'Yes - we can get rid of global variables using the `handler` / `request` mechanism of `snarky`. It allows us to define a custom environment for each prover, thus enabling to run multiple ones in parallel'), ('mitschabaude', ""No - snarky's handler / request mechanism is itself based on global variables, we should handle this with care on the JS side instead of relying on snarky which was written for an environment where the async execution model is different"")]"
132,Unify types in snarky.d.ts and party.ts,mitschabaude,closed,things like `Party` vs `Party_` etc,[]
131,Error when running some examples,themighty1,closed,"Hi, on node v17.0.1, all examples work well except
./run src/examples/ex00_preimage.ts and
./run src/examples/ex01_small_preimage.ts

The error is:

generating keypair...
prove...
(PolyDivision)
wasm://wasm/0092e2ea:1


RuntimeError: unreachable
    at wasm://wasm/0092e2ea:wasm-function[667]:0x1c350b
    at wasm://wasm/0092e2ea:wasm-function[1660]:0x235a5d
    at wasm://wasm/0092e2ea:wasm-function[339]:0x124e49
    at Object.module.exports.caml_pasta_fp_plonk_proof_create (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/plonk_wasm.js:1133:20)
    at Object.m4 [as caml_pasta_fp_plonk_proof_create] (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:2338:5)
    at /home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:311585:33
    at caml_call4 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:281446:16)
    at create_aux (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:311569:14)
    at create$1 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:311583:14)
    at caml_call5 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:267646:16)
    at create$2 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:272275:14)
    at caml_call4 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:799487:16)
    at _cP_ (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:801591:16)
    at caml_call1 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:166370:28)
    at /home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:176348:27
    at caml_call2 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:166372:28)
    at go (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:176321:18)
    at /home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:176320:22
    at am (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:491:39)
    at am (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:492:15)
    at /home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:497:62
    at am (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:490:32)
    at Object.am [as caml_call_gen] (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:492:15)
    at caml_call5 (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:799492:24)
    at prove (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:801597:16)
    at /home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:801688:38
    at am (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:491:39)
    at Function.<anonymous> (/home/default2/Desktop/poseidon/snarkyjs/dist/server/node_bindings/snarky_js_node.bc.js:1414:40)
    at Function.Class.<computed> [as prove] (/home/default2/Desktop/poseidon/snarkyjs/dist/server/index.js:53:52)
    at file:///home/default2/Desktop/poseidon/snarkyjs/src/examples/ex00_preimage.tmp.mjs:24:15

Node.js v17.0.1

","[('mitschabaude', 'Hi @themighty1, this is an error that used to happen in an earlier version of snarkyjs. Could you check your version? It should work on 0.3.0, but is expected to fail on earlier versions '), ('themighty1', ""Thanks @mitschabaude , mine is 0.2.2 - it's the version from the master branch. Is there a different repo with v0.3.0 ? ""), ('mitschabaude', ""There's no different repo :D Version 0.3.0 was published from a branch called [feature/deploy-txn](https://github.com/o1-labs/snarkyjs/commits/feature/deploy-txn), which was subsequently split up into [multiple PRs](https://github.com/o1-labs/snarkyjs/pulls), which are currently being reviewed by the team and will be merged to the main branch within the next 1-2 weeks.""), ('themighty1', 'Thanks for the heads up. Looking forward to the release. Im really impressed by how the code is well-organized and meticulously reviewed. Good work.'), ('themighty1', 'Thanks, works with 0.3.1')]"
130,All SnarkyJS errors should be very clear and include references to learn more,bkase,open,"Error messages typically use jargon that beginners may be unfamiliar with. All errors should be sufficiently detailed to explain exactly what is going on to someone with no context -- this may include a reference link to documentation to learn more.

Draw inspiration from Elm/Rust errors messages","[('bkase', 'I think this entails creating our own custom `Error` wrapper so formatting can be consistent as well')]"
129,Implement the `Mina` interface for QAnet interactions,mitschabaude,closed,"Analogous to the existing `LocalBlockchain` which implements `Mina`, we need to create an interface for interacting with a real, deployed network. For now, this will be the Berkeley QANet.
",[]
128,Add ES Lint rule: to avoid default export ,jasongitmail,closed,To warn against using export default and instruct devs to use a named export for all smart contract classes.,"[('MartinMinkov', 'PR for this here: https://github.com/o1-labs/eslint-plugin-snarkyjs/pull/6'), ('jasongitmail', 'Awesome. Thanks @MartinMinkov! \r\n\r\n@ymekuria could you review this please? '), ('ymekuria', 'This looks great @MartinMinkov. I reviewed and approved this pr https://github.com/o1-labs/eslint-plugin-snarkyjs/pull/6. ')]"
127,Bug: Custom CircuitValue inside onchain state causes crash,mitschabaude,closed,https://github.com/mana-of-mina/mana/blob/5133185f988b409067bb9f4c4b71ee91f9ef13f6/src/registry-zkapp.ts#L98,[]
114,Take into account previous parties in the same transaction when setting account preconditions,mitschabaude,open,"Currently, there are [issues](https://github.com/o1-labs/snarkyjs/issues/52) and custom workarounds for setting the correct nonce precondition in the case one account has multiple nonce-incrementing parties within one transaction. The original plan of just using a nonce fetched from an API doesn't work - the precondition has to be incremented according to previous parties.

The same is probably true of other account preconditions. Therefore, we should devise a general system for keeping track of account updates within one transaction. After the [account state cache](https://github.com/o1-labs/snarkyjs/issues/113) is integrated, we should add an additional data structure which keeps track of updates to that account states at the ""current state"" of the current transaction -- which can be used when setting preconditions.",[]
113,Integrate account fetching into SmartContracts,mitschabaude,closed,"* Use the existing fetch methods magically within `createTransaction` and similar places to fetch account state from an API
* Add a cache to store existing fetch results in
* Refactor createTransaction, such that it either uses account state from the cache, or marks it as ""to be fetched"" (not fetch it directly!). For proof transactions, this enables us to first run it ""test mode"", then asynchronously fetch the missing data, then run it again (with all the data available) inside the synchronous prover. For non-proof transactions, there can be a simple async wrapper that does those three steps in sequence.
* Expose a method to explicitly populate the cache with arbitrary data, for testing scenarios / optional fine-grained control over where the data comes from (e.g. from disk instead of from an API).

Small TODO which should be enabled by this:
* Add nonce precondition to _all_ signed parties - currently only done in `createSigned`",[]
110,Make snarkyjs ready for publishing 0.3,mitschabaude,closed,"* [x] Merge changes in master
* [x] Enable more than one `@method` https://github.com/MinaProtocol/mina/issues/10724
* [x] Make old mock API work again
* Other clean-up work",[]
109,Add floats and exponentiation,mitschabaude,open,,[]
108,[Feature Request] Enable an ABI in JSON to describe inputs on methods,MartinMinkov,open,"**Description**
Create a `Application Binary Interface` (ABI) that describes the inputs of zkapp methods. This can be formatted in JSON.

An example of an implementation is the Ethereum's ABI when compiling a smart contract:
https://docs.soliditylang.org/en/v0.5.3/abi-spec.html",[]
107,OCaml Pickles proof splitting (max-branching=configurable),bkase,closed,,"[('mitschabaude', 'closing, duplicate of https://github.com/MinaProtocol/mina/issues/10716')]"
104,Create good API for proving,jasongitmail,closed,"EDIT (gregor):

* Just *call* methods inside transaction blocks to trigger (lazy?) proof creation
* Have an option like `proofLevel: ""none""` to skip creating proofs (use dummy proofs) in the mock interface. Should also be recognize during deploy to add a dummy verification program.",[]
103,Ensure a tx relayer is set up (to receive deploy tx's & zkApp user interaction tx's),jasongitmail,closed,,"[('mitschabaude', 'this is done - we have https://proxy.berkeley.minaexplorer.com/graphql')]"
102,Deploy a zkApp,jasongitmail,closed,,"[('jasongitmail', 'This was an epic on Zenhub now tracked elsewhere. Closing')]"
101,UInt64.lt Bug,frisitano,closed,"There appears to be a bug on UInt64 implementation. When we execute `value.lt(otherValue)` when `otherValue > value` we receive an error.

How to recreate:
```
import { Field, isReady, shutdown, UInt64 } from ""snarkyjs"";

const main = async () => {
    await isReady;
    const value1 = new UInt64(new Field(""5000""));
    const value2 = new UInt64(new Field(""10000""));
    value1.lt(value2);
}

Promise.resolve()
    .then(async () => await main())

shutdown();
```

Error:
```
Error: rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349967625337 to fit in 64 bits
```","[('mitschabaude', 'Thanks for reporting - will check it out'), ('mitschabaude', 'I found this TODO comment which I think explains the bug:\r\nhttps://github.com/MinaProtocol/mina/blob/feature/snarky-js-minimal/src/lib/snarky_js_bindings/lib/snarky_js_bindings_lib.ml#L278'), ('mitschabaude', 'This is fixed by https://github.com/o1-labs/snarkyjs/pull/307!')]"
100,Make Field.random() less error-prone,mitschabaude,open,"It returns a random constant, which is definitely not what you want inside a circuit

The question is, how should a clearer API look like? It could be that Field.random() just creates a new witness whenever it's called inside the circuit.
","[('mitschabaude', 'relevant for splitting Field into Constant / Variable\n\nhttps://github.com/o1-labs/snarkyjs/issues/669')]"
98,Ensure that the zk app circuits generated by @method have all the proper constraints needed,bkase,closed,"Not needed for end-to-end testing, but important for release","[('mitschabaude', 'Possible dependency: https://github.com/MinaProtocol/mina/issues/10747\nto enable us to build up the correct proof statements to constrain')]"
97,Make an example zk app where SnarkyJS generates deploy/user transactions,bkase,closed,"For testing purposes

Ensure that all the data fields of the transaction are filled out properly

Make sure that SnarkyJS is capable of (optionally) signing itself AND that we could optionally hand it to Mina Signer","[('mitschabaude', 'Mostly done, TODO for today is adding the signing capability to snarkyjs\nNot sure if in scope, but another TODO is getting the zkapp to be accepted by the internal mock mina interface as a sanity check'), ('mitschabaude', 'I consider this closed with https://github.com/MinaProtocol/mina/pull/10674 merged')]"
96,Test issue,jasongitmail,closed,,[]
95,Encryption & decryption using Mina's curve,jasongitmail,closed,,"[('mitschabaude', 'Done, published in snarkyjs 0.2.2')]"
94,GraphQL Server endpoint for automated parties schemas,bkase,closed,,[]
92,String Implementation,45930,closed,"It would be convenient to have strings native in snapps.  Snapp state could point to a URL with more information about the snapp itself.  A username could be included in a circuit, etc...

I have an implementation I have been working on, but I'm wondering what the spec should be if it were to become a PR into the library.

The way my version works is I defined a `UInt8` CircuitValue and implemented a `StringCircuitValue` as an array of UInt8.  The primary interface with a snapp is in the `fromBits` and `toBits` functions which allow a user to initialize a field as bits, and convert back to a string.  e.g.

```
  it('can serialize and deserialize from Field', () => {
    const input = 'Input String 123'
    const ztring = new StringCircuitValue(input);
    const field = Field.ofBits(ztring.toBits());
    expect(StringCircuitValue.fromBits(ztring.toBits()).toString()).to.eq(input);
    expect(StringCircuitValue.fromBits(field.toBits()).toString().replace(/\0/g, '')).to.eq(input);
  });
```

I have not thought out edge cases like trying to pack in more than 256 bits of data, nor thought about performance or security. Just worked on the happy path until now.  If there's interest in merging something like this into snarky, I would be happy to clean it up.  Ideally there would be a spec of what o1 thinks a string ought to behave like, but if not, I'd like to get some feedback regarding concerns or holes I may not have considered.  If this implementation doesn't work, then maybe it will spark some discussion to find one that does.

To view my implementation, see these relevant files:

String.ts: https://github.com/qcomps/cachebox/blob/2369e41e55d3b78285cad2cfa9a2d0ef545d4f41/src/lib/snarkyUtils/String.ts

UInt8.ts (other than the relevant parts, this is a lazy port of UInt64, which may not actually work for math): https://github.com/qcomps/cachebox/blob/2369e41e55d3b78285cad2cfa9a2d0ef545d4f41/src/lib/snarkyUtils/UInt8.ts

String.test.ts: https://github.com/qcomps/cachebox/blob/2369e41e55d3b78285cad2cfa9a2d0ef545d4f41/test/snarkyUtils/String.test.ts

UInt8.test.ts: https://github.com/qcomps/cachebox/blob/2369e41e55d3b78285cad2cfa9a2d0ef545d4f41/test/snarkyUtils/UInt8.test.ts","[('mitschabaude', ""Cool! UInt8 looks good to me, String not yet because it doesn't have any @prop, so it's a CircuitValue representing 0 Fields. You'll need an @arrayProp and have a fixed max length for the String. Also, I'd prefer an implementation that avoids toBits / fromBits because that is super expensive. Better to make to make a primary interface based on Uint8 (which can be mostly thought of as individual characters)""), ('mrmr1993', ""> Snapp state could point to a URL with more information about the snapp itself.\r\n\r\nIn case it's useful context: we have added a [dedicated `snapp_uri`](https://github.com/MinaProtocol/mina/blob/2e2bddace3850468bae734ae456dbf54d4c26ff2/src/lib/mina_base/account.ml#L237) field within accounts for exposing this information without using the snapp state directly. When a snapp is deployed, you should be able to set this field using an optional argument to the command -- although this functionality may not be implemented yet.""), ('45930', '@mitschabaude thanks for taking a look!\r\n\r\nI went with from/to bits because I wanted to be able to read a string off of state.  I went back to your sudoku example to see how you implemented your storage, and to convert to a field, you hashed the circuit value into something that could not be read by anyone else.  A 9x9 matrix is too big to store in 32 bytes however you look at it, but 32 UInt8s should be able to fit, so I was thinking what I could change so that 1 string <=> 1 field.\r\n\r\nCould I do the same with `Field.ofFields`?  Or how else would ""a primary interface based on Uint8"" work? '), ('mitschabaude', '@qcomps Ok, I understand. You want to compress a string to 1 Field of on-chain state and be able to read it back to an array of UInt8s.\r\n\r\nFirst, I have to point out that 1 Field can\'t really hold 32 bytes of on-chain storage -- it can hold 254 bits, so only 31 full bytes.\r\n\r\nI\'d do it like this:\r\n\r\nTo compress a StringCircuitValue to a Field, you just compute a number in base-256 representation. In pseudo-code:\r\n`x = s[0] + 256 * s[1] + ... + 256^30 * s[30];`\r\nReal code might be this:\r\n```js\r\nfunction stringToField(circuitString) {\r\n  let s = circuitString.value;\r\n  let field = Field.zero;\r\n  for (let i = 0, b = Field.one; i < 31; i++, b = b.mul(256)) {\r\n    field = field.add(s[i].mul(b));\r\n  }\r\n  return field;\r\n}\r\n```\r\n\r\nTo go the other direction -- string from a field -- you just compute the string outside the circuit, bring it into to the circuit with Circuit.witness (this is basically ""pulling a witness out of your hat""). Then you use your reverse direction and an assertion to constrain the outside-circuit computation such that it has to be the right thing:\r\n\r\n```js\r\nfunction fieldToString(field) {\r\n  let circuitString = Circuit.witness(StringCircuitValue, () => {\r\n    computeStringOutsideCircuit(field); // write this function yourself, e.g. with field.toString()\r\n  });\r\n  // constrain it to be the correct string:\r\n  let field2 = stringToField(circuitString);\r\n  field.assertEquals(field2);\r\n  \r\n  return circuitString;\r\n}\r\n```'), ('mitschabaude', 'EDIT: I mixed up `8` and `2^8` yesterday, corrected the code above now'), ('mitschabaude', ""Also, I'm not really sure how efficient this is, it depends on the assumption that 1 UInt8 range check is more efficient than a naive range check with 16 constraints (8 booleans/bits + the cost of combining them). I'll try to find out what we're using here. I think I figured out a way to do either UInt8 or UInt16 with a single constraint, at the cost of introducing a look-up table... maybe we have something like that already.""), ('45930', '@mitschabaude I\'m trying to wrap my head around this...\r\n\r\nIt still seems like a one-way function right?  We might as well hash the UInt8s together, or am I missing something?  If we know what the string is, then we can use any one-way function to prove that we know what the output of the function is for the string.\r\n\r\nfield<sub>i</sub> = (field<sub>i+1</sub> + s<sub>i</sub>) * b<sub>i</sub>\r\n\r\nThis equation in reverse has 2 unknowns.  We know field<sub>i+1</sub> and b, but we don\'t know field<sub>i</sub> or s<sub>i</sub>.\r\n\r\n\r\nSo am I interpreting that correctly that you wouldn\'t be able to serialized back from a big int to a UInt8[]? Is `Field.ofBits` only slow in the context of a circuit generating an actual proof?  How bad is it?  I\'m wondering if hashing a string and ""pulling a witness out of a hat"" would be appropriate almost all the time, but if reading a string raw directly off the state is required in a certain case, then we would have `StringCV.fromBits()` as an option?\r\n\r\nFor a use case, let\'s say the most recent person to earn access to a puzzle gets to sign their name to some state called `lastWinner` and we want to let them use letters, and we want anyone else to be able to read that state without already knowing it.  In this case we would likely never compute a proof where the value of this state is checked as an input, but anyone who attempts the snapp, from any client which may be running the source code, will be able to see what the last winner has to say to them.'), ('45930', '<img width=""395"" alt=""image"" src=""https://user-images.githubusercontent.com/36939461/153990882-1071c131-b600-44d2-8a5e-4f3a991d3626.png"">\r\n\r\nIt\'s possible that I\'m missing some property of 2^8 that I\'m not understanding.'), ('mitschabaude', ""No sorry @qcomps you misunderstood me. This is not a one-way function, it is actually the same as field.toBits / fromBits, just splitting the field into bytes (8-bit vectors) instead of single bits. The intention *was* that you can get the byte array back from the field. You get the byte array back like that:\r\n1.) Test the field's first 8 bits (bit 0 to 7) => store as first element of byte array\r\n2.) Test the field's bits 8 to 15 => store as second element of byte array\r\n3.) and so on\r\n\r\nIt's more efficient than fromBits because there are only 31 bytes, but 254 bits, and each of those bits will need a constraint in your circuit.\r\n\r\nFeel free to use your version with fromBits / toBits for now! I'll add something like outlined above to snarkyjs eventually""), ('mitschabaude', '@qcomps Try to think of it with the base 10 instead of 256. I can map a number to / from an array of digits like that:\r\n\r\ntoDigits: 21316 => [6, 1, 3, 1, 2]\r\n\r\nfromDigits: `let x = 6 + 1*10^1 + 3*10^2 + 1*10^3 + 2*10^4`\r\n\r\nI did the same as fromDigits but with base 256. A byte is a number between 0 and 255 so toDigits can work.'), ('mitschabaude', 'I saw that my code above had some parentheses wrong, I think that tripped you up!'), ('mitschabaude', 'With ""pulling a witness out of your hat"" I didn\'t mean that it\'s not a real computation. It\'s just a computation done outside the circuit because splitting a Field into bits / bytes is not an operation that is directly possible in the circuit (but indirectly, as our example and the existing `toBits` function show)'), ('45930', 'Thanks for explaining further.  I have a mental model worked out now.\r\n\r\n<img width=""366"" alt=""image"" src=""https://user-images.githubusercontent.com/36939461/154081077-ce34d67a-7fd9-46b3-a2b1-17f2d014c81b.png"">\r\n'), ('45930', ""Synced with @mitschabaude more offline, and came up with this more efficient to/from Field interface:\r\n\r\n```\r\n  toField(): Field {\r\n    const values = this.value.map(x => x.value); // this.value is a UInt8[] circuit value\r\n    let field = Field.zero;\r\n\r\n    for (let i = 0, b = Field.one; i < Math.min(values.length, 31); i++, b = b.mul(256)) {\r\n      field = field.add(values[i].mul(b));\r\n    }\r\n    return field;\r\n  }\r\n\r\n  static fromField(field: Field): StringCircuitValue {\r\n    const values: UInt8[] = [];\r\n\r\n    field.toConstant().value[1].forEach((v) => {\r\n      values.push(UInt8.fromNumber(v))\r\n    }); // using the fact that a field constant is represented as a typescript UInt8[]\r\n\r\n    const stringVal = new StringCircuitValue('');\r\n    stringVal.value = values;\r\n    return stringVal;\r\n  }\r\n  ```\r\n  \r\n  Passes this test:\r\n  \r\n  ```\r\n  describe('fromField', () => {\r\n  it('can serialize and deserialize from Field', () => {\r\n    const input = 'Input String 123'\r\n    const ztring = new StringCircuitValue(input);\r\n    const stringValue = StringCircuitValue.fromField(ztring.toField());\r\n    expect(stringValue.toString().replace(/\\0/g, '')).to.eq(input);\r\n  });\r\n});\r\n```""), ('mitschabaude', 'Nice! Just noting that if you want to use your `fromField` in a circuit, you still have to do the dance I described above with `Circuit.witness` and then checking that the UInt8[] does in fact compress back to the original field when passed to `toField`'), ('mitschabaude', 'Specifically, `field.toConstant()` will only work in one of two situations:\r\n\r\n1) The Field is already a constant (this is the case in your test), or\r\n2) You use `field.toConstant()` inside the callback you give to `Circuit.witness`. This works because that callback will only be executed during proof generation, and during proof generation all the witness values are known -- that\'s why we can look at a variable\'s ""value"".\r\n\r\nIn other situations than 1) and 2), like when we compile the circuit to a prover / verifier key, the notion of a ""variable\'s actual value"" doesn\'t make sense -- it\'s just a variable, something representing an abstract computation. So in that situation, we can\'t do things like pulling out the underlying Uint8Array, we can only do other abstract computations with it (like: Field.add, Field.mul)'), ('mitschabaude', 'Would still be nice to have something like this in snarkyjs! PR welcome'), ('45930', 'So it sounds like the fundamental issue to solve here is that we want to be able to prove things like substring, case-insensitive equality, and other things related to the properties of characters and their order within a string.  The current de facto string equality function uses bijective encoding, but we are after additional properties that are commonly relied on by devs than simply equality.\r\n\r\nI will pick this back up and try to get some simple functionality built out!'), ('mitschabaude', 'Yeah, basically we want `array of UInt8` with some nice helper methods')]"
91,JSON parsing inside circuit,jasongitmail,open,Pre-requisite: [dynamic array access](https://github.com/o1-labs/snarkyjs/issues/90). ,[]
90,Dynamic array access,jasongitmail,open,,"[('mitschabaude', 'Depends on implementation of extended lookup tables: https://github.com/o1-labs/proof-systems/pull/250'), ('jasongitmail', 'Relate:, see https://github.com/o1-labs/snarkyjs/issues/633 from ZBP2, but note that it was built at a time when extended lookup tables were not available in the underlying proof system.'), ('joseandro', '@mitschabaude can we close this one?'), ('mitschabaude', ""> @mitschabaude can we close this one?\r\n\r\n@joseandro we haven't integrated runtime tables in o1js yet so it's not done. But I think it can be closed for redundancy with https://github.com/o1-labs/o1js/issues/1086"")]"
89,Recursion / proof composition RFC,jasongitmail,closed,,"[('mitschabaude', '# Recursion RFC\r\n\r\n## The `Proof` class\r\n\r\nThe plan is to create a new class `Proof`, which can be customized by some mechanism to create a proof with a custom public input. For example, we could use a (verbose) decorator like we do with state:\r\n```ts\r\nclass MyProof extends Proof {\r\n  @publicInput(Field) myAge = PublicInput<Field>();\r\n}\r\n```\r\n\r\n> Side note: I\'m not sure what\'s better terminology -- ""public input"" or ""statement"". ""Statement"" is used in the OCaml code base. I prefer statement -- it\'s less jargon-y and gives more intuition about what it means. However, ""public input"" is the well-known term, could be less ambiguous to experts. TBD\r\n\r\nProofs like `MyProof` should be usable as an argument to `SmartContract` methods. Inside the method, they can be verified, and their public input can be used in the circuit. Example:\r\n\r\n```ts\r\n@method myMethod(proof: MyProof) {\r\n  proof.verify();\r\n  proof.myAge.assertGte(18); // check that the proof attests to ""age >= 18""\r\n}\r\n```\r\n\r\nWe can also expose the possibility to verify conditionally: `proof.verifyIf(b)` where `b: Bool`. If neither of those methods is called, the proof just wouldn\'t get verified (TBD: is this a gotcha?)\r\n\r\n## Creating proofs\r\n\r\nHow do we create proofs though? There should be two ways:\r\n* As output of a `@method` prover, i.e. the kind of proof that is also sent to a zkApp account. In this case, the Proof class is not user-defined, and the public input type is just the zkApp public input, `{ transaction: Field; atParty: Field }`, which is basically the hashed transaction. The API can be a small addition to the existing one for creating zkapp proofs:\r\n```ts\r\nlet transaction = await Mina.transaction(() => {...});\r\nlet proof: Proof<ZkappStatement> = await transaction.prove(); // NEW: .prove() returns something\r\n```\r\n* As output of a custom ""proof system"", which produces statements different from the zkapp statement. These proofs cannot sent to the network directly, they are ""rollup-only"" proofs, but they offer full flexibility in the kind of statements they prove.\r\n\r\n## Custom proof system\r\n\r\nThe terminology ""proof system"" here refers to a set of circuits. One example of a proof system is a `SmartContract` (every smart contract is a distinct proof system). Another example is the ""transaction snark"" that is used by Mina to merge in proofs produced by smart contracts.\r\n\r\nThese features hold in general: the circuits of a proof system can merge proofs from the same proof system, but also proofs from other proof systems if they know about the layout of their public input.\r\n\r\nWe could create custom proof systems just by extending `Proof`. This is example code copied from @imeckler\'s rollup draft:\r\n\r\n```ts\r\nclass RollupProof extends Proof<RollupStateTransition> {\r\n  // ... public input ...\r\n\r\n  @branch static processDeposit(\r\n    pending: MerkleStack<RollupDeposit>,\r\n    accountDb: AccountDb\r\n  ): RollupProof {\r\n    let before = new RollupState(pending.commitment, accountDb.commitment());\r\n    let after = new RollupState(pending.commitment, accountDb.commitment());\r\n    return new RollupProof(new RollupStateTransition(before, after));\r\n  }\r\n\r\n  // Is branch a good name?\r\n  @branch static merge(p1: RollupProof, p2: RollupProof): RollupProof {\r\n    p1.publicInput.target.assertEquals(p2.publicInput.source);\r\n    return new RollupProof(\r\n      new RollupStateTransition(p1.publicInput.source, p2.publicInput.target)\r\n    );\r\n  }\r\n}\r\n```\r\n\r\nHere, `@branch` is equivalent to what `@method` does for `SmartContract`: it declares a circuit.\r\n\r\nIn this API, we\'d also need a method to execute one of the branches, and create a proof of that execution. I think a good such API may be just *calling* them:\r\n\r\n```ts\r\nlet proof = await RollupProof.processDeposit(...);\r\n```\r\nA serious problem with this idea is that we need some required extra step at the return statement in the `@branch`, so it returns a `Promise`. \r\n\r\n## Open questions\r\n\r\nHow should we expose the public input?\r\n\r\n* We\'ll need *some* way of declaring a custom public input type, but there are many ways to achieve that.\r\n* the syntax above feels redundant, like with `State()`. But having something which can be assigned to `myAge` means we don\'t have to have a constructor. I\'d like to avoid a custom constructor for this class.\r\n* maybe we should avoid having user-defined names as class fields? Izzy\'s example uses `proof.publicInput` instead. The following would work, and I prefer it:\r\n```ts\r\nclass MyProof extends Proof<Field> {\r\n  publicInputType = Field;\r\n  \r\n  // ... branches\r\n}\r\n\r\nlet proof = new MyProof(Field(35));\r\nlet myAge: Field = proof.publicInput;\r\n```\r\n  The extra generic type param again feels redundant, but is needed in this variant to correctly type `proof.publicInput`. The `publicInputType` prop is needed for runtime access.\r\n  \r\n Misc questions:\r\n \r\n * Should we add the decorator `@branch` or just call it `@method` as well? `@method` should work because the decorator can figure out what to do depending on the class it\'s on\r\n  \r\n* Do we want to further dig ourselves into the hole of classes + `extend` as the main programming style?\r\n  \r\n* When the proof is a zkapp proof, should we expose the zkapp statement also in its unhashed version, i.e. expose the full transaction? Then we could make actual statements about previous transactions. But we would need to re-hash it in the snark, to tie it to the hashed version.\r\n\r\n\r\n'), ('mimoo', '> Side note: I\'m not sure what\'s better terminology -- ""public input"" or ""statement"". ""Statement"" is used in the OCaml code base. I prefer statement -- it\'s less jargon-y and gives more intuition about what it means. However, ""public input"" is the well-known term, could be less ambiguous to experts. TBD\r\n\r\nnot a fan of statement because IIUC in ZK theory it often refers to the tuple `(circuit, public_input)`. I was thinking that from a developer\'s point of view, programming languages often have private and public/exposed functions and types and so requiring a `public` or `pub` keyword in front of everything that\'s not secret would be good practice (for example, even declaration of the fields of the zkapp (state) might benefit from a redundant `pub` keyword).\r\n\r\n> We can also expose the possibility to verify conditionally\r\n\r\nIs this a legitimate usecase? I was thinking: what if they forget to call `verify`?\r\n\r\n> The terminology ""proof system"" here refers to a set of circuits\r\n\r\nit sounds to me like it might refer to proofs created with different proof systems (other than kimchi). Maybe kimchi circuits?\r\n\r\n>   // Is branch a good name?\r\n\r\nit confused me to no end the first time I read it. I don\'t have a suggestion but I don\'t like it'), ('mitschabaude', 'Thanks for the feedback @mimoo!\r\n\r\n> not a fan of statement because IIUC in ZK theory it often refers to the tuple (circuit, public_input). I was thinking that from a developer\'s point of view, programming languages often have private and public/exposed functions and types\r\n\r\nMakes sense to me to use the public/private analogy with programming 👍🏻 \r\n\r\n> > We can also expose the possibility to verify conditionally\r\n>\r\n> Is this a legitimate usecase? I was thinking: what if they forget to call verify?\r\n\r\nI think it would be a shame not to support it, since there\'s no way for the developer to do conditional verification if we don\'t provide it, and it\'s already built into Pickles. We could throw an error if neither `.verify()` nor `.verifyIf()` is called, so that not verifying becomes an explicit choice and can\'t be caused by oversight.\r\n\r\n> [proof system] sounds to me like it might refer to proofs created with different proof systems (other than kimchi). Maybe kimchi circuits?\r\n\r\nYeah, we shouldn\'t use ""proof system"" for this in the API\r\n\r\nI\'m starting to think it could be less confusing if we separated the classes for `Proof` and the ""proof system"". In this case, we need to come up with a better term for proof system. Maybe `MultiCircuit`?\r\n\r\nI wouldn\'t just call it ""kimchi circuits"" since what we expose is less general than that -- it\'s always a step + a wrap circuit, so a more precise name could be `PicklesCircuit`, but I think `MultiCircuit` may be clearer. With a separate class for the circuits we could also make it more clear that `SmartContract` is a type of `MultiCircuit`, with some extra stuff added to let it use Mina accounts etc.\r\n\r\nThe downside of separating `Proof` from `MultiCircuit` is that it would suggest they can exist independently. They can\'t -- for a `Proof` to be verified, we must have access to the compiled output of its associated `MultiCircuit`. So our API would need to tie a proof to one specific multi-circuit. Maybe the `MultiCircuit` should be what is declared, and the `Proof` type is just derived from that and never created by a user. That would be consistent with `SmartContract`.\r\n\r\n> Is branch a good name?\r\n\r\nMy current favorites are `@method` and `@circuit`:\r\n\r\n* `@method` is what we already use on `SmartContract` for declaring circuits. Reusing it could be good because its familiar, or bad/confusing because `@method` on `MultiCircuit` may not have the exact same behaviour as `@method` on `SmartContract`\r\n* I like `@circuit` because it\'s obvious'), ('bkase', '> A serious problem with this idea is that we need some required extra step at the return statement in the @branch, so it returns a Promise.\r\n\r\nCan’t we transform the function with the decorator to wrap it in the promise? I really like the “calling” the branches version.\r\n\r\nagree with your reasoning for reusing `@method` , I don’t think it’s too confusing and intellisense will help people not get confused. And `@circuit`.\r\n\r\nI like the version of Proof with the generic type parameter for the public input — this gives maximum power to consumers of the API if they want to do something crazy. Plus it keeps the knowledge of the public input shape in front when consuming one of those objects.\r\n\r\nI don’t have any great ideas about naming for proof vs the collection of recursive proofs, but this is something we should resolve here for sure.'), ('mitschabaude', 'I researched a bit in the direction of not using classes. Correct typing without syntax contortions would get **much** easier if we would just use a function for the `MultiCircuit`.\r\n\r\nFor example, I\'m able to get this to type-check. In particular, see how the circuit becomes a prover with the same name, which returns a Promise, which holds a type that is inferred from the `publicInput` parameter (that last bit is actually the hardest part).\r\n```ts\r\nlet myCircuit = MultiCircuit({\r\n  publicInput: UInt32,\r\n  circuits: {\r\n    someCircuit: {\r\n      privateInput: [Bool],\r\n      circuit(publicInput: UInt32, b: Bool) {\r\n        publicInput.add(9).equals(UInt32.from(10)).and(b).assertTrue();\r\n      },\r\n    },\r\n  },\r\n});\r\n\r\nlet p: Proof<UInt32> = await myCircuit.someCircuit(UInt32.one, Bool.true);\r\np.verify();\r\np.publicInput;\r\n```\r\nEverything has full intellisense. There aren\'t any weird hacks, lying to TS, assigning something which we don\'t need just to make TS happy, verbosity, ... Plus, we avoid all the problems people have with decorator support...\r\n\r\nAnyone in favor of seriously considering an approach like that? cc @bkase @mrmr1993 @imeckler \r\n\r\nEDIT: I modified the first version to pass in the public input to each circuit. We probably should allow for ""public outputs"" as well.\r\n\r\nIf no-one speaks up, I might implement this for now, because I already got the types working and the implementation will be quickly transferable to any other API surface'), ('mitschabaude', ""> Can’t we transform the function with the decorator to wrap it in the promise?\r\n\r\nWe should research that. My feeling was that you can't make TS diverge from the method signatures and prop types on a class""), ('mitschabaude', 'We decided to go with the function-based (not class-based) approach for non-smart-contract proofs for now, as an ""API experiment"" to see how everyone likes this alternative. This could help inform general directions taken in our API.\r\n\r\nHere is an example of using recursive proofs with a new primitive called `Program`. A `Program` is a collection of circuits which share the same public input. It\'s like a `SmartContract` but more general, and without the Mina-related functionality (like on-chain state etc). This example is fully implemented and working int [this PR](https://github.com/o1-labs/snarkyjs/pull/250).\r\n\r\n\r\n```ts\r\nimport { SelfProof, Field, Program } from \'snarkyjs\';\r\n\r\nlet MyProgram = Program({\r\n  publicInput: Field,\r\n\r\n  methods: {\r\n    baseCase: {\r\n      privateInput: [],\r\n\r\n      method(publicInput: Field) {\r\n        publicInput.assertEquals(Field.zero);\r\n      },\r\n    },\r\n\r\n    inductiveCase: {\r\n      privateInput: [SelfProof],\r\n\r\n      method(publicInput: Field, earlierProof: SelfProof<Field>) {\r\n        earlierProof.verify();\r\n        earlierProof.publicInput.add(1).assertEquals(publicInput);\r\n      },\r\n    },\r\n  },\r\n});\r\n\r\nconsole.log(\'compiling MyProgram...\');\r\nawait MyProgram.compile();\r\n\r\nconsole.log(\'proving base case...\');\r\nlet proof = await MyProgram.baseCase(Field.zero);\r\n\r\nconsole.log(\'proving step 1...\');\r\nproof = await MyProgram.inductiveCase(Field.one, proof);\r\n\r\nconsole.log(\'proving step 2...\');\r\nproof = await MyProgram.inductiveCase(Field(2), proof);\r\n\r\nconsole.log(\'ok?\', proof.publicInput.toString() === \'2\');\r\n```\r\n\r\nTo use merge in from the `Program` itself, you use `SelfProof`, which means you don\'t have to set up an extra proof class. ([Here](https://github.com/o1-labs/snarkyjs/blob/feature/recursion-2/src/examples/simple_zkapp_with_proof.ts) is another example which merges proofs into a smart contract, and also uses a proof form a different smart contract, and extends `Proof` to create the necessary proof class.)\r\n\r\nSome smaller questions to bike-shed:\r\n\r\n* Should it be `privateInput` or `privateInputs`?\r\n* Should `methods` be an array, or an object?\r\n* Should it be called `Program`?\r\n* Should it be called `methods` and `method`?\r\n* Should it be called `SelfProof`?\r\n* Should we also have `OtherProof(OtherProgram)`, with the type `OtherProof<OtherPublicInput>`? This couldn\'t be used as easily in a SmartContract... because there we use decorators to find out the types of method arguments, and types need to exactly match names of values.\r\n\r\n## Function vs class-based proofs\r\n\r\nSpinning the last idea further, we could also ditch class definitions of proofs entirely. We could have:\r\n\r\n```ts\r\nlet MyProof = Proof(() => Program);\r\ntype MyProof = Proof<Field>;\r\n```\r\n\r\nCurrently we have the following general way of declaring a proof:\r\n```ts\r\nclass MyProof extends Proof<Field> {\r\n  static publicInputType = Field;\r\n  static tag = () => Program\r\n}\r\n```\r\n\r\nOr if we stick with class-based: Is ""tag"" a good name?\r\n\r\nIn both those examples `Program` can also be a `SmartContract`. \r\n\r\nThe tag needs to be passed in as function so you don\'t have a cyclic dependency of objects when you create a custom proof for a Program that references that proof itself.')]"
88,Sequencing support (a.k.a. sequence events),jasongitmail,closed,,[]
87,Restore prover keys,jasongitmail,closed,Motivation described well here: https://github.com/o1-labs/snarkyjs/issues/951,"[('mitschabaude', 'Verification key is done in the tx construction branch, TODO prover key'), ('mitschabaude', 'Prover key is only necessary as a performance improvement. Proof transactions can also be constructed by computing the prover key on the fly, which currently doubles the time to generate proofs. Removing from the tx construction epic, to be addressed in a (less-high-priority) performance improvement epic'), ('mitschabaude', ""this is actually harder than I thought first, because the JS code needs to be bundled in as well (it's called by the prover). bumping estimate to 3 days""), ('mitschabaude', ""JS code doesn't need to be bundled; pickles can be modified to return the parts it needs in addition to the user code, which is just imported as usual. However, I learned that the prover key is huge (100s of MBs). We should investigate whether some parts of it can be recomputed quickly on demand""), ('mitschabaude', 'Users asking for this feature, ""dramatic improvement to UX"": https://discord.com/channels/484437221055922177/1070570936799084554'), ('jasongitmail', 'Needs research & RFC or mini RFC'), ('shimkiv', 'Hundreds of megs were mentioned but is this the size of the raw data or we have a way to compress it? If compression is possible at all and makes sense.'), ('mitschabaude', ""> Hundreds of megs were mentioned but is this the size of the raw data or we have a way to compress it? If compression is possible at all and makes sense.\r\n\r\nAnswering that is part of this task. I imagine the data is mostly field elements. If those are very structured, e.g. lots of 0s and 1s each stored in 32 bytes, then general-purpose compression could indeed make a huge difference. But I don't recommend that the developer doing this treats the prover index as a black box blob of data"")]"
86,proving with Kimchi,jasongitmail,closed,,"[('mitschabaude', 'Closing as duplicate of #49')]"
85,Boolean field construct,jasongitmail,closed,Implemented. Added issue for progress tracking.,"[('mitschabaude', ""Closing because it's implemented :smile: "")]"
84,branchless conditional/ternary `.if()`,jasongitmail,closed,Implemented. Added issue for progress tracking.,[]
83,"Basic arithmetic (add, sub, mul, div) on fields",jasongitmail,closed,Implemented. Added issue for progress tracking.,[]
82,Local blockchain MVP,jasongitmail,closed,Implemented. Added issue for progress tracking.,[]
81,"UInt32, UInt64",jasongitmail,closed,,"[('jasongitmail', 'Implemented. Added issue for progress tracking.')]"
80,Events implementation,jasongitmail,closed,,[]
79,Admin handling,jasongitmail,closed,,"[('mitschabaude', ""I'm closing this, as we sort of decided to not have a dedicated API for this. We can open more specific issues for specific things we really want to add"")]"
78,Merkle tree support,jasongitmail,closed,,"[('Trivo25', 'I believe this can be closed?'), ('mitschabaude', 'Yes!')]"
77,Fetch snapp account state during execution,jasongitmail,closed,,"[('MartinMinkov', 'Closed with https://github.com/o1-labs/snarkyjs/pull/106')]"
76,Minimal @method decorator for end-to-end testing,jasongitmail,closed,,[]
75,Refactor to use a deploy() method instead of constructor,jasongitmail,closed,,"[('jasongitmail', 'Already done. Creating issue to track progress better.')]"
74,Tx construction,jasongitmail,closed,,"[('bkase', 'This is covered by an epic')]"
73,int64 support,jasongitmail,closed,,"[('mitschabaude', 'closing as duplicate of #66 ')]"
72,Support flows where fee-payer signs later,mitschabaude,closed,,"[('mitschabaude', 'done')]"
71,Make arrayProp work before isReady,mitschabaude,closed,This just means Circuit.array has to be ported to JS,"[('mitschabaude', 'Related: `Circuit.array` should have the methods expected on CircuitValues, like to/fromJSON\r\n\r\nShould resolve this: https://gist.github.com/marekyggdrasil/2a8fc00a86af5d05542e01667a4a2cd7')]"
70,Consider supporting mock snapp GraphQL API endpoint,jasongitmail,closed,"We could consider allowing devs to send transactions to Mina's mock/dry run API endpoint, which will show them the rest of a transaction without actually executing the transaction state changes on chain.

Low priority.","[('mitschabaude', 'dupe')]"
69,Make chrome/web and node/server consistent,mitschabaude,closed,,"[('mitschabaude', 'Refers to naming of folders in our repo'), ('mitschabaude', 'done')]"
68,"Add longer forms, `lte`-> `lessThanOrEqual`",mitschabaude,closed,and deprecate (but not remove) short forms,"[('Trivo25', 'Is this still something we want to do?'), ('mitschabaude', ""dang, I forgot this. I assume our reasoning for why we wanted this didn't change -- so, yes!""), ('Trivo25', 'No worries! I was just going through the list to get myself an overview, and potentially sort out out-to-date issues :D ')]"
67,Code style clean-up,mitschabaude,closed,"Whenever there is time, I'd like to go through the code base to address the following stylistic points (copied from the discussion on PR #36)

* scan the code base for usage of promises that can be simplified / made more readable by using async / await
* don't use type annotations in assignments or function return signature, except where necessary
* Classes which don't have instance methods should just be types instead. That removes the need for a constructor and makes the code less painful.
* It would be less confusing to me if ""signatureSufficient"" would instead be called ""proofNecessary"", and the Bool negated (if that's accurate)
* IMO it's easier to understand the purpose of a file if all its exports are listed at the very top (after the imports)
* (TBD) I'm not a fan of having many names for the same types / classes
","[('mitschabaude', 'We seem to have slowly molded the code base to the preferences expressed above in an organic way, by always making stuff we worked on look like we wanted it to look. Closing')]"
66,Finish `Int64` implementation,mitschabaude,closed,,"[('jasongitmail', '@mitschabaude Are aspects of the Int64 implementation remaining? Still need code review?')]"
65,`inProver` returns true in unexpected places,mitschabaude,closed,"`Circuit.inProver` seems to behave weird with the current implementation.
They are false in the beginning but stay true after the first `Mina.transaction` was run

(Observed in simple SmartContract example, needs proper investigation)","[('mitschabaude', 'Very likely caused by asyncness of `Circuit.runAndCheck`'), ('mitschabaude', ""This is still present, and not caused asyncness of Circuit.runAndCheck. Should be resolved by\n* understanding snarky's global state better\n* when possible, using the more reliable JS versions of inProver / inCheckedCopmutation""), ('mitschabaude', 'Solution is to use the JS version of inProver everywhere and remove the other one'), ('mitschabaude', 'can be closed for now since we use the JS version everywhere')]"
62,Add keccak256 hash support,jasongitmail,open,,"[('imengmengda', ""Hello,  Jason. I'm interested in this feature.Moreover, I think it would be nice to add RSA signature verification to snarkyjs. But it's a bit difficult to implement it in existing libraries.""), ('jasongitmail', ""Hi @imengmengda! Thanks for mentioning this. It'd be great to receive a PR for this or other functionality for SnarkyJS, if you're interested.\r\n\r\nI discussed this with one of O1's cryptographic engineers for more details, and it sounds like this will be much easier to implement after APIs exist for lookups & range checks in both Kimchi and SnarkyJS. We don't have an estimate on when those may be available yet, but I'll update here when they're available or when we have more info.""), ('jasongitmail', ""Update: O1's crypto team is adding Keccak256 to Kimchi, for optimal performance. The SnarkyJS-related portion will be very easy, once it's done within Kimchi.""), ('xhliu', 'Is it checked in yet? Also can u add `sha256` support?'), ('jasongitmail', ""@xhliu Not yet. O(1) Labs' crypto team is working to add Keccak256 within Kimchi itself, for optimal performance. Currently they're prioritizing work for launching Berkeley Testnet and then will be able to focus on this. When Keccak256 is available within Kimchi, adding this method in SnarkyJS will be very quick.  They're also planning to add sha256 support within Kimchi, but that will be prioritized after Keccak256""), ('xhliu', 'I can always code my own sha256 in Typescript using `snarkyjs`, right?\r\n```ts\r\nsha256(Field preimage): Field\r\n```\r\n\r\nIt is just not as performant as adding it within Kimchi.'), ('xhliu', 'BTW, what does this commit https://github.com/o1-labs/snarky/pull/489 do, regarding sha256?'), ('mitschabaude', ""> BTW, what does this commit [o1-labs/snarky#489](https://github.com/o1-labs/snarky/pull/489) do, regarding sha256?\r\n\r\nIt's a 2 year old commit which deletes bindings to some C/libsnark code. We don't use libsnark anymore, and don't bind into C anymore. So I'd just ignore that commit, it's irrelevant to any functionality we can offer now.\r\n\r\n> I can always code my own sha256 in Typescript using snarkyjs, right?\r\n\r\nYes! I'd be really interested in how feasible this is. If you want to try, I'm happy to help wherever you get stuck"")]"
61,Add secp256k1 signature verification support,jasongitmail,open,,"[('Comdex', ""I'm interested in this feature. Also, it would be nice to add RSASSA-PKCS1-v1_5 signature verification and SHA256 hash support.\r\nIn this way, we can take advantage of the existing Internet infrastructure, such as the SubtleCrypto interface, which is widely supported by browsers, to manage the keys that can be used to control snapp. SubtleCrypto supports non-exportable keys to prevent the risk of disclosure of plaintext private keys."")]"
59,Create more useful CI tests,bkase,closed,,"[('mitschabaude', 'CI tests are useful now! => closing')]"
58,[BUG] UInt64.assertGt and UInt32.assertGt do not work correctly,Comdex,closed,"https://github.com/o1-labs/snarkyjs/blob/e08f981166be59d962e9cfa196da1ae7e33f1368/src/lib/int.ts?_pjax=%23repo-content-pjax-container#L153

Hi, these two methods(**UInt64.assertGt and UInt32.assertGt**) do not work correctly, as shown in the code. Is the assertGte method also missing?","[('0b01', 'Do you have a minimal reproducible example? It appears to be correct as `a < b === b > a`'), ('mitschabaude', 'Agreed that the `assertGt` code looks correct, and agreed that `assertGte` is missing. Will fix the latter'), ('Comdex', '@0b01 @mitschabaude  I\'m sorry that I may not have described the problem correctly. I am confused by the result of the following code, which raises an exception when running check() and is normal when running check1().  The purpose of both methods is to compare the size of the numbers, and I understand that their results should be the same.\r\n\r\n```\r\nimport {\r\n  Field,\r\n  PrivateKey,\r\n  PublicKey,\r\n  SmartContract,\r\n  state,\r\n  State,\r\n  method,\r\n  UInt64,\r\n  Mina,\r\n  Party,\r\n  isReady,\r\n  shutdown,\r\n  Circuit\r\n} from \'snarkyjs\';\r\n\r\nclass Exercise1 extends SmartContract {\r\n  @state(UInt64) x: State<UInt64>;\r\n\r\n  constructor(initialBalance: UInt64, address: PublicKey, x: UInt64) {\r\n    super(address);\r\n    this.balance.addInPlace(initialBalance);\r\n    this.x = State.init(x);\r\n  }\r\n\r\n  @method async check(num: UInt64) {\r\n    const x = await this.x.get();\r\n\t Circuit.asProver(() => {\r\n        console.log(""x: "", x.toString());\r\n      });\r\n    x.assertGt(num);\r\n  }\r\n  \r\n  @method async check1(num: UInt64) {\r\n    const x = await this.x.get();\r\n\t Circuit.asProver(() => {\r\n        console.log(""x: "", x.toString());\r\n      });\r\n   x.lt(num).assertEquals(false);\r\n   //num.assertLt(x); also throw exception\r\n  }\r\n}\r\n\r\nexport async function run() {\r\n  await isReady;\r\n\r\n  const Local = Mina.LocalBlockchain();\r\n  Mina.setActiveInstance(Local);\r\n  const account1 = Local.testAccounts[0].privateKey;\r\n  const account2 = Local.testAccounts[1].privateKey;\r\n\r\n  const snappPrivkey = PrivateKey.random();\r\n  const snappPubkey = snappPrivkey.toPublicKey();\r\n\r\n  let snappInstance: Exercise1;\r\n  const initSnappState = UInt64.fromNumber(2000000000);;\r\n\r\n  // Deploys the snapp\r\n  await Mina.transaction(account1, async () => {\r\n    // account2 sends 1000000000 to the new snapp account\r\n    const amount = UInt64.fromNumber(1000000000);\r\n    const p = await Party.createSigned(account2);\r\n    p.balance.subInPlace(amount);\r\n\r\n    snappInstance = new Exercise1(amount, snappPubkey, initSnappState);\r\n  })\r\n    .send()\r\n    .wait();\r\n\r\n  // check\r\n  await Mina.transaction(account1, async () => {\r\n\t\r\n    await snappInstance.check(UInt64.fromNumber(1000000000));\r\n  })\r\n    .send()\r\n    .wait()\r\n\t.catch((e) => {\r\n\t\tconsole.log(e);\r\n\t}); ;\r\n\r\n  const a = await Mina.getAccount(snappPubkey);\r\n\r\n  console.log(\'Exercise 1\');\r\n  console.log(\'final state value\', a.snapp.appState[0].toString());\r\n}\r\n\r\nrun();\r\nshutdown();\r\n```'), ('Trivo25', 'I believe this can be closed?')]"
57,Getting the value of a Field using toString(),Muhammad-Altabba,closed,"Hello,
The `.toStrting()` is giving the value of the Field. I think this is a bug in the Mocking and not intended, right?
You can check how I am able to get the numeric value of `UInt64` here:
https://github.com/Muhammad-Altabba/snarkyjs-tender/blob/bf6ba9503fe905c65376237c18a81422c119cc28/src/sealed-bid-auction-snapp.ts#L90","[('mitschabaude', ""It's not a bug, but we'll have to think about the design so it's clear it's not a circuit calculation. Closing this because #40 describes the problem better"")]"
56,"When using `Circuit.if(...)`, Error: rangeCheckHelper: Expected 289...661 to fit in 64 bits",Muhammad-Altabba,closed,"Hello,
When using `Circuit.if(...)` an exception occurs:

> Error: rangeCheckHelper: Expected 28948022309329048855892746252171976963363056481941560715954676764349966633661 to fit in 64 bits
    at Jv (eval at Be (:3010/js/chunk-QIK4YCST.js:7670), <anonymous>:3210:1356)
    at eval (eval at Be (:3010/js/chunk-QIK4YCST.js:7670), <anonymous>:3210:8522)
    at am (eval at Be (:3010/js/chunk-QIK4YCST.js:7670), <anonymous>:4:23673)
    at Object.eval [as rangeCheckHelper] (eval at Be (:3010/js/chunk-QIK4YCST.js:7670), <anonymous>:4:80689)
    at z.lte (:3010/js/chunk-QIK4YCST.js:8582)
    at z.lt (:3010/js/chunk-QIK4YCST.js:8590)
    at SealedBidAuctionSnapp.bid (:3010/js/sealed-bid-auction-snapp-HCY3URRZ.js:52)
    at :3010/js/sealed-bid-auction-snapp-HCY3URRZ.js:135
    at :3010/js/chunk-QIK4YCST.js:8980
    at As (eval at Be (:3010/js/chunk-QIK4YCST.js:7670), <anonymous>:3210:24862)


To reproduce, uncomment the commented lines at https://github.com/Muhammad-Altabba/snarkyjs-tender/blob/bf6ba9503fe905c65376237c18a81422c119cc28/src/sealed-bid-auction-snapp.ts#L80 and run the project.

Is this an expected behavior? Could you please elaborate on this?

Thanks in advace,

 ","[('jasongitmail', 'Thank you! Looks like this is tracked over here: https://github.com/o1-labs/snarkyjs/issues/174')]"
55,[BUG] Mina.LocalBlockchain() allows multiple snapps to share an address and state,mirceanis,open,"It appears that multiple snapps can be deployed to the same address using snarkyjs v0.1.11 and LocalBlockchain().
The second deployment transaction doesn't fail silently, it actually executes and allows an outsider to overwrite the existing state.

I made a small proof of concept for this bug here: https://gist.github.com/mirceanis/b53b6acd0dbe6f1658c78706800736d5, based on one of the exercises from the workshop.

1. deploy `contract1` with initial state and logic to `snappPublicKey`
    * everything runs normally
2. deploy `contract2` to the same `snappPublicKey`
    * this should have failed but doesn't
    * It also works if the initial state is different, and existing state gets overridden
    * also, it doesn't matter if it's the same account performing the deployment. An external party can also do it.
3. existing state of the old contract is overridden by the new initial state of the new contract
    * this should not even be possible if 2. is fixed
4. execute code from `contract2`, works and updates the state
    * also should not work if 2. is fixed, but I thought I'd mention it since it may be related.
5. execute code from `contract1` still works, with old contract logic, but over the new state
    * this is even weirder, since the new contract is not an ""upgrade"", but rather a ""sibling"" of the same address, sharing the same state

I suppose this is only an issue with the mock local blockchain, but I can't test the real thing yet :)

Even so, I believe that fixing this bug is important even before testnet snapps, since it should make it clearer to devs which parts of the code actually matter for circuits and building the security model of snapps.
","[('mirceanis', 'This may be related to #52, #47, #50.\r\nI suppose that if the snapp deployment model is changed, this might not manifest anymore.'), ('mirceanis', 'This is still present in version 0.2.0\r\n\r\nI updated the gist with the code that reproduces this: https://gist.github.com/mirceanis/b53b6acd0dbe6f1658c78706800736d5')]"
54,[feature request] exposing/(de)serializing proof and verification key,Trivo25,closed,"Thins idea was also mentioned in Discord.

**Idea:** Potentially allowing to ""export"" and ""import"" proofs and their coressponding verification key to allow verification and proofing of code outside of the Mina blockchain, inside of web2.0.

**Reason:** It would open up SnarkyJS to more developers, allowing many web 2.0 devs and other developers to utilize the power of zero knowledge proofs to some extend in normal web applications.

**Possible usage:** What it could look like


```ts
// example from ex00_preimage.ts

class Main extends Circuit {
  @circuitMain
  static main(preimage: Field, @public_ hash: Field) {
    Poseidon.hash([preimage]).assertEquals(hash);
  }
}

// ... 

let proof = Main.prove(/* .. */); // returns the proof
let encodedProof = proof.toBase58()) // potentially encoded in base58 for easy use eg 'RJcTKtswS9xgY4FDfxCq4ZaLRfQwGME8GYPFGpxieWZXJMGUuqN1zdKYEM6dLZER'  

let verificationKey = Main.getVerificationKey(); // returns the verification key; potentially also encoded for easy use

// usage in a different application

class MyVerifier extends Verifier {
  constructor(key: VerificationKey) {
     // ...
  }
}

let verificationKey = 'someVerificationKeyEncoded';
let myVerifier = new Verifier(VerificationKey.fromString(verificationKey))

let proof = 'someProofEncoded';
let isValid = myVerifier.verify(Proof.fromString(proof)); // returns true if proof matches verification key


```

Is something like that feasible and makes sense?
Or is something like that potentially even planned already?

Thanks!

","[('Scratch-net', '@Trivo25 is it implemented? It would be nice to have both compiled circuits and keys to be exportable for off-chain applications'), ('Trivo25', ""> @Trivo25 is it implemented? It would be nice to have both compiled circuits and keys to be exportable for off-chain applications\r\n\r\nYes, proofs can be serialized as well as verification keys (of smart contract as well as the ZkProgram API). The prover key can't be currently serialized but there's a separate issue for that https://github.com/o1-labs/snarkyjs/issues/87""), ('Scratch-net', 'Ok, I was just playing with a plain circuit and could not find it')]"
53,[feature request] Decouple signing from transaction creation,mirceanis,closed,"In current snarkyjs (v0.1.11) creating and sending a transaction looks like this:
```ts
await Mina.transaction(senderPrivateKey, async () => {
    // transaction code
  })
    .send()
    .wait();
```

This means that the frontend code that creates the transaction and waits for it also has access to the private key.
I think it would be very useful to be able to create transactions without having direct access to the key, but rather by getting access to a signer object.

A back of the napkin example would be something like this:

```ts
interface MinaSigner {
  sign: (data: Uint8Array) => Promise<Uint8Array>
}

class SimpleSigner implements MinaSigner {
  constructor(privateKey: string) {}
  async sign(data: Uint8Array): Promise<Uint8Array> {
      // ...implement the actual signing
  }
}

const senderSigner = new MinaSigner(senderPrivateKey)

await Mina.transaction(senderSigner, async () => {
    // transaction code
  })
    .send()
    .wait();
```

The benefit of this approach is that you can separate concerns more cleanly between key management and frontend code.
You can let a wallet or an HSM handle keys and not have to trust that the frontend has no vulnerability that allows someone to sniff keys.","[('mitschabaude', ""Hey, thanks a lot for the feedback. This is on our testnet roadmap, the idea is that snarkyJS will only handle the transaction construction, and signing/sending is done by either another library or - preferably! - by interfacing with a browser wallet. We are in contact with the Auro wallet to make that work.\r\n\r\nIt's good to have it in its own github issue!""), ('mirceanis', 'Excellent!\r\n\r\nI\'m developing a framework for verifiable data and decentralized identitiy (https://veramo.io) and would like to integrate snapps and some snarkyjs circuit logic.\r\n\r\nThis separation of concerns is very important, since these 2 aspects of transaction lifecycle don\'t always live in the same app, or even on the same machine.\r\n\r\nAn intermediate solution is to be able to serialize/deserialize signed transactions.\r\nThis way, the ""signer"" can act on a higher level and also build the transactions, not just sign blind data, but then the logic that sends transactions and waits for them can still live in a frontend.\r\n\r\nDoes this make sense?\r\nI think serializing signed transactions is important for its own sake. I can create a different issue for that if you agree :)'), ('mitschabaude', 'Makes sense to me!\r\n\r\nRe: serializing transactions, to interact with browser extension we will have to send transactions with [postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), and if that works then serialization is probably only a small step away. So I think it can stay coupled to this issue.'), ('mitschabaude', 'This is done -- in current snarkyjs, you can leave out the fee payer key and sign with mina-signer')]"
52,Fix weird 3-way account interaction...,mitschabaude,closed,...in the current examples when funding a snapp account.,"[('mitschabaude', 'The snapp creator should be able to send the initial balance within the initial transaction'), ('mitschabaude', 'Fixed in the `simple_zkapp.ts` example - the issue is conflicting nonces when the fee payer incremented his nonce and then turned up in another party which had an outdated nonce precondition. Should add more intelligent, global nonce handling (separate issue).'), ('mitschabaude', 'Closing since a version where this is fixed (0.3.0) is already published')]"
51,Throw an error if a transaction fails,mitschabaude,closed,"Currently transactions tend to fail silently, which is discovered later when an account is not available or a state update didn't happen","[('mitschabaude', ""Mostly fixed! An instance where it can still happen will be fixed by https://github.com/MinaProtocol/mina/issues/10712\r\n\r\nOpen question: what feedback should we give when an account is modified in a transaction, but not sufficiently funded. This won't cause an error, but the account will simply not appear in the ledger, which also leads to counter-intuitive errors."")]"
50,"Enable calling other snapps, creating accounts, ...",mitschabaude,closed,"and deploying snapps from within a snapp.

Also, fix weird 3-way account interaction in the current examples when funding a snapp account.

This is a nice-to-have in the current mocked-blockchain situation, but a must-have once testnet is available.","[('mitschabaude', 'Closing\n* calling other zkApps is tracked by #185\n* creating accounts from a zkapp just means sending MINA there, is implemented\n* deploying zkapps from a zkapp means updating its verification key & permissions -- should just be possible already, but a bit esoteric, can get a separate issue whenever its needed and turns out to not be easy to do already\n* the 3-way account interaction is fixed')]"
49,Make proving/verifying work in SnarkyJS with kimchi,mitschabaude,closed,,"[('mitschabaude', 'Matt fixed the proving bug, and proving works for the low-level `Circuit` interface now.\n\nHowever, this isn\'t quite done, because recursive pickles proofs don\'t work yet (which are the ones we need for snapps). The issue is that they get returned as a `Deferred`, but deferred\'s never actually finish in JS, because there is no ""scheduler"" for them. I\'m trying to solve that now.'), ('mitschabaude', 'Pushed a branch which seems to solve the problem described above: https://github.com/MinaProtocol/mina/tree/feature/snarkyjs-pickles-proof\nThis makes a fairly wide-reaching change to the code base, and still has to be consolidated with develop\n\nHowever, a new issue turned up - a missing implementation of `Kimchi.Oracles.create` in the Wasm version'), ('mitschabaude', 'Set up this PR to fix the async prover issue: https://github.com/MinaProtocol/mina/pull/10454 '), ('mitschabaude', ""Multiple Wasm / bindings issues are fixed, and the proof seems to work - there's only an issue with asyncness left, where the proof is computed, but the promise that should hold it resolves early with a value of `undefined`""), ('mitschabaude', ""Proving works :tada: I'll devote another morning to see if I can get pickles verifying to work in JS as well, because that would be a nice sanity check. (Verifying already works for non-recursive proofs, so we shouldn't be too far off)""), ('mitschabaude', 'Verify works as well now 🎉\n\nThe only remaining TODO is to fix the regressions that come up when merging develop in the branch where it works (https://github.com/MinaProtocol/mina/pull/10267)'), ('mitschabaude', 'As snarkyjs is being merged in a version where everything works and is tested in CI, this can be closed :)')]"
48,"RFC / to discuss if we should add ""payable"" modifier for SnarkyJS methods",jasongitmail,closed,,"[('jasongitmail', ""Doesn't seem useful. Closing"")]"
47,API to expose public key of caller in SnarkyJS methods,mitschabaude,closed,,"[('mitschabaude', 'doesn\'t make sense to me, because the ""caller"" (fee payer) can be undefined in a transaction block (in fact, this is the intended default way of using snarkyjs, the fee payer should be added by a wallet)\n\nSo, it\'s unclear to me how the fee payer should be exposed in a circuit-safe way'), ('mitschabaude', ""actually this makes a lot of sense and should be done soon. It's fine to make access to the caller simply throw an error if it can't be accessed. while the _private key_ of the fee payer should be added by a wallet, the _public key_ should be made available to snarkyjs (from the wallet, possibly), because many methods will depend on it"")]"
46,"RFC for / discuss  a solution to manage integer overflows, if needed",jasongitmail,closed,,"[('mitschabaude', ""Can't remember what this was about, but we have UInt32 / UInt64 / Int64 for use in snarks, all of which don't allow overflows. Do you think we can close this?"")]"
45,"Write an RFC proposing a mechanism for showing the ""compiled constraint system"" ala godbolt",mitschabaude,open,,[]
44,More useful errors in snarkyjs,mitschabaude,closed,"* Include error strings in assertions somehow
* Don't throw arrays","[('mitschabaude', 'first bullet point is fixed, second is fixed in almost all cases, closing')]"
43,Field constructor vs static methods,mitschabaude,closed,Do we want stuff like `Field.fromBitstring()`?,[]
42,"For every section of the SnarkyJS, link to the relevant section of the docs (if helpful)",jasongitmail,closed,"E.g.
- https://docs.minaprotocol.com/en/snapps/how-snapps-work#deploying-a-smart-contract","[('barriebyron', 'docs restructure in place since this issue was created')]"
41,Review existing precondition implementation for API usability,bkase,closed,,[]
40,Bug: toString() on Field/Bool doesn't work outside of asProver blocks,bkase,closed,It could work everywhere,"[('mitschabaude', 'Partially fixed in [a branch](https://github.com/o1-labs/snarkyjs/tree/feature/method-decorator) by using a different function to run circuits. toString should work now with the mock transaction interface -- which properly creates an as_prover block now --, but still throws during Pickles.compile where it should also work'), ('mitschabaude', ""Will address this not by enabling `toString()` inside methods, but instead to throw a helpful error message (the former doesn't really make sense, since during compile a Field element is just an empty variable. there's no good stringification of that which wouldn't cause even more confusion) https://github.com/o1-labs/snarkyjs/issues/478\n\nclosing this one"")]"
39,"Naming: Replace all names of the form: ""ofX"" with ""fromX"". Additionally replace underscores with camel case.",MartinMinkov,closed,,"[('mitschabaude', 'fixed')]"
37,"During build, warn if unsupported JS/TS language constructs are used",jasongitmail,closed,"During SnarkyJS’ build, we could help guide developers by checking for unsupported language constructs  (e.g.  `throw`, conditionals, native ternaries) and warning developers. Likely using an abstract syntax tree to do this reliably.

Related: we want to set up matching ES Lint custom rules in the Snapp CLI's `projec-ts`, if possible, to warn developers as they wrote their app. ","[('jasongitmail', '*write'), ('jasongitmail', 'Done https://www.npmjs.com/package/eslint-plugin-snarkyjs')]"
32,Change tsconfig.json `target` value to ES2020,MartinMinkov,closed,"Izaak has reported that decorators don't behave as expected on the `feature/workshop-examples` branch. By changing the `target` value from `esnext` to `es2020`, the decorator error he was experiencing was fixed. Further work should be made to figure out why this was a breaking change.

Because `esnext` targets the highest version of TypeScript that the project supports, maybe we should be more conservative with how we specify the `target` value.

Playground link of correct behavior:
https://www.typescriptlang.org/play?ts=4.4.4#code/GYVwdgxgLglg9mABMOcAUAPAXIsIC2ARgKYBOAlIgN4BQNpxUIpSoksCiaUAFjAM44AhmACeAGkRQhpAOaNhYyQGtionPyikYYWZVqJDiCAn5wANsQB05uLLQByAYgCCDydLmMrJsJtIg0HCkiAC84a7kANw0RsamFta29g68YALuUnz80bFGvmaWNnaOUJme8lC5cQDyhABWxNBWACbEwDrEAAqkcAAOZFCi3DKVKmqSVIj8ClwYlKEAfNTxfonFKTNQUGQO5AC+kpU4aAvLDiakDNAO++Q0+w80QoT+QtDG5kL8-IgAQtQ6I86BAvj9XIhiBgdmAWr8AYC4gABFDoACMAAZ7nFsNMtDpZDE8oYClpAlBgqdEXEjPwQANSKdiXFeAIrBgwogHAB3Xq6BwxOKPR6kxBCTlgYjc1ynIkFdbJNBCdn3IA

Output should specify the variable `x` as the value ""correct"" when run. On commit `953cc6020966e90e36f3410237a64a0d16dcc6c5`, the same example is in `index.ts` and fails to set the variable correctly with the same code as the playground. To run the code on commit `953cc...`, run `npm run exec`","[('mitschabaude', 'Interesting! Here is more background on what exactly is the relevant change between es2021 and es2022:\r\nhttps://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#the-usedefineforclassfields-flag-and-the-declare-property-modifier\r\n\r\nI tried it out and if you leave ""target"" at ""esnext"", but set `""useDefineForClassFields"": false`, then you also get the ""correct"" behaviour. I don\'t have anything against switching to ES2020 right now, but it\'s good to know that our library users can still have esnext output if they want.'), ('mitschabaude', 'FWIW, in the ""esnext"" version the class field is implemented by Typescript using an actual JavaScript class field:\r\n\r\n```js\r\nclass A extends B {\r\n    x;\r\n    constructor() {\r\n        super();\r\n        this.x = \'wrong\';\r\n    }\r\n}\r\n__decorate([\r\n    foo(10),\r\n    __metadata(""design:type"", String)\r\n], A.prototype, ""x"", void 0);\r\n```\r\nSo we\'re sort of asking TS to break spec\'ed JS behaviour. But I think no problem for now because decorators will take a while to come to JS, and will also be quite different in JS than now in TS, so we may want to revisit our assumptions of decorator behaviour when this time has come and not now.')]"
31,streamline releases,mimoo,closed,"it'd be nice to leverage CI as much as possible to perform releases.

> (Optional) Automatic releases and changelog, using Semantic release, Commitizen, Conventional changelog and Husky (for the git hooks)

from https://github.com/alexjoverm/typescript-library-starter

@mitschabaude points to https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages also","[('mitschabaude', 'dupe')]"
26,Change `assertBoolean()` > `assertBool()`,jasongitmail,closed,For consistency given we use `new Bool()`.,[]
25,Remove spin lock hack,mitschabaude,closed,"This is a longer-term issue that probably requires some ocaml code to be rewritten to expect Promises when calling into the Wasm produced by Rust (marlin_plonk_bindings).

We currently have an awful hack in JS land just to present functions as sync to the JSOO code that in reality are async, context here:

https://o1-labs.slack.com/archives/C028Q27R8UC/p1633028074087000

It would make the JS project so much nicer if we could avoid this and deal with Promises from end to end","[('mitschabaude', 'dupe of #227')]"
20,Make more user friendly to use in a Snapp UI,jasongitmail,closed,,"[('mitschabaude', 'I think this has been partially addressed and is too vague to spawn further action, closing')]"
19,Support async loading,jasongitmail,closed,,"[('mitschabaude', ""Supported via using `isReady` in an async block. Most of the class declarations can be done outside that block.\r\n#71  tracks a decorator that should work before isReady, but currently doesn't"")]"
18,Ensure tree shaking is used during the build,jasongitmail,closed,We need to get the client bundle size _much_ smaller.,"[('mitschabaude', 'I already poked into this a bit and want to dump my current state of thoughts:\r\n\r\nThe bundle size is dominated by the jsoo-generated code, `snarky_js_chrome.bc.js`\r\n\r\nSadly, this code is generated in an inherently un-treeshakeable style. Boiled down to the essentials it is of the following form:\r\n```js\r\nlet globalObject = {};\r\n\r\n// module 1 (corresponds to an ocaml module)\r\nglobalObject.export1OfModule1 = ...\r\nglobalObject.export2OfModule1 = ...\r\n\r\n// module2\r\n// ... does its things while assuming that the exports of module1 are already there, then:\r\nglobalObject.export1OfModule2 = ...\r\nglobalObject.export2OfModule2 = ...\r\n\r\n// ... and so on ...\r\n\r\n// final module. this module is the entry point of the jsoo build and provides the exports we need in JS\r\nglobalObject.finalExport1 = ...\r\nglobalObject.finalExport2 = ...\r\n\r\n// put global object on the window; thus, make it all available\r\nwindow.globalObject = globalObject;\r\n```\r\n(This is simplified of course. In actual code, each of the module parts above is wrapped in an IIFE, and these IIFEs itself seem to sometimes contain sub-globalObjects that get passed around.)\r\n\r\nSo first off, this won\'t be tree-shakeable because it is not an ES6 module. But for the simplified code above this is easy to fix: we just need a list of the finalExports, then we can strip away the last line `window.globalObject = globalObject;` and replace it with a real export:\r\n\r\n```js\r\nlet {finalExport1, finalExport2, ...} = globalObject;\r\nexport {finalExport1, finalExport2, ...};\r\n```\r\nThis seems to be what the ""transpile to ES6"" script by @nholland94 does (among other things): https://gist.github.com/nholland94/641ddb34b7ca1368c80cabe1d8c90beb\r\n\r\nHowever, this doesn\'t change the basic structure outlined above, which is multiple ""modules"" writing to a global object one after another. Even in ES6 form, this structure makes treeshaking impossible. This is because tree-shaking normally would work like this:\r\n* Figure out which finalExport is actually used (imported from another file).\r\n* Only keep the JS objects that this finalExport depends on.\r\n\r\nHowever, in the code above, every finalExport depends on the globalObject. So standard tree-shaking won\'t elimnate anything (because it will never eliminate the globalObject, and so almost none of the other code because all the module pieces touch the globalObject).\r\n\r\nIn concrete experiments with esbuild and google closure compiler (advanced mode), neither of them can eliminate obsolete code in a structure like the above.\r\n\r\nMy conclusion so far is: There is no way to make any significant bundle size improvements by treeshaking, without going deeper into parsing and transpiling the jsoo-generated code (in a way that knows about the module dependency graph on the ocaml side, or is able to reconstruct such a graph from the jsoo code).'), ('mitschabaude', 'Another, maybe related observation is that jsoo itself does seem to do proper dead code elimination. Thus, even if we managed to transpile the jsoo form into one that can be treeshaked, it is still not obvious that there would be large reductions of bundle size if our JS code actually needs most of the exports.\r\n\r\nSo the only ""simple"" strategy I can think of on the whole topic is to make multiple jsoo bundles, corresponding to multiple sets of exports that we might need.\r\n\r\nBut my higher-level conclusions on bundle size at this point are\r\n* that the ocaml -> JS pipeline inherently produces huge bundles, because of how much basic functionality is re-created / reformulated in an ocaml-compatible way\r\n* the only effective strategy to reduce the amount of code in the bundle is to rewrite stuff in JS, thus reduce the exports from ocaml to JS.\r\n* I should focus on other things that improve performance first (EDIT: after picking the low-hanging fruit of minifying, see next comment)'), ('mitschabaude', 'Bundle-size related good news is that a simple minifying step with esbuild reduces the chrome bindings `.bc.js` from 26MB to 5.5MB:\r\n\r\n```sh\r\nesbuild --minify snarky_js_chrome.bc.js --outfile=chrome.min.js\r\n```'), ('jasongitmail', 'Not actionable with current architecture due to JS of OCaml code not being tree shakeable.')]"
17,Convert the build to output ES6,jasongitmail,closed,"Todo: Check with Nathan & Martin to ask about their latest progress, before starting.

Issue: [JS of OCaml](https://github.com/ocsigen/js_of_ocaml/issues) only builds to CommonJS.","[('mitschabaude', ""Initial progress: I tried to see why the existing ES6 version (in the `joo-to-es6-module-fix` branch) doesn't run and it seems almost all of the errors stem from jsoo trying to access global variables from what it thinks is the global object, e.g. `jsoo_global.Uint8Array`, while we don't provide this stuff on our modified `jsoo_global`. This should be easy to fix.\r\n\r\nHowever, see #18 for why I think that fixing this issue alone won't solve much"")]"
16,Get build to work on the client,jasongitmail,closed,,"[('mitschabaude', ""I'm not sure what this was referring to -- I assume getting snarkyjs working in a web browser? Closing for housekeeping"")]"
15,Change the build to output 4 artifacts,jasongitmail,closed,"- prover.js
- prover.key
- verifier.js 
- verifier.key","[('bkase', ""Note the verifier.js/verifier.key is only used for testing -- in production this is done on Mina's blockchain\r\n""), ('mitschabaude', 'This is more precisely tracked in #87 now')]"
1,Building Snarkette,idkjs,closed,"I would like to know how to build the dune dependency in https://github.com/o1-labs/snarkyjs. I am trying to learn to use a dune dependency in a js project as you did here by reading your code. It seems we are missing ""../../config.mlh"" required by the `dune` file. Can this script be provided?

error output:
```sh
mando@mandalarian ~/G/s/snarkette (master)> dune build
Info: Creating file dune-project with this contents:
| (lang dune 2.8)
File ""dune"", line 5, characters 20-36:
5 |  (preprocessor_deps ../../config.mlh)
                        ^^^^^^^^^^^^^^^^
Error: path outside the workspace: ../../config.mlh from default
```
Thank you.

Also, nice work on [ocamlbyexample](https://github.com/o1-labs/ocamlbyexample)!","[('mitschabaude', ""This is outdated - snarkyjs' ocaml parts don't live in this repo anymore. To build snarkyjs including its Ocaml and Rust dependencies, clone the Mina repo (https://github.com/MinaProtocol/mina), make sure to have submodules set up (`git submodule update --init --recursive`) and run `make snarkyjs`.\r\n\r\nThere are a lot of dependencies for getting the build to work, check out https://github.com/MinaProtocol/mina/blob/develop/README-dev.md""), ('idkjs', 'Thank you!')]"
